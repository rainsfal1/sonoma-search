"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@elastic";
exports.ids = ["vendor-chunks/@elastic"];
exports.modules = {

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\nconst {\n  Diagnostic,\n  Transport,\n  WeightedConnectionPool,\n  ClusterConnectionPool,\n  BaseConnectionPool,\n  CloudConnectionPool,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  Serializer,\n  errors,\n  events\n} = __webpack_require__(/*! @elastic/transport */ \"(rsc)/./node_modules/@elastic/transport/index.js\")\n\nconst { default: Client } = __webpack_require__(/*! ./lib/client */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/client.js\")\nconst { default: SniffingTransport } = __webpack_require__(/*! ./lib/sniffingTransport */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js\")\n\nmodule.exports = {\n  Client,\n  SniffingTransport,\n  Diagnostic,\n  Transport,\n  WeightedConnectionPool,\n  ClusterConnectionPool,\n  BaseConnectionPool,\n  CloudConnectionPool,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  Serializer,\n  errors,\n  events\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFvQjs7QUFFaEMsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLCtFQUFjO0FBQ2xELFFBQVEsNkJBQTZCLEVBQUUsbUJBQU8sQ0FBQyxxR0FBeUI7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgRGlhZ25vc3RpYyxcbiAgVHJhbnNwb3J0LFxuICBXZWlnaHRlZENvbm5lY3Rpb25Qb29sLFxuICBDbHVzdGVyQ29ubmVjdGlvblBvb2wsXG4gIEJhc2VDb25uZWN0aW9uUG9vbCxcbiAgQ2xvdWRDb25uZWN0aW9uUG9vbCxcbiAgQmFzZUNvbm5lY3Rpb24sXG4gIEh0dHBDb25uZWN0aW9uLFxuICBVbmRpY2lDb25uZWN0aW9uLFxuICBTZXJpYWxpemVyLFxuICBlcnJvcnMsXG4gIGV2ZW50c1xufSA9IHJlcXVpcmUoJ0BlbGFzdGljL3RyYW5zcG9ydCcpXG5cbmNvbnN0IHsgZGVmYXVsdDogQ2xpZW50IH0gPSByZXF1aXJlKCcuL2xpYi9jbGllbnQnKVxuY29uc3QgeyBkZWZhdWx0OiBTbmlmZmluZ1RyYW5zcG9ydCB9ID0gcmVxdWlyZSgnLi9saWIvc25pZmZpbmdUcmFuc3BvcnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xpZW50LFxuICBTbmlmZmluZ1RyYW5zcG9ydCxcbiAgRGlhZ25vc3RpYyxcbiAgVHJhbnNwb3J0LFxuICBXZWlnaHRlZENvbm5lY3Rpb25Qb29sLFxuICBDbHVzdGVyQ29ubmVjdGlvblBvb2wsXG4gIEJhc2VDb25uZWN0aW9uUG9vbCxcbiAgQ2xvdWRDb25uZWN0aW9uUG9vbCxcbiAgQmFzZUNvbm5lY3Rpb24sXG4gIEh0dHBDb25uZWN0aW9uLFxuICBVbmRpY2lDb25uZWN0aW9uLFxuICBTZXJpYWxpemVyLFxuICBlcnJvcnMsXG4gIGV2ZW50c1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/async_search.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/async_search.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass AsyncSearch {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'async_search.delete',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'async_search.get',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async status(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_async_search/status/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'async_search.status',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async submit(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'ext', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'knn', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) { // eslint-disable-line\n                    // @ts-expect-error\n                    querystring[key] = params[key];\n                }\n                else {\n                    // @ts-expect-error\n                    body[key] = params[key];\n                }\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_async_search`;\n        }\n        else {\n            method = 'POST';\n            path = '/_async_search';\n        }\n        const meta = {\n            name: 'async_search.submit',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = AsyncSearch;\n//# sourceMappingURL=async_search.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9hc3luY19zZWFyY2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5Q0FBeUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUNBQXlDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlDQUF5QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvYXN5bmNfc2VhcmNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBBc3luY1NlYXJjaCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hc3luY19zZWFyY2gvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnYXN5bmNfc2VhcmNoLmRlbGV0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hc3luY19zZWFyY2gvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnYXN5bmNfc2VhcmNoLmdldCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hc3luY19zZWFyY2gvc3RhdHVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2FzeW5jX3NlYXJjaC5zdGF0dXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN1Ym1pdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FnZ3JlZ2F0aW9ucycsICdhZ2dzJywgJ2NvbGxhcHNlJywgJ2V4cGxhaW4nLCAnZXh0JywgJ2Zyb20nLCAnaGlnaGxpZ2h0JywgJ3RyYWNrX3RvdGFsX2hpdHMnLCAnaW5kaWNlc19ib29zdCcsICdkb2N2YWx1ZV9maWVsZHMnLCAna25uJywgJ21pbl9zY29yZScsICdwb3N0X2ZpbHRlcicsICdwcm9maWxlJywgJ3F1ZXJ5JywgJ3Jlc2NvcmUnLCAnc2NyaXB0X2ZpZWxkcycsICdzZWFyY2hfYWZ0ZXInLCAnc2l6ZScsICdzbGljZScsICdzb3J0JywgJ19zb3VyY2UnLCAnZmllbGRzJywgJ3N1Z2dlc3QnLCAndGVybWluYXRlX2FmdGVyJywgJ3RpbWVvdXQnLCAndHJhY2tfc2NvcmVzJywgJ3ZlcnNpb24nLCAnc2VxX25vX3ByaW1hcnlfdGVybScsICdzdG9yZWRfZmllbGRzJywgJ3BpdCcsICdydW50aW1lX21hcHBpbmdzJywgJ3N0YXRzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdzb3J0JyAmJiB0eXBlb2YgcGFyYW1zW2tleV0gPT09ICdzdHJpbmcnICYmIHBhcmFtc1trZXldLmluY2x1ZGVzKCc6JykpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYXN5bmNfc2VhcmNoYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19hc3luY19zZWFyY2gnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnYXN5bmNfc2VhcmNoLnN1Ym1pdCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBc3luY1NlYXJjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jX3NlYXJjaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/async_search.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js":
/*!************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Autoscaling {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteAutoscalingPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'autoscaling.delete_autoscaling_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAutoscalingCapacity(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_autoscaling/capacity';\n        const meta = {\n            name: 'autoscaling.get_autoscaling_capacity'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAutoscalingPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'autoscaling.get_autoscaling_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putAutoscalingPolicy(params, options) {\n        var _a;\n        const acceptedPath = ['name'];\n        const acceptedBody = ['policy'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'autoscaling.put_autoscaling_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Autoscaling;\n//# sourceMappingURL=autoscaling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9hdXRvc2NhbGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDJDQUEyQztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvYXV0b3NjYWxpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEF1dG9zY2FsaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVBdXRvc2NhbGluZ1BvbGljeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hdXRvc2NhbGluZy9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdhdXRvc2NhbGluZy5kZWxldGVfYXV0b3NjYWxpbmdfcG9saWN5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXV0b3NjYWxpbmdDYXBhY2l0eShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fYXV0b3NjYWxpbmcvY2FwYWNpdHknO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2F1dG9zY2FsaW5nLmdldF9hdXRvc2NhbGluZ19jYXBhY2l0eSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdXRvc2NhbGluZ1BvbGljeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hdXRvc2NhbGluZy9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdhdXRvc2NhbGluZy5nZXRfYXV0b3NjYWxpbmdfcG9saWN5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0QXV0b3NjYWxpbmdQb2xpY3kocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsncG9saWN5J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fYXV0b3NjYWxpbmcvcG9saWN5LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnYXV0b3NjYWxpbmcucHV0X2F1dG9zY2FsaW5nX3BvbGljeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQXV0b3NjYWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvc2NhbGluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/bulk.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/bulk.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function BulkApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['operations'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = 'POST';\n        path = `/${encodeURIComponent(params.index.toString())}/_bulk`;\n    }\n    else {\n        method = 'POST';\n        path = '/_bulk';\n    }\n    const meta = {\n        name: 'bulk',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n}\nexports[\"default\"] = BulkApi;\n//# sourceMappingURL=bulk.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9idWxrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFpRDtBQUMzRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2J1bGsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEJ1bGtBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ29wZXJhdGlvbnMnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2J1bGtgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBwYXRoID0gJy9fYnVsayc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdidWxrJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYnVsa0JvZHk6IGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBCdWxrQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVsay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/bulk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function CapabilitiesApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/_capabilities';\n    const meta = {\n        name: 'capabilities'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = CapabilitiesApi;\n//# sourceMappingURL=capabilities.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jYXBhYmlsaXRpZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvY2FwYWJpbGl0aWVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBDYXBhYmlsaXRpZXNBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9ICcvX2NhcGFiaWxpdGllcyc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2NhcGFiaWxpdGllcydcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENhcGFiaWxpdGllc0FwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcGFiaWxpdGllcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cat.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/cat.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Cat {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async aliases(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_cat/aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/aliases';\n        }\n        const meta = {\n            name: 'cat.aliases',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async allocation(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_cat/allocation/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/allocation';\n        }\n        const meta = {\n            name: 'cat.allocation',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async componentTemplates(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_cat/component_templates/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/component_templates';\n        }\n        const meta = {\n            name: 'cat.component_templates',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async count(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/count/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/count';\n        }\n        const meta = {\n            name: 'cat.count',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async fielddata(params, options) {\n        const acceptedPath = ['fields'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.fields != null) {\n            method = 'GET';\n            path = `/_cat/fielddata/${encodeURIComponent(params.fields.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/fielddata';\n        }\n        const meta = {\n            name: 'cat.fielddata',\n            pathParts: {\n                fields: params.fields\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async health(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/health';\n        const meta = {\n            name: 'cat.health'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async help(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat';\n        const meta = {\n            name: 'cat.help'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async indices(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/indices/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/indices';\n        }\n        const meta = {\n            name: 'cat.indices',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async master(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/master';\n        const meta = {\n            name: 'cat.master'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async mlDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_cat/ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/data_frame/analytics';\n        }\n        const meta = {\n            name: 'cat.ml_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async mlDatafeeds(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/datafeeds';\n        }\n        const meta = {\n            name: 'cat.ml_datafeeds',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async mlJobs(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/anomaly_detectors';\n        }\n        const meta = {\n            name: 'cat.ml_jobs',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async mlTrainedModels(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/trained_models';\n        }\n        const meta = {\n            name: 'cat.ml_trained_models',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async nodeattrs(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/nodeattrs';\n        const meta = {\n            name: 'cat.nodeattrs'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async nodes(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/nodes';\n        const meta = {\n            name: 'cat.nodes'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async pendingTasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/pending_tasks';\n        const meta = {\n            name: 'cat.pending_tasks'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async plugins(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/plugins';\n        const meta = {\n            name: 'cat.plugins'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async recovery(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/recovery/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/recovery';\n        }\n        const meta = {\n            name: 'cat.recovery',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async repositories(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/repositories';\n        const meta = {\n            name: 'cat.repositories'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async segments(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/segments/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/segments';\n        }\n        const meta = {\n            name: 'cat.segments',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async shards(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/shards/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/shards';\n        }\n        const meta = {\n            name: 'cat.shards',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async snapshots(params, options) {\n        const acceptedPath = ['repository'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.repository != null) {\n            method = 'GET';\n            path = `/_cat/snapshots/${encodeURIComponent(params.repository.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/snapshots';\n        }\n        const meta = {\n            name: 'cat.snapshots',\n            pathParts: {\n                repository: params.repository\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async tasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/tasks';\n        const meta = {\n            name: 'cat.tasks'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async templates(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_cat/templates/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/templates';\n        }\n        const meta = {\n            name: 'cat.templates',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async threadPool(params, options) {\n        const acceptedPath = ['thread_pool_patterns'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.thread_pool_patterns != null) {\n            method = 'GET';\n            path = `/_cat/thread_pool/${encodeURIComponent(params.thread_pool_patterns.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/thread_pool';\n        }\n        const meta = {\n            name: 'cat.thread_pool',\n            pathParts: {\n                thread_pool_patterns: params.thread_pool_patterns\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async transforms(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = 'GET';\n            path = `/_cat/transforms/${encodeURIComponent(params.transform_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/transforms';\n        }\n        const meta = {\n            name: 'cat.transforms',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Cat;\n//# sourceMappingURL=cat.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jYXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4Q0FBOEM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDRDQUE0QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2Q0FBNkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQTRDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlDQUF5QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkNBQTZDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLCtDQUErQztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0Q0FBNEM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNENBQTRDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDRDQUE0QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQTJDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUEyRDtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtREFBbUQ7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2NhdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ2F0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBhbGlhc2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2F0L2FsaWFzZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2NhdC9hbGlhc2VzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5hbGlhc2VzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgYWxsb2NhdGlvbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC9hbGxvY2F0aW9uLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvYWxsb2NhdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQuYWxsb2NhdGlvbicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNvbXBvbmVudFRlbXBsYXRlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC9jb21wb25lbnRfdGVtcGxhdGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvY29tcG9uZW50X3RlbXBsYXRlcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQuY29tcG9uZW50X3RlbXBsYXRlcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNvdW50KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvY291bnQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvY291bnQnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0LmNvdW50JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmaWVsZGRhdGEocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnZmllbGRzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5maWVsZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2F0L2ZpZWxkZGF0YS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuZmllbGRzLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvZmllbGRkYXRhJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5maWVsZGRhdGEnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgZmllbGRzOiBwYXJhbXMuZmllbGRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaGVhbHRoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jYXQvaGVhbHRoJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQuaGVhbHRoJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGhlbHAocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NhdCc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0LmhlbHAnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaW5kaWNlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2F0L2luZGljZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvaW5kaWNlcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQuaW5kaWNlcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbWFzdGVyKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jYXQvbWFzdGVyJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQubWFzdGVyJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1sRGF0YUZyYW1lQW5hbHl0aWNzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvbWwvZGF0YV9mcmFtZS9hbmFseXRpY3MvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvbWwvZGF0YV9mcmFtZS9hbmFseXRpY3MnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0Lm1sX2RhdGFfZnJhbWVfYW5hbHl0aWNzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBtbERhdGFmZWVkcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydkYXRhZmVlZF9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuZGF0YWZlZWRfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2F0L21sL2RhdGFmZWVkcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuZGF0YWZlZWRfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2NhdC9tbC9kYXRhZmVlZHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0Lm1sX2RhdGFmZWVkcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBkYXRhZmVlZF9pZDogcGFyYW1zLmRhdGFmZWVkX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbWxKb2JzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuam9iX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC9tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvbWwvYW5vbWFseV9kZXRlY3RvcnMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0Lm1sX2pvYnMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbWxUcmFpbmVkTW9kZWxzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5tb2RlbF9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvbWwvdHJhaW5lZF9tb2RlbHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0Lm1sX3RyYWluZWRfbW9kZWxzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBub2RlYXR0cnMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NhdC9ub2RlYXR0cnMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5ub2RlYXR0cnMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbm9kZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NhdC9ub2Rlcyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0Lm5vZGVzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBlbmRpbmdUYXNrcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY2F0L3BlbmRpbmdfdGFza3MnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5wZW5kaW5nX3Rhc2tzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBsdWdpbnMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NhdC9wbHVnaW5zJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQucGx1Z2lucydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZWNvdmVyeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2F0L3JlY292ZXJ5LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fY2F0L3JlY292ZXJ5JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5yZWNvdmVyeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwb3NpdG9yaWVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jYXQvcmVwb3NpdG9yaWVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjYXQucmVwb3NpdG9yaWVzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNlZ21lbnRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvc2VnbWVudHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvc2VnbWVudHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0LnNlZ21lbnRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzaGFyZHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC9zaGFyZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvc2hhcmRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC5zaGFyZHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNuYXBzaG90cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydyZXBvc2l0b3J5J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5yZXBvc2l0b3J5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC9zbmFwc2hvdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJlcG9zaXRvcnkudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2NhdC9zbmFwc2hvdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0LnNuYXBzaG90cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5OiBwYXJhbXMucmVwb3NpdG9yeVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHRhc2tzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jYXQvdGFza3MnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC50YXNrcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB0ZW1wbGF0ZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvdGVtcGxhdGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvdGVtcGxhdGVzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC50ZW1wbGF0ZXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB0aHJlYWRQb29sKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3RocmVhZF9wb29sX3BhdHRlcm5zJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy50aHJlYWRfcG9vbF9wYXR0ZXJucyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jYXQvdGhyZWFkX3Bvb2wvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRocmVhZF9wb29sX3BhdHRlcm5zLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jYXQvdGhyZWFkX3Bvb2wnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2F0LnRocmVhZF9wb29sJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRocmVhZF9wb29sX3BhdHRlcm5zOiBwYXJhbXMudGhyZWFkX3Bvb2xfcGF0dGVybnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB0cmFuc2Zvcm1zKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3RyYW5zZm9ybV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMudHJhbnNmb3JtX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NhdC90cmFuc2Zvcm1zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2NhdC90cmFuc2Zvcm1zJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NhdC50cmFuc2Zvcm1zJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2F0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ccr.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ccr.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ccr {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'ccr.delete_auto_follow_pattern',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async follow(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['leader_index', 'max_outstanding_read_requests', 'max_outstanding_write_requests', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size', 'read_poll_timeout', 'remote_cluster'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/follow`;\n        const meta = {\n            name: 'ccr.follow',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async followInfo(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/info`;\n        const meta = {\n            name: 'ccr.follow_info',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async followStats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/stats`;\n        const meta = {\n            name: 'ccr.follow_stats',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async forgetFollower(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['follower_cluster', 'follower_index', 'follower_index_uuid', 'leader_remote_cluster'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/forget_follower`;\n        const meta = {\n            name: 'ccr.forget_follower',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ccr/auto_follow';\n        }\n        const meta = {\n            name: 'ccr.get_auto_follow_pattern',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async pauseAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/pause`;\n        const meta = {\n            name: 'ccr.pause_auto_follow_pattern',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async pauseFollow(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/pause_follow`;\n        const meta = {\n            name: 'ccr.pause_follow',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['remote_cluster', 'follow_index_pattern', 'leader_index_patterns', 'leader_index_exclusion_patterns', 'max_outstanding_read_requests', 'settings', 'max_outstanding_write_requests', 'read_poll_timeout', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'ccr.put_auto_follow_pattern',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resumeAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/resume`;\n        const meta = {\n            name: 'ccr.resume_auto_follow_pattern',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resumeFollow(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['max_outstanding_read_requests', 'max_outstanding_write_requests', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size', 'read_poll_timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/resume_follow`;\n        const meta = {\n            name: 'ccr.resume_follow',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ccr/stats';\n        const meta = {\n            name: 'ccr.stats'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async unfollow(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/unfollow`;\n        const meta = {\n            name: 'ccr.unfollow',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Ccr;\n//# sourceMappingURL=ccr.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jY3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUEyQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkNBQTJDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDJDQUEyQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2Njci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ2NyIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVBdXRvRm9sbG93UGF0dGVybihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jY3IvYXV0b19mb2xsb3cvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjY3IuZGVsZXRlX2F1dG9fZm9sbG93X3BhdHRlcm4nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmb2xsb3cocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydsZWFkZXJfaW5kZXgnLCAnbWF4X291dHN0YW5kaW5nX3JlYWRfcmVxdWVzdHMnLCAnbWF4X291dHN0YW5kaW5nX3dyaXRlX3JlcXVlc3RzJywgJ21heF9yZWFkX3JlcXVlc3Rfb3BlcmF0aW9uX2NvdW50JywgJ21heF9yZWFkX3JlcXVlc3Rfc2l6ZScsICdtYXhfcmV0cnlfZGVsYXknLCAnbWF4X3dyaXRlX2J1ZmZlcl9jb3VudCcsICdtYXhfd3JpdGVfYnVmZmVyX3NpemUnLCAnbWF4X3dyaXRlX3JlcXVlc3Rfb3BlcmF0aW9uX2NvdW50JywgJ21heF93cml0ZV9yZXF1ZXN0X3NpemUnLCAncmVhZF9wb2xsX3RpbWVvdXQnLCAncmVtb3RlX2NsdXN0ZXInXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2Njci9mb2xsb3dgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5mb2xsb3cnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGZvbGxvd0luZm8ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY2NyL2luZm9gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5mb2xsb3dfaW5mbycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZm9sbG93U3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY2NyL3N0YXRzYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjY3IuZm9sbG93X3N0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmb3JnZXRGb2xsb3dlcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2ZvbGxvd2VyX2NsdXN0ZXInLCAnZm9sbG93ZXJfaW5kZXgnLCAnZm9sbG93ZXJfaW5kZXhfdXVpZCcsICdsZWFkZXJfcmVtb3RlX2NsdXN0ZXInXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19jY3IvZm9yZ2V0X2ZvbGxvd2VyYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjY3IuZm9yZ2V0X2ZvbGxvd2VyJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBdXRvRm9sbG93UGF0dGVybihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2Njci9hdXRvX2ZvbGxvdy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fY2NyL2F1dG9fZm9sbG93JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5nZXRfYXV0b19mb2xsb3dfcGF0dGVybicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBhdXNlQXV0b0ZvbGxvd1BhdHRlcm4ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Njci9hdXRvX2ZvbGxvdy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vcGF1c2VgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5wYXVzZV9hdXRvX2ZvbGxvd19wYXR0ZXJuJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcGF1c2VGb2xsb3cocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2Njci9wYXVzZV9mb2xsb3dgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5wYXVzZV9mb2xsb3cnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dEF1dG9Gb2xsb3dQYXR0ZXJuKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyZW1vdGVfY2x1c3RlcicsICdmb2xsb3dfaW5kZXhfcGF0dGVybicsICdsZWFkZXJfaW5kZXhfcGF0dGVybnMnLCAnbGVhZGVyX2luZGV4X2V4Y2x1c2lvbl9wYXR0ZXJucycsICdtYXhfb3V0c3RhbmRpbmdfcmVhZF9yZXF1ZXN0cycsICdzZXR0aW5ncycsICdtYXhfb3V0c3RhbmRpbmdfd3JpdGVfcmVxdWVzdHMnLCAncmVhZF9wb2xsX3RpbWVvdXQnLCAnbWF4X3JlYWRfcmVxdWVzdF9vcGVyYXRpb25fY291bnQnLCAnbWF4X3JlYWRfcmVxdWVzdF9zaXplJywgJ21heF9yZXRyeV9kZWxheScsICdtYXhfd3JpdGVfYnVmZmVyX2NvdW50JywgJ21heF93cml0ZV9idWZmZXJfc2l6ZScsICdtYXhfd3JpdGVfcmVxdWVzdF9vcGVyYXRpb25fY291bnQnLCAnbWF4X3dyaXRlX3JlcXVlc3Rfc2l6ZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Njci9hdXRvX2ZvbGxvdy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5wdXRfYXV0b19mb2xsb3dfcGF0dGVybicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc3VtZUF1dG9Gb2xsb3dQYXR0ZXJuKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jY3IvYXV0b19mb2xsb3cvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9L3Jlc3VtZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2NyLnJlc3VtZV9hdXRvX2ZvbGxvd19wYXR0ZXJuJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdW1lRm9sbG93KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbWF4X291dHN0YW5kaW5nX3JlYWRfcmVxdWVzdHMnLCAnbWF4X291dHN0YW5kaW5nX3dyaXRlX3JlcXVlc3RzJywgJ21heF9yZWFkX3JlcXVlc3Rfb3BlcmF0aW9uX2NvdW50JywgJ21heF9yZWFkX3JlcXVlc3Rfc2l6ZScsICdtYXhfcmV0cnlfZGVsYXknLCAnbWF4X3dyaXRlX2J1ZmZlcl9jb3VudCcsICdtYXhfd3JpdGVfYnVmZmVyX3NpemUnLCAnbWF4X3dyaXRlX3JlcXVlc3Rfb3BlcmF0aW9uX2NvdW50JywgJ21heF93cml0ZV9yZXF1ZXN0X3NpemUnLCAncmVhZF9wb2xsX3RpbWVvdXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19jY3IvcmVzdW1lX2ZvbGxvd2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2NyLnJlc3VtZV9mb2xsb3cnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jY3Ivc3RhdHMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Njci5zdGF0cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1bmZvbGxvdyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY2NyL3VuZm9sbG93YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjY3IudW5mb2xsb3cnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2NyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2NyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ccr.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ClearScrollApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['scroll_id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = '/_search/scroll';\n    const meta = {\n        name: 'clear_scroll',\n        pathParts: {\n            scroll_id: params.scroll_id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ClearScrollApi;\n//# sourceMappingURL=clear_scroll.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jbGVhcl9zY3JvbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2NsZWFyX3Njcm9sbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gQ2xlYXJTY3JvbGxBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydzY3JvbGxfaWQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICBjb25zdCBwYXRoID0gJy9fc2VhcmNoL3Njcm9sbCc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2NsZWFyX3Njcm9sbCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgc2Nyb2xsX2lkOiBwYXJhbXMuc2Nyb2xsX2lkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsZWFyU2Nyb2xsQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xlYXJfc2Nyb2xsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ClosePointInTimeApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = '/_pit';\n    const meta = {\n        name: 'close_point_in_time'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ClosePointInTimeApi;\n//# sourceMappingURL=close_point_in_time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jbG9zZV9wb2ludF9pbl90aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvY2xvc2VfcG9pbnRfaW5fdGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gQ2xvc2VQb2ludEluVGltZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2lkJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgY29uc3QgcGF0aCA9ICcvX3BpdCc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2Nsb3NlX3BvaW50X2luX3RpbWUnXG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDbG9zZVBvaW50SW5UaW1lQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvc2VfcG9pbnRfaW5fdGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cluster.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/cluster.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Cluster {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async allocationExplain(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['current_node', 'index', 'primary', 'shard'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_cluster/allocation/explain';\n        const meta = {\n            name: 'cluster.allocation_explain'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'cluster.delete_component_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteVotingConfigExclusions(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_cluster/voting_config_exclusions';\n        const meta = {\n            name: 'cluster.delete_voting_config_exclusions'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async existsComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'cluster.exists_component_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_component_template';\n        }\n        const meta = {\n            name: 'cluster.get_component_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cluster/settings';\n        const meta = {\n            name: 'cluster.get_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async health(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cluster/health/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/health';\n        }\n        const meta = {\n            name: 'cluster.health',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async info(params, options) {\n        const acceptedPath = ['target'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_info/${encodeURIComponent(params.target.toString())}`;\n        const meta = {\n            name: 'cluster.info',\n            pathParts: {\n                target: params.target\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async pendingTasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cluster/pending_tasks';\n        const meta = {\n            name: 'cluster.pending_tasks'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postVotingConfigExclusions(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_cluster/voting_config_exclusions';\n        const meta = {\n            name: 'cluster.post_voting_config_exclusions'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['template', 'version', '_meta', 'deprecated'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'cluster.put_component_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putSettings(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['persistent', 'transient'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_cluster/settings';\n        const meta = {\n            name: 'cluster.put_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async remoteInfo(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_remote/info';\n        const meta = {\n            name: 'cluster.remote_info'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async reroute(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['commands'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_cluster/reroute';\n        const meta = {\n            name: 'cluster.reroute'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async state(params, options) {\n        const acceptedPath = ['metric', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.metric != null && params.index != null) {\n            method = 'GET';\n            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/state';\n        }\n        const meta = {\n            name: 'cluster.state',\n            pathParts: {\n                metric: params.metric,\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_cluster/stats/nodes/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/stats';\n        }\n        const meta = {\n            name: 'cluster.stats',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Cluster;\n//# sourceMappingURL=cluster.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jbHVzdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywyQ0FBMkM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkNBQTJDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkNBQTJDO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUE2QyxHQUFHLDRDQUE0QztBQUNsSTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkNBQTZDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsOENBQThDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jbHVzdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDbHVzdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBhbGxvY2F0aW9uRXhwbGFpbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnY3VycmVudF9ub2RlJywgJ2luZGV4JywgJ3ByaW1hcnknLCAnc2hhcmQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY2x1c3Rlci9hbGxvY2F0aW9uL2V4cGxhaW4nO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuYWxsb2NhdGlvbl9leHBsYWluJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNvbXBvbmVudFRlbXBsYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2NvbXBvbmVudF90ZW1wbGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuZGVsZXRlX2NvbXBvbmVudF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVZvdGluZ0NvbmZpZ0V4Y2x1c2lvbnMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NsdXN0ZXIvdm90aW5nX2NvbmZpZ19leGNsdXNpb25zJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjbHVzdGVyLmRlbGV0ZV92b3RpbmdfY29uZmlnX2V4Y2x1c2lvbnMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhpc3RzQ29tcG9uZW50VGVtcGxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdIRUFEJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2NvbXBvbmVudF90ZW1wbGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuZXhpc3RzX2NvbXBvbmVudF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldENvbXBvbmVudFRlbXBsYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY29tcG9uZW50X3RlbXBsYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jb21wb25lbnRfdGVtcGxhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2x1c3Rlci5nZXRfY29tcG9uZW50X3RlbXBsYXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NsdXN0ZXIvc2V0dGluZ3MnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuZ2V0X3NldHRpbmdzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGhlYWx0aChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2x1c3Rlci9oZWFsdGgvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jbHVzdGVyL2hlYWx0aCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjbHVzdGVyLmhlYWx0aCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0YXJnZXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2luZm8vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhcmdldC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuaW5mbycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHBhcmFtcy50YXJnZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwZW5kaW5nVGFza3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2NsdXN0ZXIvcGVuZGluZ190YXNrcyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2x1c3Rlci5wZW5kaW5nX3Rhc2tzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RWb3RpbmdDb25maWdFeGNsdXNpb25zKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY2x1c3Rlci92b3RpbmdfY29uZmlnX2V4Y2x1c2lvbnMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIucG9zdF92b3RpbmdfY29uZmlnX2V4Y2x1c2lvbnMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0Q29tcG9uZW50VGVtcGxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3RlbXBsYXRlJywgJ3ZlcnNpb24nLCAnX21ldGEnLCAnZGVwcmVjYXRlZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2NvbXBvbmVudF90ZW1wbGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIucHV0X2NvbXBvbmVudF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dFNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydwZXJzaXN0ZW50JywgJ3RyYW5zaWVudCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jbHVzdGVyL3NldHRpbmdzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjbHVzdGVyLnB1dF9zZXR0aW5ncydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZW1vdGVJbmZvKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19yZW1vdGUvaW5mbyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY2x1c3Rlci5yZW1vdGVfaW5mbydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXJvdXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjb21tYW5kcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY2x1c3Rlci9yZXJvdXRlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjbHVzdGVyLnJlcm91dGUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbWV0cmljJywgJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5tZXRyaWMgIT0gbnVsbCAmJiBwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY2x1c3Rlci9zdGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubWV0cmljLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2NsdXN0ZXIvc3RhdGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fY2x1c3Rlci9zdGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjbHVzdGVyLnN0YXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1ldHJpYzogcGFyYW1zLm1ldHJpYyxcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbm9kZV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19jbHVzdGVyL3N0YXRzL25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19jbHVzdGVyL3N0YXRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2NsdXN0ZXIuc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbHVzdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cluster.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/connector.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/connector.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Connector {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async checkIn(params, options) {\n        const acceptedPath = ['connector_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_check_in`;\n        const meta = {\n            name: 'connector.check_in',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async delete(params, options) {\n        const acceptedPath = ['connector_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;\n        const meta = {\n            name: 'connector.delete',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['connector_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;\n        const meta = {\n            name: 'connector.get',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async lastSync(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['last_access_control_sync_error', 'last_access_control_sync_scheduled_at', 'last_access_control_sync_status', 'last_deleted_document_count', 'last_incremental_sync_scheduled_at', 'last_indexed_document_count', 'last_seen', 'last_sync_error', 'last_sync_scheduled_at', 'last_sync_status', 'last_synced', 'sync_cursor'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_last_sync`;\n        const meta = {\n            name: 'connector.last_sync',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async list(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_connector';\n        const meta = {\n            name: 'connector.list'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async post(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['description', 'index_name', 'is_native', 'language', 'name', 'service_type'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_connector';\n        const meta = {\n            name: 'connector.post'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async put(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['description', 'index_name', 'is_native', 'language', 'name', 'service_type'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.connector_id != null) {\n            method = 'PUT';\n            path = `/_connector/${encodeURIComponent(params.connector_id.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_connector';\n        }\n        const meta = {\n            name: 'connector.put',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async secretDelete(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'connector.secret_delete',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async secretGet(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'connector.secret_get',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async secretPost(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_connector/_secret';\n        const meta = {\n            name: 'connector.secret_post'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async secretPut(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_secret/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'connector.secret_put',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobCancel(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_cancel`;\n        const meta = {\n            name: 'connector.sync_job_cancel',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobCheckIn(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_check_in`;\n        const meta = {\n            name: 'connector.sync_job_check_in',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobClaim(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_claim`;\n        const meta = {\n            name: 'connector.sync_job_claim',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobDelete(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;\n        const meta = {\n            name: 'connector.sync_job_delete',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobError(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_error`;\n        const meta = {\n            name: 'connector.sync_job_error',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobGet(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}`;\n        const meta = {\n            name: 'connector.sync_job_get',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobList(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_connector/_sync_job';\n        const meta = {\n            name: 'connector.sync_job_list'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobPost(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['id', 'job_type', 'trigger_method'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_connector/_sync_job';\n        const meta = {\n            name: 'connector.sync_job_post'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async syncJobUpdateStats(params, options) {\n        const acceptedPath = ['connector_sync_job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/_sync_job/${encodeURIComponent(params.connector_sync_job_id.toString())}/_stats`;\n        const meta = {\n            name: 'connector.sync_job_update_stats',\n            pathParts: {\n                connector_sync_job_id: params.connector_sync_job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateActiveFiltering(params, options) {\n        const acceptedPath = ['connector_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_activate`;\n        const meta = {\n            name: 'connector.update_active_filtering',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateApiKeyId(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['api_key_id', 'api_key_secret_id'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_api_key_id`;\n        const meta = {\n            name: 'connector.update_api_key_id',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateConfiguration(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['configuration', 'values'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_configuration`;\n        const meta = {\n            name: 'connector.update_configuration',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateError(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['error'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_error`;\n        const meta = {\n            name: 'connector.update_error',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateFeatures(params, options) {\n        const acceptedPath = ['connector_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_features`;\n        const meta = {\n            name: 'connector.update_features',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateFiltering(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['filtering', 'rules', 'advanced_snippet'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering`;\n        const meta = {\n            name: 'connector.update_filtering',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateFilteringValidation(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['validation'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_filtering/_validation`;\n        const meta = {\n            name: 'connector.update_filtering_validation',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateIndexName(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['index_name'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_index_name`;\n        const meta = {\n            name: 'connector.update_index_name',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateName(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['name', 'description'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_name`;\n        const meta = {\n            name: 'connector.update_name',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateNative(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['is_native'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_native`;\n        const meta = {\n            name: 'connector.update_native',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updatePipeline(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['pipeline'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_pipeline`;\n        const meta = {\n            name: 'connector.update_pipeline',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateScheduling(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['scheduling'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_scheduling`;\n        const meta = {\n            name: 'connector.update_scheduling',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateServiceType(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['service_type'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_service_type`;\n        const meta = {\n            name: 'connector.update_service_type',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateStatus(params, options) {\n        const acceptedPath = ['connector_id'];\n        const acceptedBody = ['status'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_connector/${encodeURIComponent(params.connector_id.toString())}/_status`;\n        const meta = {\n            name: 'connector.update_status',\n            pathParts: {\n                connector_id: params.connector_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Connector;\n//# sourceMappingURL=connector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jb25uZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtREFBbUQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlDQUF5QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlDQUF5QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0REFBNEQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNERBQTREO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDREQUE0RDtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0REFBNEQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsNERBQTREO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDREQUE0RDtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0REFBNEQ7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jb25uZWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvbm5lY3RvciB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgY2hlY2tJbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fY2hlY2tfaW5gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci5jaGVja19pbicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JfaWQ6IHBhcmFtcy5jb25uZWN0b3JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci5kZWxldGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX2lkOiBwYXJhbXMuY29ubmVjdG9yX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IuZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGxhc3RTeW5jKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2xhc3RfYWNjZXNzX2NvbnRyb2xfc3luY19lcnJvcicsICdsYXN0X2FjY2Vzc19jb250cm9sX3N5bmNfc2NoZWR1bGVkX2F0JywgJ2xhc3RfYWNjZXNzX2NvbnRyb2xfc3luY19zdGF0dXMnLCAnbGFzdF9kZWxldGVkX2RvY3VtZW50X2NvdW50JywgJ2xhc3RfaW5jcmVtZW50YWxfc3luY19zY2hlZHVsZWRfYXQnLCAnbGFzdF9pbmRleGVkX2RvY3VtZW50X2NvdW50JywgJ2xhc3Rfc2VlbicsICdsYXN0X3N5bmNfZXJyb3InLCAnbGFzdF9zeW5jX3NjaGVkdWxlZF9hdCcsICdsYXN0X3N5bmNfc3RhdHVzJywgJ2xhc3Rfc3luY2VkJywgJ3N5bmNfY3Vyc29yJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3JfaWQudG9TdHJpbmcoKSl9L19sYXN0X3N5bmNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci5sYXN0X3N5bmMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX2lkOiBwYXJhbXMuY29ubmVjdG9yX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY29ubmVjdG9yJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IubGlzdCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwb3N0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkZXNjcmlwdGlvbicsICdpbmRleF9uYW1lJywgJ2lzX25hdGl2ZScsICdsYW5ndWFnZScsICduYW1lJywgJ3NlcnZpY2VfdHlwZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY29ubmVjdG9yJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IucG9zdCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzY3JpcHRpb24nLCAnaW5kZXhfbmFtZScsICdpc19uYXRpdmUnLCAnbGFuZ3VhZ2UnLCAnbmFtZScsICdzZXJ2aWNlX3R5cGUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5jb25uZWN0b3JfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fY29ubmVjdG9yLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2Nvbm5lY3Rvcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IucHV0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNlY3JldERlbGV0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yL19zZWNyZXQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnNlY3JldF9kZWxldGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNlY3JldEdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yL19zZWNyZXQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnNlY3JldF9nZXQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNlY3JldFBvc3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2Nvbm5lY3Rvci9fc2VjcmV0JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3Iuc2VjcmV0X3Bvc3QnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2VjcmV0UHV0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvX3NlY3JldC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3Iuc2VjcmV0X3B1dCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3luY0pvYkNhbmNlbChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3Jfc3luY19qb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci9fc3luY19qb2IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9zeW5jX2pvYl9pZC50b1N0cmluZygpKX0vX2NhbmNlbGA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnN5bmNfam9iX2NhbmNlbCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Jfc3luY19qb2JfaWQ6IHBhcmFtcy5jb25uZWN0b3Jfc3luY19qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzeW5jSm9iQ2hlY2tJbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3Jfc3luY19qb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci9fc3luY19qb2IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9zeW5jX2pvYl9pZC50b1N0cmluZygpKX0vX2NoZWNrX2luYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3Iuc3luY19qb2JfY2hlY2tfaW4nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX3N5bmNfam9iX2lkOiBwYXJhbXMuY29ubmVjdG9yX3N5bmNfam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3luY0pvYkNsYWltKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9zeW5jX2pvYl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yL19zeW5jX2pvYi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX3N5bmNfam9iX2lkLnRvU3RyaW5nKCkpfS9fY2xhaW1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci5zeW5jX2pvYl9jbGFpbScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Jfc3luY19qb2JfaWQ6IHBhcmFtcy5jb25uZWN0b3Jfc3luY19qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzeW5jSm9iRGVsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9zeW5jX2pvYl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yL19zeW5jX2pvYi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX3N5bmNfam9iX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnN5bmNfam9iX2RlbGV0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3Jfc3luY19qb2JfaWQ6IHBhcmFtcy5jb25uZWN0b3Jfc3luY19qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzeW5jSm9iRXJyb3IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX3N5bmNfam9iX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvX3N5bmNfam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3Jfc3luY19qb2JfaWQudG9TdHJpbmcoKSl9L19lcnJvcmA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnN5bmNfam9iX2Vycm9yJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9zeW5jX2pvYl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9zeW5jX2pvYl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN5bmNKb2JHZXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX3N5bmNfam9iX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvX3N5bmNfam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3Jfc3luY19qb2JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3Iuc3luY19qb2JfZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9zeW5jX2pvYl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9zeW5jX2pvYl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN5bmNKb2JMaXN0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19jb25uZWN0b3IvX3N5bmNfam9iJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3Iuc3luY19qb2JfbGlzdCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzeW5jSm9iUG9zdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnaWQnLCAnam9iX3R5cGUnLCAndHJpZ2dlcl9tZXRob2QnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fY29ubmVjdG9yL19zeW5jX2pvYic7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnN5bmNfam9iX3Bvc3QnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3luY0pvYlVwZGF0ZVN0YXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9zeW5jX2pvYl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yL19zeW5jX2pvYi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX3N5bmNfam9iX2lkLnRvU3RyaW5nKCkpfS9fc3RhdHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci5zeW5jX2pvYl91cGRhdGVfc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX3N5bmNfam9iX2lkOiBwYXJhbXMuY29ubmVjdG9yX3N5bmNfam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQWN0aXZlRmlsdGVyaW5nKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3JfaWQudG9TdHJpbmcoKSl9L19maWx0ZXJpbmcvX2FjdGl2YXRlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IudXBkYXRlX2FjdGl2ZV9maWx0ZXJpbmcnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX2lkOiBwYXJhbXMuY29ubmVjdG9yX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQXBpS2V5SWQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYXBpX2tleV9pZCcsICdhcGlfa2V5X3NlY3JldF9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fYXBpX2tleV9pZGA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9hcGlfa2V5X2lkJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUNvbmZpZ3VyYXRpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnY29uZmlndXJhdGlvbicsICd2YWx1ZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX0vX2NvbmZpZ3VyYXRpb25gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci51cGRhdGVfY29uZmlndXJhdGlvbicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JfaWQ6IHBhcmFtcy5jb25uZWN0b3JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVFcnJvcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydlcnJvciddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fZXJyb3JgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci51cGRhdGVfZXJyb3InLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX2lkOiBwYXJhbXMuY29ubmVjdG9yX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRmVhdHVyZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX0vX2ZlYXR1cmVzYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IudXBkYXRlX2ZlYXR1cmVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZpbHRlcmluZyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydmaWx0ZXJpbmcnLCAncnVsZXMnLCAnYWR2YW5jZWRfc25pcHBldCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fZmlsdGVyaW5nYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IudXBkYXRlX2ZpbHRlcmluZycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JfaWQ6IHBhcmFtcy5jb25uZWN0b3JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVGaWx0ZXJpbmdWYWxpZGF0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3ZhbGlkYXRpb24nXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX0vX2ZpbHRlcmluZy9fdmFsaWRhdGlvbmA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9maWx0ZXJpbmdfdmFsaWRhdGlvbicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JfaWQ6IHBhcmFtcy5jb25uZWN0b3JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJbmRleE5hbWUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnaW5kZXhfbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9faW5kZXhfbmFtZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9pbmRleF9uYW1lJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZU5hbWUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbmFtZScsICdkZXNjcmlwdGlvbiddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fbmFtZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9uYW1lJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZU5hdGl2ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjb25uZWN0b3JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydpc19uYXRpdmUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX0vX25hdGl2ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9uYXRpdmUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yX2lkOiBwYXJhbXMuY29ubmVjdG9yX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUGlwZWxpbmUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsncGlwZWxpbmUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19jb25uZWN0b3IvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbm5lY3Rvcl9pZC50b1N0cmluZygpKX0vX3BpcGVsaW5lYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IudXBkYXRlX3BpcGVsaW5lJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVNjaGVkdWxpbmcocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc2NoZWR1bGluZyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fc2NoZWR1bGluZ2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnY29ubmVjdG9yLnVwZGF0ZV9zY2hlZHVsaW5nJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVNlcnZpY2VUeXBlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2Nvbm5lY3Rvcl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3NlcnZpY2VfdHlwZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2Nvbm5lY3Rvci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY29ubmVjdG9yX2lkLnRvU3RyaW5nKCkpfS9fc2VydmljZV90eXBlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdjb25uZWN0b3IudXBkYXRlX3NlcnZpY2VfdHlwZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3JfaWQ6IHBhcmFtcy5jb25uZWN0b3JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29ubmVjdG9yX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc3RhdHVzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fY29ubmVjdG9yLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jb25uZWN0b3JfaWQudG9TdHJpbmcoKSl9L19zdGF0dXNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2Nvbm5lY3Rvci51cGRhdGVfc3RhdHVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rvcl9pZDogcGFyYW1zLmNvbm5lY3Rvcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/connector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/count.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/count.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function CountApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['query'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_count`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_count';\n    }\n    const meta = {\n        name: 'count',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = CountApi;\n//# sourceMappingURL=count.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2NvdW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBDb3VudEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydxdWVyeSddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY291bnRgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSAnL19jb3VudCc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdjb3VudCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb3VudEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvdW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/count.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/create.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/create.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function CreateApi(params, options) {\n    var _a;\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['document'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'PUT';\n    const path = `/${encodeURIComponent(params.index.toString())}/_create/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'create',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = CreateApi;\n//# sourceMappingURL=create.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9jcmVhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDLFdBQVcseUNBQXlDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2NyZWF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gQ3JlYXRlQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJywgJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkb2N1bWVudCddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGxldCBib2R5ID0gKF9hID0gcGFyYW1zLmJvZHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY3JlYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdjcmVhdGUnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENyZWF0ZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/create.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass DanglingIndices {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteDanglingIndex(params, options) {\n        const acceptedPath = ['index_uuid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;\n        const meta = {\n            name: 'dangling_indices.delete_dangling_index',\n            pathParts: {\n                index_uuid: params.index_uuid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async importDanglingIndex(params, options) {\n        const acceptedPath = ['index_uuid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;\n        const meta = {\n            name: 'dangling_indices.import_dangling_index',\n            pathParts: {\n                index_uuid: params.index_uuid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async listDanglingIndices(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_dangling';\n        const meta = {\n            name: 'dangling_indices.list_dangling_indices'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = DanglingIndices;\n//# sourceMappingURL=dangling_indices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kYW5nbGluZ19pbmRpY2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQWlEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlEQUFpRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kYW5nbGluZ19pbmRpY2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBEYW5nbGluZ0luZGljZXMge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURhbmdsaW5nSW5kZXgocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXhfdXVpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fZGFuZ2xpbmcvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4X3V1aWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdkYW5nbGluZ19pbmRpY2VzLmRlbGV0ZV9kYW5nbGluZ19pbmRleCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleF91dWlkOiBwYXJhbXMuaW5kZXhfdXVpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGltcG9ydERhbmdsaW5nSW5kZXgocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXhfdXVpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2RhbmdsaW5nLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleF91dWlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZGFuZ2xpbmdfaW5kaWNlcy5pbXBvcnRfZGFuZ2xpbmdfaW5kZXgnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXhfdXVpZDogcGFyYW1zLmluZGV4X3V1aWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0RGFuZ2xpbmdJbmRpY2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19kYW5nbGluZyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZGFuZ2xpbmdfaW5kaWNlcy5saXN0X2RhbmdsaW5nX2luZGljZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEYW5nbGluZ0luZGljZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYW5nbGluZ19pbmRpY2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/delete.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function DeleteApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'delete',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = DeleteApi;\n//# sourceMappingURL=delete.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QyxRQUFRLHlDQUF5QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIERlbGV0ZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJywgJ2luZGV4J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZG9jLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdkZWxldGUnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlbGV0ZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGV0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function DeleteByQueryApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['max_docs', 'query', 'slice'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_delete_by_query`;\n    const meta = {\n        name: 'delete_by_query',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = DeleteByQueryApi;\n//# sourceMappingURL=delete_by_query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGVfYnlfcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGVfYnlfcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIERlbGV0ZUJ5UXVlcnlBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbWF4X2RvY3MnLCAncXVlcnknLCAnc2xpY2UnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZGVsZXRlX2J5X3F1ZXJ5YDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZGVsZXRlX2J5X3F1ZXJ5JyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlbGV0ZUJ5UXVlcnlBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxldGVfYnlfcXVlcnkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function DeleteByQueryRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_delete_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    const meta = {\n        name: 'delete_by_query_rethrottle',\n        pathParts: {\n            task_id: params.task_id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = DeleteByQueryRethrottleApi;\n//# sourceMappingURL=delete_by_query_rethrottle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGVfYnlfcXVlcnlfcmV0aHJvdHRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGVfYnlfcXVlcnlfcmV0aHJvdHRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gRGVsZXRlQnlRdWVyeVJldGhyb3R0bGVBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0YXNrX2lkJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHBhdGggPSBgL19kZWxldGVfYnlfcXVlcnkvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhc2tfaWQudG9TdHJpbmcoKSl9L19yZXRocm90dGxlYDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZGVsZXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGUnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIHRhc2tfaWQ6IHBhcmFtcy50YXNrX2lkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERlbGV0ZUJ5UXVlcnlSZXRocm90dGxlQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsZXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function DeleteScriptApi(params, options) {\n    const acceptedPath = ['id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'delete_script',\n        pathParts: {\n            id: params.id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = DeleteScriptApi;\n//# sourceMappingURL=delete_script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9kZWxldGVfc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2RlbGV0ZV9zY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIERlbGV0ZVNjcmlwdEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgY29uc3QgcGF0aCA9IGAvX3NjcmlwdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2RlbGV0ZV9zY3JpcHQnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGVsZXRlU2NyaXB0QXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsZXRlX3NjcmlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/enrich.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/enrich.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Enrich {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deletePolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'enrich.delete_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async executePolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}/_execute`;\n        const meta = {\n            name: 'enrich.execute_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_enrich/policy';\n        }\n        const meta = {\n            name: 'enrich.get_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['geo_match', 'match', 'range'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'enrich.put_policy',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_enrich/_stats';\n        const meta = {\n            name: 'enrich.stats'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Enrich;\n//# sourceMappingURL=enrich.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lbnJpY2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQTJDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJDQUEyQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lbnJpY2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEVucmljaCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUG9saWN5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2VucmljaC9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlbnJpY2guZGVsZXRlX3BvbGljeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVQb2xpY3kocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fZW5yaWNoL3BvbGljeS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vX2V4ZWN1dGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2VucmljaC5leGVjdXRlX3BvbGljeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFBvbGljeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2VucmljaC9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2VucmljaC9wb2xpY3knO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZW5yaWNoLmdldF9wb2xpY3knLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRQb2xpY3kocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2dlb19tYXRjaCcsICdtYXRjaCcsICdyYW5nZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2VucmljaC9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlbnJpY2gucHV0X3BvbGljeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19lbnJpY2gvX3N0YXRzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlbnJpY2guc3RhdHMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBFbnJpY2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnJpY2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/enrich.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/eql.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/eql.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Eql {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'eql.delete',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'eql.get',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_eql/search/status/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'eql.get_status',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async search(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['query', 'case_sensitive', 'event_category_field', 'tiebreaker_field', 'timestamp_field', 'fetch_size', 'filter', 'keep_alive', 'keep_on_completion', 'wait_for_completion_timeout', 'size', 'fields', 'result_position', 'runtime_mappings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_eql/search`;\n        const meta = {\n            name: 'eql.search',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Eql;\n//# sourceMappingURL=eql.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lcWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5Q0FBeUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlDQUF5QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lcWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEVxbCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19lcWwvc2VhcmNoLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2VxbC5kZWxldGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fZXFsL3NlYXJjaC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlcWwuZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2VxbC9zZWFyY2gvc3RhdHVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2VxbC5nZXRfc3RhdHVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzZWFyY2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydxdWVyeScsICdjYXNlX3NlbnNpdGl2ZScsICdldmVudF9jYXRlZ29yeV9maWVsZCcsICd0aWVicmVha2VyX2ZpZWxkJywgJ3RpbWVzdGFtcF9maWVsZCcsICdmZXRjaF9zaXplJywgJ2ZpbHRlcicsICdrZWVwX2FsaXZlJywgJ2tlZXBfb25fY29tcGxldGlvbicsICd3YWl0X2Zvcl9jb21wbGV0aW9uX3RpbWVvdXQnLCAnc2l6ZScsICdmaWVsZHMnLCAncmVzdWx0X3Bvc2l0aW9uJywgJ3J1bnRpbWVfbWFwcGluZ3MnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2VxbC9zZWFyY2hgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2VxbC5zZWFyY2gnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXFsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/eql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/esql.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/esql.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Esql {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async asyncQuery(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_query/async';\n        const meta = {\n            name: 'esql.async_query'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async asyncQueryGet(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_query/async/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'esql.async_query_get',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async query(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['columnar', 'filter', 'locale', 'params', 'profile', 'query', 'tables'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_query';\n        const meta = {\n            name: 'esql.query'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Esql;\n//# sourceMappingURL=esql.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lc3FsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlDQUF5QztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9lc3FsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBFc3FsIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBhc3luY1F1ZXJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19xdWVyeS9hc3luYyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZXNxbC5hc3luY19xdWVyeSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhc3luY1F1ZXJ5R2V0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19xdWVyeS9hc3luYy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlc3FsLmFzeW5jX3F1ZXJ5X2dldCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcXVlcnkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2NvbHVtbmFyJywgJ2ZpbHRlcicsICdsb2NhbGUnLCAncGFyYW1zJywgJ3Byb2ZpbGUnLCAncXVlcnknLCAndGFibGVzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3F1ZXJ5JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdlc3FsLnF1ZXJ5J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXNxbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzcWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/esql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/exists.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ExistsApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'exists',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ExistsApi;\n//# sourceMappingURL=exists.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9leGlzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QyxRQUFRLHlDQUF5QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9leGlzdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEV4aXN0c0FwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJywgJ2luZGV4J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0hFQUQnO1xuICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2RvYy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZXhpc3RzJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBFeGlzdHNBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGlzdHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ExistsSourceApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'exists_source',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ExistsSourceApi;\n//# sourceMappingURL=exists_source.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9leGlzdHNfc291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBNEMsV0FBVyx5Q0FBeUM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvZXhpc3RzX3NvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gRXhpc3RzU291cmNlQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnLCAnaW5kZXgnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnSEVBRCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fc291cmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdleGlzdHNfc291cmNlJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpZDogcGFyYW1zLmlkLFxuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBFeGlzdHNTb3VyY2VBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGlzdHNfc291cmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/explain.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/explain.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ExplainApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['query'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_explain/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'explain',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ExplainApi;\n//# sourceMappingURL=explain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9leHBsYWluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QyxZQUFZLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9leHBsYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBFeHBsYWluQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnLCAnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3F1ZXJ5J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZXhwbGFpbi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZXhwbGFpbicsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZCxcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gRXhwbGFpbkFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGxhaW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/explain.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/features.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/features.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Features {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async getFeatures(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_features';\n        const meta = {\n            name: 'features.get_features'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resetFeatures(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_features/_reset';\n        const meta = {\n            name: 'features.reset_features'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Features;\n//# sourceMappingURL=features.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9mZWF0dXJlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2ZlYXR1cmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBGZWF0dXJlcyB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVhdHVyZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2ZlYXR1cmVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdmZWF0dXJlcy5nZXRfZmVhdHVyZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzZXRGZWF0dXJlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2ZlYXR1cmVzL19yZXNldCc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZmVhdHVyZXMucmVzZXRfZmVhdHVyZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBGZWF0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZlYXR1cmVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/features.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function FieldCapsApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['fields', 'index_filter', 'runtime_mappings'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_field_caps`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_field_caps';\n    }\n    const meta = {\n        name: 'field_caps',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = FieldCapsApi;\n//# sourceMappingURL=field_caps.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9maWVsZF9jYXBzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvZmllbGRfY2Fwcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gRmllbGRDYXBzQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2ZpZWxkcycsICdpbmRleF9maWx0ZXInLCAncnVudGltZV9tYXBwaW5ncyddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZmllbGRfY2Fwc2A7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9ICcvX2ZpZWxkX2NhcHMnO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZmllbGRfY2FwcycsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBGaWVsZENhcHNBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWVsZF9jYXBzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/fleet.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/fleet.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Fleet {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteSecret(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'fleet.delete_secret',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSecret(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_fleet/secret/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'fleet.get_secret',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async globalCheckpoints(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/global_checkpoints`;\n        const meta = {\n            name: 'fleet.global_checkpoints',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async msearch(params, options) {\n        var _a;\n        const acceptedPath = ['index'];\n        const acceptedBody = ['searches'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_msearch`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_fleet/_fleet_msearch';\n        }\n        const meta = {\n            name: 'fleet.msearch',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n    }\n    async postSecret(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_fleet/secret';\n        const meta = {\n            name: 'fleet.post_secret'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async search(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'ext', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_search`;\n        const meta = {\n            name: 'fleet.search',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Fleet;\n//# sourceMappingURL=fleet.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9mbGVldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlDQUF5QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5Q0FBeUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaURBQWlEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvZmxlZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEZsZWV0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVTZWNyZXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2ZsZWV0L3NlY3JldC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdmbGVldC5kZWxldGVfc2VjcmV0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZWNyZXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2ZsZWV0L3NlY3JldC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdmbGVldC5nZXRfc2VjcmV0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnbG9iYWxDaGVja3BvaW50cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19mbGVldC9nbG9iYWxfY2hlY2twb2ludHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2ZsZWV0Lmdsb2JhbF9jaGVja3BvaW50cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbXNlYXJjaChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc2VhcmNoZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZmxlZXQvX2ZsZWV0X21zZWFyY2hgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fZmxlZXQvX2ZsZWV0X21zZWFyY2gnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZmxlZXQubXNlYXJjaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYnVsa0JvZHk6IGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RTZWNyZXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2ZsZWV0L3NlY3JldCc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZmxlZXQucG9zdF9zZWNyZXQnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2VhcmNoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWdncmVnYXRpb25zJywgJ2FnZ3MnLCAnY29sbGFwc2UnLCAnZXhwbGFpbicsICdleHQnLCAnZnJvbScsICdoaWdobGlnaHQnLCAndHJhY2tfdG90YWxfaGl0cycsICdpbmRpY2VzX2Jvb3N0JywgJ2RvY3ZhbHVlX2ZpZWxkcycsICdtaW5fc2NvcmUnLCAncG9zdF9maWx0ZXInLCAncHJvZmlsZScsICdxdWVyeScsICdyZXNjb3JlJywgJ3NjcmlwdF9maWVsZHMnLCAnc2VhcmNoX2FmdGVyJywgJ3NpemUnLCAnc2xpY2UnLCAnc29ydCcsICdfc291cmNlJywgJ2ZpZWxkcycsICdzdWdnZXN0JywgJ3Rlcm1pbmF0ZV9hZnRlcicsICd0aW1lb3V0JywgJ3RyYWNrX3Njb3JlcycsICd2ZXJzaW9uJywgJ3NlcV9ub19wcmltYXJ5X3Rlcm0nLCAnc3RvcmVkX2ZpZWxkcycsICdwaXQnLCAncnVudGltZV9tYXBwaW5ncycsICdzdGF0cyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZmxlZXQvX2ZsZWV0X3NlYXJjaGA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnZmxlZXQuc2VhcmNoJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEZsZWV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxlZXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/fleet.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/get.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function GetApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'get',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = GetApi;\n//# sourceMappingURL=get.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QyxRQUFRLHlDQUF5QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEdldEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJywgJ2luZGV4J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZG9jLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdnZXQnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdldEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/get_script.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function GetScriptApi(params, options) {\n    const acceptedPath = ['id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'get_script',\n        pathParts: {\n            id: params.id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = GetScriptApi;\n//# sourceMappingURL=get_script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXRfc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2dldF9zY3JpcHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEdldFNjcmlwdEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvX3NjcmlwdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2dldF9zY3JpcHQnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gR2V0U2NyaXB0QXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0X3NjcmlwdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function GetScriptContextApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/_script_context';\n    const meta = {\n        name: 'get_script_context'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = GetScriptContextApi;\n//# sourceMappingURL=get_script_context.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXRfc2NyaXB0X2NvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXRfc2NyaXB0X2NvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEdldFNjcmlwdENvbnRleHRBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9ICcvX3NjcmlwdF9jb250ZXh0JztcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnZ2V0X3NjcmlwdF9jb250ZXh0J1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gR2V0U2NyaXB0Q29udGV4dEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldF9zY3JpcHRfY29udGV4dC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function GetScriptLanguagesApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/_script_language';\n    const meta = {\n        name: 'get_script_languages'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = GetScriptLanguagesApi;\n//# sourceMappingURL=get_script_languages.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXRfc2NyaXB0X2xhbmd1YWdlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2dldF9zY3JpcHRfbGFuZ3VhZ2VzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBHZXRTY3JpcHRMYW5ndWFnZXNBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9ICcvX3NjcmlwdF9sYW5ndWFnZSc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2dldF9zY3JpcHRfbGFuZ3VhZ2VzJ1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gR2V0U2NyaXB0TGFuZ3VhZ2VzQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0X3NjcmlwdF9sYW5ndWFnZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_source.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/get_source.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function GetSourceApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'get_source',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = GetSourceApi;\n//# sourceMappingURL=get_source.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9nZXRfc291cmNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBNEMsV0FBVyx5Q0FBeUM7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvZ2V0X3NvdXJjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gR2V0U291cmNlQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnLCAnaW5kZXgnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zb3VyY2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ2dldF9zb3VyY2UnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdldFNvdXJjZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldF9zb3VyY2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_source.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/graph.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/graph.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Graph {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async explore(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['connections', 'controls', 'query', 'vertices'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_graph/explore`;\n        const meta = {\n            name: 'graph.explore',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Graph;\n//# sourceMappingURL=graph.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9ncmFwaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2dyYXBoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBHcmFwaCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZXhwbG9yZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2Nvbm5lY3Rpb25zJywgJ2NvbnRyb2xzJywgJ3F1ZXJ5JywgJ3ZlcnRpY2VzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19ncmFwaC9leHBsb3JlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdncmFwaC5leHBsb3JlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEdyYXBoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/graph.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/health_report.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/health_report.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function HealthReportApi(params, options) {\n    const acceptedPath = ['feature'];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.feature != null) {\n        method = 'GET';\n        path = `/_health_report/${encodeURIComponent(params.feature.toString())}`;\n    }\n    else {\n        method = 'GET';\n        path = '/_health_report';\n    }\n    const meta = {\n        name: 'health_report',\n        pathParts: {\n            feature: params.feature\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = HealthReportApi;\n//# sourceMappingURL=health_report.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9oZWFsdGhfcmVwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDhDQUE4QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2hlYWx0aF9yZXBvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIEhlYWx0aFJlcG9ydEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2ZlYXR1cmUnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBpZiAocGFyYW1zLmZlYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvX2hlYWx0aF9yZXBvcnQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmZlYXR1cmUudG9TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBwYXRoID0gJy9faGVhbHRoX3JlcG9ydCc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdoZWFsdGhfcmVwb3J0JyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBmZWF0dXJlOiBwYXJhbXMuZmVhdHVyZVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBIZWFsdGhSZXBvcnRBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFsdGhfcmVwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/health_report.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ilm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ilm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ilm {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'ilm.delete_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async explainLifecycle(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/explain`;\n        const meta = {\n            name: 'ilm.explain_lifecycle',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ilm/policy';\n        }\n        const meta = {\n            name: 'ilm.get_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ilm/status';\n        const meta = {\n            name: 'ilm.get_status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async migrateToDataTiers(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['legacy_template_to_delete', 'node_attribute'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/migrate_to_data_tiers';\n        const meta = {\n            name: 'ilm.migrate_to_data_tiers'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async moveToStep(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['current_step', 'next_step'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ilm/move/${encodeURIComponent(params.index.toString())}`;\n        const meta = {\n            name: 'ilm.move_to_step',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['policy'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'ilm.put_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async removePolicy(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/remove`;\n        const meta = {\n            name: 'ilm.remove_policy',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async retry(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/retry`;\n        const meta = {\n            name: 'ilm.retry',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/start';\n        const meta = {\n            name: 'ilm.start'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/stop';\n        const meta = {\n            name: 'ilm.stop'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Ilm;\n//# sourceMappingURL=ilm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbG0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywyQ0FBMkM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkNBQTJDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNENBQTRDO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMkNBQTJDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvaWxtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBJbG0ge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUxpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19pbG0vcG9saWN5LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaWxtLmRlbGV0ZV9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBleHBsYWluTGlmZWN5Y2xlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2lsbS9leHBsYWluYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbG0uZXhwbGFpbl9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldExpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2lsbS9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2lsbS9wb2xpY3knO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaWxtLmdldF9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2lsbS9zdGF0dXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2lsbS5nZXRfc3RhdHVzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1pZ3JhdGVUb0RhdGFUaWVycyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbGVnYWN5X3RlbXBsYXRlX3RvX2RlbGV0ZScsICdub2RlX2F0dHJpYnV0ZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9faWxtL21pZ3JhdGVfdG9fZGF0YV90aWVycyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaWxtLm1pZ3JhdGVfdG9fZGF0YV90aWVycydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBtb3ZlVG9TdGVwKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnY3VycmVudF9zdGVwJywgJ25leHRfc3RlcCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19pbG0vbW92ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbG0ubW92ZV90b19zdGVwJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRMaWZlY3ljbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3BvbGljeSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2lsbS9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbG0ucHV0X2xpZmVjeWNsZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVBvbGljeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9faWxtL3JlbW92ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaWxtLnJlbW92ZV9wb2xpY3knLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJldHJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19pbG0vcmV0cnlgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2lsbS5yZXRyeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19pbG0vc3RhcnQnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2lsbS5zdGFydCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9faWxtL3N0b3AnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2lsbS5zdG9wJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSWxtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWxtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ilm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function IndexApi(params, options) {\n    var _a;\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['document'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null && params.id != null) {\n        method = 'PUT';\n        path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = 'POST';\n        path = `/${encodeURIComponent(params.index.toString())}/_doc`;\n    }\n    const meta = {\n        name: 'index',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = IndexApi;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEMsUUFBUSx5Q0FBeUM7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBJbmRleEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCcsICdpbmRleCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZG9jdW1lbnQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCAmJiBwYXJhbXMuaWQgIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZG9jLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19kb2NgO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnaW5kZXgnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEluZGV4QXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/indices.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/indices.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Indices {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async addBlock(params, options) {\n        const acceptedPath = ['index', 'block'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_block/${encodeURIComponent(params.block.toString())}`;\n        const meta = {\n            name: 'indices.add_block',\n            pathParts: {\n                index: params.index,\n                block: params.block\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async analyze(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['analyzer', 'attributes', 'char_filter', 'explain', 'field', 'filter', 'normalizer', 'text', 'tokenizer'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_analyze`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_analyze';\n        }\n        const meta = {\n            name: 'indices.analyze',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCache(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_cache/clear`;\n        }\n        else {\n            method = 'POST';\n            path = '/_cache/clear';\n        }\n        const meta = {\n            name: 'indices.clear_cache',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clone(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_clone/${encodeURIComponent(params.target.toString())}`;\n        const meta = {\n            name: 'indices.clone',\n            pathParts: {\n                index: params.index,\n                target: params.target\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async close(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_close`;\n        const meta = {\n            name: 'indices.close',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async create(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aliases', 'mappings', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        const meta = {\n            name: 'indices.create',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async createDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.create_data_stream',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async dataStreamsStats(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_data_stream/_stats';\n        }\n        const meta = {\n            name: 'indices.data_streams_stats',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async delete(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        const meta = {\n            name: 'indices.delete',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteAlias(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'DELETE';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        const meta = {\n            name: 'indices.delete_alias',\n            pathParts: {\n                index: params.index,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteDataLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;\n        const meta = {\n            name: 'indices.delete_data_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.delete_data_stream',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.delete_index_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.delete_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async diskUsage(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_disk_usage`;\n        const meta = {\n            name: 'indices.disk_usage',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async downsample(params, options) {\n        var _a;\n        const acceptedPath = ['index', 'target_index'];\n        const acceptedBody = ['config'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_downsample/${encodeURIComponent(params.target_index.toString())}`;\n        const meta = {\n            name: 'indices.downsample',\n            pathParts: {\n                index: params.index,\n                target_index: params.target_index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async exists(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        const meta = {\n            name: 'indices.exists',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async existsAlias(params, options) {\n        const acceptedPath = ['name', 'index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'HEAD';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'HEAD';\n            path = `/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        const meta = {\n            name: 'indices.exists_alias',\n            pathParts: {\n                name: params.name,\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async existsIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.exists_index_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async existsTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.exists_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async explainDataLifecycle(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_lifecycle/explain`;\n        const meta = {\n            name: 'indices.explain_data_lifecycle',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async fieldUsageStats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_field_usage_stats`;\n        const meta = {\n            name: 'indices.field_usage_stats',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async flush(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_flush`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_flush';\n        }\n        const meta = {\n            name: 'indices.flush',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async forcemerge(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_forcemerge`;\n        }\n        else {\n            method = 'POST';\n            path = '/_forcemerge';\n        }\n        const meta = {\n            name: 'indices.forcemerge',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        const meta = {\n            name: 'indices.get',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAlias(params, options) {\n        const acceptedPath = ['name', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.name != null) {\n            method = 'GET';\n            path = `/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias`;\n        }\n        else {\n            method = 'GET';\n            path = '/_alias';\n        }\n        const meta = {\n            name: 'indices.get_alias',\n            pathParts: {\n                name: params.name,\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDataLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;\n        const meta = {\n            name: 'indices.get_data_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_data_stream';\n        }\n        const meta = {\n            name: 'indices.get_data_stream',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getFieldMapping(params, options) {\n        const acceptedPath = ['fields', 'index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.fields != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_mapping/field/${encodeURIComponent(params.fields.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = `/_mapping/field/${encodeURIComponent(params.fields.toString())}`;\n        }\n        const meta = {\n            name: 'indices.get_field_mapping',\n            pathParts: {\n                fields: params.fields,\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_index_template';\n        }\n        const meta = {\n            name: 'indices.get_index_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getMapping(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_mapping`;\n        }\n        else {\n            method = 'GET';\n            path = '/_mapping';\n        }\n        const meta = {\n            name: 'indices.get_mapping',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings`;\n        }\n        else if (params.name != null) {\n            method = 'GET';\n            path = `/_settings/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_settings';\n        }\n        const meta = {\n            name: 'indices.get_settings',\n            pathParts: {\n                index: params.index,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_template';\n        }\n        const meta = {\n            name: 'indices.get_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async migrateToDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_data_stream/_migrate/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.migrate_to_data_stream',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async modifyDataStream(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['actions'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_data_stream/_modify';\n        const meta = {\n            name: 'indices.modify_data_stream'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async open(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_open`;\n        const meta = {\n            name: 'indices.open',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async promoteDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_data_stream/_promote/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.promote_data_stream',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putAlias(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const acceptedBody = ['filter', 'index_routing', 'is_write_index', 'routing', 'search_routing'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        const meta = {\n            name: 'indices.put_alias',\n            pathParts: {\n                index: params.index,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putDataLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['data_retention', 'downsampling'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_lifecycle`;\n        const meta = {\n            name: 'indices.put_data_lifecycle',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['index_patterns', 'composed_of', 'template', 'data_stream', 'priority', 'version', '_meta', 'allow_auto_create', 'ignore_missing_component_templates', 'deprecated'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.put_index_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putMapping(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['date_detection', 'dynamic', 'dynamic_date_formats', 'dynamic_templates', '_field_names', '_meta', 'numeric_detection', 'properties', '_routing', '_source', 'runtime'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_mapping`;\n        const meta = {\n            name: 'indices.put_mapping',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putSettings(params, options) {\n        var _a;\n        const acceptedPath = ['index'];\n        const acceptedBody = ['settings'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_settings';\n        }\n        const meta = {\n            name: 'indices.put_settings',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['aliases', 'index_patterns', 'mappings', 'order', 'settings', 'version'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.put_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async recovery(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_recovery`;\n        }\n        else {\n            method = 'GET';\n            path = '/_recovery';\n        }\n        const meta = {\n            name: 'indices.recovery',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async refresh(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_refresh`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_refresh';\n        }\n        const meta = {\n            name: 'indices.refresh',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async reloadSearchAnalyzers(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_reload_search_analyzers`;\n        const meta = {\n            name: 'indices.reload_search_analyzers',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resolveCluster(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_resolve/cluster/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.resolve_cluster',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resolveIndex(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_resolve/index/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.resolve_index',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async rollover(params, options) {\n        const acceptedPath = ['alias', 'new_index'];\n        const acceptedBody = ['aliases', 'conditions', 'mappings', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.alias != null && params.new_index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.alias.toString())}/_rollover/${encodeURIComponent(params.new_index.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.alias.toString())}/_rollover`;\n        }\n        const meta = {\n            name: 'indices.rollover',\n            pathParts: {\n                alias: params.alias,\n                new_index: params.new_index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async segments(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_segments`;\n        }\n        else {\n            method = 'GET';\n            path = '/_segments';\n        }\n        const meta = {\n            name: 'indices.segments',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async shardStores(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_shard_stores`;\n        }\n        else {\n            method = 'GET';\n            path = '/_shard_stores';\n        }\n        const meta = {\n            name: 'indices.shard_stores',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async shrink(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_shrink/${encodeURIComponent(params.target.toString())}`;\n        const meta = {\n            name: 'indices.shrink',\n            pathParts: {\n                index: params.index,\n                target: params.target\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async simulateIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_index_template/_simulate_index/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'indices.simulate_index_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async simulateTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['allow_auto_create', 'index_patterns', 'composed_of', 'template', 'data_stream', 'priority', 'version', '_meta', 'ignore_missing_component_templates', 'deprecated'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'POST';\n            path = `/_index_template/_simulate/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = '/_index_template/_simulate';\n        }\n        const meta = {\n            name: 'indices.simulate_template',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async split(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_split/${encodeURIComponent(params.target.toString())}`;\n        const meta = {\n            name: 'indices.split',\n            pathParts: {\n                index: params.index,\n                target: params.target\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['metric', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.metric != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_stats';\n        }\n        const meta = {\n            name: 'indices.stats',\n            pathParts: {\n                metric: params.metric,\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async unfreeze(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_unfreeze`;\n        const meta = {\n            name: 'indices.unfreeze',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateAliases(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['actions'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_aliases';\n        const meta = {\n            name: 'indices.update_aliases'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async validateQuery(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['query'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_validate/query`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_validate/query';\n        }\n        const meta = {\n            name: 'indices.validate_query',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Indices;\n//# sourceMappingURL=indices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmRpY2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDLFVBQVUsNENBQTRDO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDLFVBQVUsNkNBQTZDO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJDQUEyQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QyxVQUFVLDJDQUEyQztBQUN4SDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDLFlBQVksMkNBQTJDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQTJDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDJDQUEyQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBMkM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDLGVBQWUsbURBQW1EO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QyxVQUFVLDJDQUEyQztBQUN4SDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkNBQTJDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywyQ0FBMkM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMkNBQTJDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEMsVUFBVSwyQ0FBMkM7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUEyQztBQUN6RTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJDQUEyQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDJDQUEyQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDLGtCQUFrQiw2Q0FBNkM7QUFDbEk7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUE2QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QywyQ0FBMkM7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QyxhQUFhLDJDQUEyQztBQUMzSDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDJDQUEyQztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkNBQTJDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDLFVBQVUsMkNBQTJDO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEMsWUFBWSwyQ0FBMkM7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkNBQTJDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsMkNBQTJDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJDQUEyQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywyQ0FBMkM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDLGFBQWEsZ0RBQWdEO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEMsV0FBVyw2Q0FBNkM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDJDQUEyQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEMsVUFBVSw2Q0FBNkM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QyxVQUFVLDZDQUE2QztBQUMxSDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsNENBQTRDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvaW5kaWNlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgSW5kaWNlcyB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgYWRkQmxvY2socGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnLCAnYmxvY2snXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYmxvY2svJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmJsb2NrLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5hZGRfYmxvY2snLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleCxcbiAgICAgICAgICAgICAgICBibG9jazogcGFyYW1zLmJsb2NrXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgYW5hbHl6ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FuYWx5emVyJywgJ2F0dHJpYnV0ZXMnLCAnY2hhcl9maWx0ZXInLCAnZXhwbGFpbicsICdmaWVsZCcsICdmaWx0ZXInLCAnbm9ybWFsaXplcicsICd0ZXh0JywgJ3Rva2VuaXplciddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYW5hbHl6ZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19hbmFseXplJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuYW5hbHl6ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXJDYWNoZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fY2FjaGUvY2xlYXJgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2NhY2hlL2NsZWFyJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuY2xlYXJfY2FjaGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNsb25lKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4JywgJ3RhcmdldCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FsaWFzZXMnLCAnc2V0dGluZ3MnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2Nsb25lLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXJnZXQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmNsb25lJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBwYXJhbXMudGFyZ2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2xvc2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2Nsb3NlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmNsb3NlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbGlhc2VzJywgJ21hcHBpbmdzJywgJ3NldHRpbmdzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmNyZWF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGF0YVN0cmVhbShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19kYXRhX3N0cmVhbS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuY3JlYXRlX2RhdGFfc3RyZWFtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGF0YVN0cmVhbXNTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2RhdGFfc3RyZWFtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfS9fc3RhdHNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fZGF0YV9zdHJlYW0vX3N0YXRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZGF0YV9zdHJlYW1zX3N0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZGVsZXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVBbGlhcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCcsICduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwgJiYgcGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19hbGlhcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19hbGlhc2VzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmRlbGV0ZV9hbGlhcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4LFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YUxpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19kYXRhX3N0cmVhbS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vX2xpZmVjeWNsZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5kZWxldGVfZGF0YV9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVEYXRhU3RyZWFtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2RhdGFfc3RyZWFtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5kZWxldGVfZGF0YV9zdHJlYW0nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVJbmRleFRlbXBsYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2luZGV4X3RlbXBsYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5kZWxldGVfaW5kZXhfdGVtcGxhdGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVUZW1wbGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL190ZW1wbGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZGVsZXRlX3RlbXBsYXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGlza1VzYWdlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19kaXNrX3VzYWdlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmRpc2tfdXNhZ2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRvd25zYW1wbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCcsICd0YXJnZXRfaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjb25maWcnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19kb3duc2FtcGxlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXJnZXRfaW5kZXgudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmRvd25zYW1wbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleCxcbiAgICAgICAgICAgICAgICB0YXJnZXRfaW5kZXg6IHBhcmFtcy50YXJnZXRfaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBleGlzdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnSEVBRCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZXhpc3RzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBleGlzdHNBbGlhcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJywgJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwgJiYgcGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0hFQUQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYWxpYXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdIRUFEJztcbiAgICAgICAgICAgIHBhdGggPSBgL19hbGlhcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5leGlzdHNfYWxpYXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGV4aXN0c0luZGV4VGVtcGxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdIRUFEJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2luZGV4X3RlbXBsYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5leGlzdHNfaW5kZXhfdGVtcGxhdGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBleGlzdHNUZW1wbGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0hFQUQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fdGVtcGxhdGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmV4aXN0c190ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGV4cGxhaW5EYXRhTGlmZWN5Y2xlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2xpZmVjeWNsZS9leHBsYWluYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmV4cGxhaW5fZGF0YV9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGZpZWxkVXNhZ2VTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19maWVsZF91c2FnZV9zdGF0c2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5maWVsZF91c2FnZV9zdGF0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZmx1c2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZmx1c2hgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fZmx1c2gnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5mbHVzaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZm9yY2VtZXJnZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fZm9yY2VtZXJnZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fZm9yY2VtZXJnZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmZvcmNlbWVyZ2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmdldCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxpYXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZScsICdpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCAmJiBwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX2FsaWFzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fYWxpYXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19hbGlhc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19hbGlhcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmdldF9hbGlhcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YUxpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19kYXRhX3N0cmVhbS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vX2xpZmVjeWNsZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5nZXRfZGF0YV9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXREYXRhU3RyZWFtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fZGF0YV9zdHJlYW0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2RhdGFfc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZ2V0X2RhdGFfc3RyZWFtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmllbGRNYXBwaW5nKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2ZpZWxkcycsICdpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsICYmIHBhcmFtcy5maWVsZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19tYXBwaW5nL2ZpZWxkLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5maWVsZHMudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21hcHBpbmcvZmllbGQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmZpZWxkcy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5nZXRfZmllbGRfbWFwcGluZycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBmaWVsZHM6IHBhcmFtcy5maWVsZHMsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldEluZGV4VGVtcGxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmRleF90ZW1wbGF0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9faW5kZXhfdGVtcGxhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5nZXRfaW5kZXhfdGVtcGxhdGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRNYXBwaW5nKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX21hcHBpbmdgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fbWFwcGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmdldF9tYXBwaW5nJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCcsICduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsICYmIHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fc2V0dGluZ3MvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zZXR0aW5nc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fc2V0dGluZ3MvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NldHRpbmdzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuZ2V0X3NldHRpbmdzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUZW1wbGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX3RlbXBsYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL190ZW1wbGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLmdldF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1pZ3JhdGVUb0RhdGFTdHJlYW0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2RhdGFfc3RyZWFtL19taWdyYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5taWdyYXRlX3RvX2RhdGFfc3RyZWFtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbW9kaWZ5RGF0YVN0cmVhbShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWN0aW9ucyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19kYXRhX3N0cmVhbS9fbW9kaWZ5JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLm1vZGlmeV9kYXRhX3N0cmVhbSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBvcGVuKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19vcGVuYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLm9wZW4nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHByb21vdGVEYXRhU3RyZWFtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19kYXRhX3N0cmVhbS9fcHJvbW90ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMucHJvbW90ZV9kYXRhX3N0cmVhbScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dEFsaWFzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4JywgJ25hbWUnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydmaWx0ZXInLCAnaW5kZXhfcm91dGluZycsICdpc193cml0ZV9pbmRleCcsICdyb3V0aW5nJywgJ3NlYXJjaF9yb3V0aW5nJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsICYmIHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYWxpYXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fYWxpYXNlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5wdXRfYWxpYXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleCxcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dERhdGFMaWZlY3ljbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RhdGFfcmV0ZW50aW9uJywgJ2Rvd25zYW1wbGluZyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2RhdGFfc3RyZWFtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfS9fbGlmZWN5Y2xlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnB1dF9kYXRhX2xpZmVjeWNsZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dEluZGV4VGVtcGxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2luZGV4X3BhdHRlcm5zJywgJ2NvbXBvc2VkX29mJywgJ3RlbXBsYXRlJywgJ2RhdGFfc3RyZWFtJywgJ3ByaW9yaXR5JywgJ3ZlcnNpb24nLCAnX21ldGEnLCAnYWxsb3dfYXV0b19jcmVhdGUnLCAnaWdub3JlX21pc3NpbmdfY29tcG9uZW50X3RlbXBsYXRlcycsICdkZXByZWNhdGVkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9faW5kZXhfdGVtcGxhdGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnB1dF9pbmRleF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dE1hcHBpbmcocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkYXRlX2RldGVjdGlvbicsICdkeW5hbWljJywgJ2R5bmFtaWNfZGF0ZV9mb3JtYXRzJywgJ2R5bmFtaWNfdGVtcGxhdGVzJywgJ19maWVsZF9uYW1lcycsICdfbWV0YScsICdudW1lcmljX2RldGVjdGlvbicsICdwcm9wZXJ0aWVzJywgJ19yb3V0aW5nJywgJ19zb3VyY2UnLCAncnVudGltZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fbWFwcGluZ2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5wdXRfbWFwcGluZycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0U2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3NldHRpbmdzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3NldHRpbmdzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NldHRpbmdzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMucHV0X3NldHRpbmdzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRUZW1wbGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWxpYXNlcycsICdpbmRleF9wYXR0ZXJucycsICdtYXBwaW5ncycsICdvcmRlcicsICdzZXR0aW5ncycsICd2ZXJzaW9uJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fdGVtcGxhdGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnB1dF90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY292ZXJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3JlY292ZXJ5YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3JlY292ZXJ5JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMucmVjb3ZlcnknLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlZnJlc2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fcmVmcmVzaGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19yZWZyZXNoJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMucmVmcmVzaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVsb2FkU2VhcmNoQW5hbHl6ZXJzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3JlbG9hZF9zZWFyY2hfYW5hbHl6ZXJzYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnJlbG9hZF9zZWFyY2hfYW5hbHl6ZXJzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXNvbHZlQ2x1c3RlcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19yZXNvbHZlL2NsdXN0ZXIvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnJlc29sdmVfY2x1c3RlcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVJbmRleChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19yZXNvbHZlL2luZGV4LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5yZXNvbHZlX2luZGV4JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcm9sbG92ZXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnYWxpYXMnLCAnbmV3X2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWxpYXNlcycsICdjb25kaXRpb25zJywgJ21hcHBpbmdzJywgJ3NldHRpbmdzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5hbGlhcyAhPSBudWxsICYmIHBhcmFtcy5uZXdfaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmFsaWFzLnRvU3RyaW5nKCkpfS9fcm9sbG92ZXIvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5ld19pbmRleC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmFsaWFzLnRvU3RyaW5nKCkpfS9fcm9sbG92ZXJgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5yb2xsb3ZlcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBhbGlhczogcGFyYW1zLmFsaWFzLFxuICAgICAgICAgICAgICAgIG5ld19pbmRleDogcGFyYW1zLm5ld19pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNlZ21lbnRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3NlZ21lbnRzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NlZ21lbnRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuc2VnbWVudHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNoYXJkU3RvcmVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3NoYXJkX3N0b3Jlc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zaGFyZF9zdG9yZXMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5zaGFyZF9zdG9yZXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNocmluayhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCcsICd0YXJnZXQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbGlhc2VzJywgJ3NldHRpbmdzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zaHJpbmsvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhcmdldC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMuc2hyaW5rJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBwYXJhbXMudGFyZ2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGVJbmRleFRlbXBsYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19pbmRleF90ZW1wbGF0ZS9fc2ltdWxhdGVfaW5kZXgvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnNpbXVsYXRlX2luZGV4X3RlbXBsYXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGVUZW1wbGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWxsb3dfYXV0b19jcmVhdGUnLCAnaW5kZXhfcGF0dGVybnMnLCAnY29tcG9zZWRfb2YnLCAndGVtcGxhdGUnLCAnZGF0YV9zdHJlYW0nLCAncHJpb3JpdHknLCAndmVyc2lvbicsICdfbWV0YScsICdpZ25vcmVfbWlzc2luZ19jb21wb25lbnRfdGVtcGxhdGVzJywgJ2RlcHJlY2F0ZWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmRleF90ZW1wbGF0ZS9fc2ltdWxhdGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19pbmRleF90ZW1wbGF0ZS9fc2ltdWxhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5zaW11bGF0ZV90ZW1wbGF0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNwbGl0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4JywgJ3RhcmdldCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FsaWFzZXMnLCAnc2V0dGluZ3MnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3NwbGl0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXJnZXQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmRpY2VzLnNwbGl0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBwYXJhbXMudGFyZ2V0XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbWV0cmljJywgJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsICYmIHBhcmFtcy5tZXRyaWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zdGF0cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubWV0cmljLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zdGF0cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubWV0cmljLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fc3RhdHNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fc3RhdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy5zdGF0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtZXRyaWM6IHBhcmFtcy5tZXRyaWMsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVuZnJlZXplKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L191bmZyZWV6ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy51bmZyZWV6ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlQWxpYXNlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWN0aW9ucyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fYWxpYXNlcyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5kaWNlcy51cGRhdGVfYWxpYXNlcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZVF1ZXJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsncXVlcnknXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3ZhbGlkYXRlL3F1ZXJ5YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3ZhbGlkYXRlL3F1ZXJ5JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZGljZXMudmFsaWRhdGVfcXVlcnknLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kaWNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGljZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/indices.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/inference.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/inference.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Inference {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['task_type', 'inference_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_type != null && params.inference_id != null) {\n            method = 'DELETE';\n            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        const meta = {\n            name: 'inference.delete',\n            pathParts: {\n                task_type: params.task_type,\n                inference_id: params.inference_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['task_type', 'inference_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_type != null && params.inference_id != null) {\n            method = 'GET';\n            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        else if (params.inference_id != null) {\n            method = 'GET';\n            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_inference';\n        }\n        const meta = {\n            name: 'inference.get',\n            pathParts: {\n                task_type: params.task_type,\n                inference_id: params.inference_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async inference(params, options) {\n        const acceptedPath = ['task_type', 'inference_id'];\n        const acceptedBody = ['query', 'input', 'task_settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_type != null && params.inference_id != null) {\n            method = 'POST';\n            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        const meta = {\n            name: 'inference.inference',\n            pathParts: {\n                task_type: params.task_type,\n                inference_id: params.inference_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async put(params, options) {\n        var _a;\n        const acceptedPath = ['task_type', 'inference_id'];\n        const acceptedBody = ['inference_config'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_type != null && params.inference_id != null) {\n            method = 'PUT';\n            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}`;\n        }\n        const meta = {\n            name: 'inference.put',\n            pathParts: {\n                task_type: params.task_type,\n                inference_id: params.inference_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async streamInference(params, options) {\n        const acceptedPath = ['inference_id', 'task_type'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_type != null && params.inference_id != null) {\n            method = 'POST';\n            path = `/_inference/${encodeURIComponent(params.task_type.toString())}/${encodeURIComponent(params.inference_id.toString())}/_stream`;\n        }\n        else {\n            method = 'POST';\n            path = `/_inference/${encodeURIComponent(params.inference_id.toString())}/_stream`;\n        }\n        const meta = {\n            name: 'inference.stream_inference',\n            pathParts: {\n                inference_id: params.inference_id,\n                task_type: params.task_type\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Inference;\n//# sourceMappingURL=inference.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmZlcmVuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnREFBZ0QsR0FBRyxtREFBbUQ7QUFDeEk7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnREFBZ0QsR0FBRyxtREFBbUQ7QUFDeEk7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdEQUFnRCxHQUFHLG1EQUFtRDtBQUN4STtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQW1EO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdEQUFnRCxHQUFHLG1EQUFtRDtBQUN4STtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQW1EO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnREFBZ0QsR0FBRyxtREFBbUQ7QUFDeEk7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvaW5mZXJlbmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBJbmZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0YXNrX3R5cGUnLCAnaW5mZXJlbmNlX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLnRhc2tfdHlwZSAhPSBudWxsICYmIHBhcmFtcy5pbmZlcmVuY2VfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5mZXJlbmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXNrX3R5cGUudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmZlcmVuY2VfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2luZmVyZW5jZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5mZXJlbmNlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmZlcmVuY2UuZGVsZXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRhc2tfdHlwZTogcGFyYW1zLnRhc2tfdHlwZSxcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VfaWQ6IHBhcmFtcy5pbmZlcmVuY2VfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndGFza190eXBlJywgJ2luZmVyZW5jZV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMudGFza190eXBlICE9IG51bGwgJiYgcGFyYW1zLmluZmVyZW5jZV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmZlcmVuY2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhc2tfdHlwZS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZmVyZW5jZV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5pbmZlcmVuY2VfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5mZXJlbmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmZlcmVuY2VfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2luZmVyZW5jZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmZlcmVuY2UuZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRhc2tfdHlwZTogcGFyYW1zLnRhc2tfdHlwZSxcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VfaWQ6IHBhcmFtcy5pbmZlcmVuY2VfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBpbmZlcmVuY2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndGFza190eXBlJywgJ2luZmVyZW5jZV9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3F1ZXJ5JywgJ2lucHV0JywgJ3Rhc2tfc2V0dGluZ3MnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLnRhc2tfdHlwZSAhPSBudWxsICYmIHBhcmFtcy5pbmZlcmVuY2VfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2luZmVyZW5jZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudGFza190eXBlLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5mZXJlbmNlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5mZXJlbmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmZlcmVuY2VfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZmVyZW5jZS5pbmZlcmVuY2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdGFza190eXBlOiBwYXJhbXMudGFza190eXBlLFxuICAgICAgICAgICAgICAgIGluZmVyZW5jZV9pZDogcGFyYW1zLmluZmVyZW5jZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3Rhc2tfdHlwZScsICdpbmZlcmVuY2VfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydpbmZlcmVuY2VfY29uZmlnJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy50YXNrX3R5cGUgIT0gbnVsbCAmJiBwYXJhbXMuaW5mZXJlbmNlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2luZmVyZW5jZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudGFza190eXBlLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5mZXJlbmNlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmZlcmVuY2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZmVyZW5jZV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5mZXJlbmNlLnB1dCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB0YXNrX3R5cGU6IHBhcmFtcy50YXNrX3R5cGUsXG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlX2lkOiBwYXJhbXMuaW5mZXJlbmNlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RyZWFtSW5mZXJlbmNlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZmVyZW5jZV9pZCcsICd0YXNrX3R5cGUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMudGFza190eXBlICE9IG51bGwgJiYgcGFyYW1zLmluZmVyZW5jZV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5mZXJlbmNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXNrX3R5cGUudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmZlcmVuY2VfaWQudG9TdHJpbmcoKSl9L19zdHJlYW1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2luZmVyZW5jZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5mZXJlbmNlX2lkLnRvU3RyaW5nKCkpfS9fc3RyZWFtYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZmVyZW5jZS5zdHJlYW1faW5mZXJlbmNlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZV9pZDogcGFyYW1zLmluZmVyZW5jZV9pZCxcbiAgICAgICAgICAgICAgICB0YXNrX3R5cGU6IHBhcmFtcy50YXNrX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEluZmVyZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/inference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/info.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/info.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function InfoApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/';\n    const meta = {\n        name: 'info'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = InfoApi;\n//# sourceMappingURL=info.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvaW5mby5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gSW5mb0FwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gJy8nO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdpbmZvJ1xuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW5mb0FwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZm8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ingest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ingest.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ingest {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteGeoipDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.delete_geoip_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteIpLocationDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.delete_ip_location_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deletePipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.delete_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async geoIpStats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ingest/geoip/stats';\n        const meta = {\n            name: 'ingest.geo_ip_stats'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getGeoipDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ingest/geoip/database';\n        }\n        const meta = {\n            name: 'ingest.get_geoip_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getIpLocationDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ingest/ip_location/database';\n        }\n        const meta = {\n            name: 'ingest.get_ip_location_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ingest/pipeline';\n        }\n        const meta = {\n            name: 'ingest.get_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async processorGrok(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ingest/processor/grok';\n        const meta = {\n            name: 'ingest.processor_grok'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putGeoipDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['name', 'maxmind'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ingest/geoip/database/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.put_geoip_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putIpLocationDatabase(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ingest/ip_location/database/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.put_ip_location_database',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['_meta', 'description', 'on_failure', 'processors', 'version', 'deprecated'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ingest.put_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async simulate(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['docs', 'pipeline'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}/_simulate`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ingest/pipeline/_simulate';\n        }\n        const meta = {\n            name: 'ingest.simulate',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Ingest;\n//# sourceMappingURL=ingest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmdlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUNBQXlDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlDQUF5QztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUNBQXlDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHlDQUF5QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QseUNBQXlDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUNBQXlDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUNBQXlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9pbmdlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEluZ2VzdCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlR2VvaXBEYXRhYmFzZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9faW5nZXN0L2dlb2lwL2RhdGFiYXNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZ2VzdC5kZWxldGVfZ2VvaXBfZGF0YWJhc2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUlwTG9jYXRpb25EYXRhYmFzZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9faW5nZXN0L2lwX2xvY2F0aW9uL2RhdGFiYXNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZ2VzdC5kZWxldGVfaXBfbG9jYXRpb25fZGF0YWJhc2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVBpcGVsaW5lKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19pbmdlc3QvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5nZXN0LmRlbGV0ZV9waXBlbGluZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2VvSXBTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9faW5nZXN0L2dlb2lwL3N0YXRzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3QuZ2VvX2lwX3N0YXRzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldEdlb2lwRGF0YWJhc2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2luZ2VzdC9nZW9pcC9kYXRhYmFzZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2luZ2VzdC9nZW9pcC9kYXRhYmFzZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3QuZ2V0X2dlb2lwX2RhdGFiYXNlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRJcExvY2F0aW9uRGF0YWJhc2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5nZXN0L2lwX2xvY2F0aW9uL2RhdGFiYXNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9faW5nZXN0L2lwX2xvY2F0aW9uL2RhdGFiYXNlJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2luZ2VzdC5nZXRfaXBfbG9jYXRpb25fZGF0YWJhc2UnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFBpcGVsaW5lKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmdlc3QvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19pbmdlc3QvcGlwZWxpbmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5nZXN0LmdldF9waXBlbGluZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc29yR3JvayhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9faW5nZXN0L3Byb2Nlc3Nvci9ncm9rJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3QucHJvY2Vzc29yX2dyb2snXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0R2VvaXBEYXRhYmFzZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ25hbWUnLCAnbWF4bWluZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2luZ2VzdC9nZW9pcC9kYXRhYmFzZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3QucHV0X2dlb2lwX2RhdGFiYXNlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRJcExvY2F0aW9uRGF0YWJhc2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2luZ2VzdC9pcF9sb2NhdGlvbi9kYXRhYmFzZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3QucHV0X2lwX2xvY2F0aW9uX2RhdGFiYXNlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRQaXBlbGluZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ19tZXRhJywgJ2Rlc2NyaXB0aW9uJywgJ29uX2ZhaWx1cmUnLCAncHJvY2Vzc29ycycsICd2ZXJzaW9uJywgJ2RlcHJlY2F0ZWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19pbmdlc3QvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnaW5nZXN0LnB1dF9waXBlbGluZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2ltdWxhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkb2NzJywgJ3BpcGVsaW5lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19pbmdlc3QvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfS9fc2ltdWxhdGVgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9faW5nZXN0L3BpcGVsaW5lL19zaW11bGF0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmdlc3Quc2ltdWxhdGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gSW5nZXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5nZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ingest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function KnnSearchApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['_source', 'docvalue_fields', 'stored_fields', 'fields', 'filter', 'knn'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_knn_search`;\n    const meta = {\n        name: 'knn_search',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = KnnSearchApi;\n//# sourceMappingURL=knn_search.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9rbm5fc2VhcmNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkva25uX3NlYXJjaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gS25uU2VhcmNoQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ19zb3VyY2UnLCAnZG9jdmFsdWVfZmllbGRzJywgJ3N0b3JlZF9maWVsZHMnLCAnZmllbGRzJywgJ2ZpbHRlcicsICdrbm4nXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19rbm5fc2VhcmNoYDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAna25uX3NlYXJjaCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBLbm5TZWFyY2hBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rbm5fc2VhcmNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/license.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/license.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass License {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_license';\n        const meta = {\n            name: 'license.delete'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license';\n        const meta = {\n            name: 'license.get'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getBasicStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license/basic_status';\n        const meta = {\n            name: 'license.get_basic_status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTrialStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license/trial_status';\n        const meta = {\n            name: 'license.get_trial_status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async post(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['license', 'licenses'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_license';\n        const meta = {\n            name: 'license.post'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postStartBasic(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_license/start_basic';\n        const meta = {\n            name: 'license.post_start_basic'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postStartTrial(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_license/start_trial';\n        const meta = {\n            name: 'license.post_start_trial'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = License;\n//# sourceMappingURL=license.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9saWNlbnNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9saWNlbnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBMaWNlbnNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2xpY2Vuc2UnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2xpY2Vuc2UuZGVsZXRlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fbGljZW5zZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbGljZW5zZS5nZXQnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmFzaWNTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2xpY2Vuc2UvYmFzaWNfc3RhdHVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsaWNlbnNlLmdldF9iYXNpY19zdGF0dXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJpYWxTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX2xpY2Vuc2UvdHJpYWxfc3RhdHVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsaWNlbnNlLmdldF90cmlhbF9zdGF0dXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcG9zdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbGljZW5zZScsICdsaWNlbnNlcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19saWNlbnNlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsaWNlbnNlLnBvc3QnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcG9zdFN0YXJ0QmFzaWMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19saWNlbnNlL3N0YXJ0X2Jhc2ljJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsaWNlbnNlLnBvc3Rfc3RhcnRfYmFzaWMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcG9zdFN0YXJ0VHJpYWwocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19saWNlbnNlL3N0YXJ0X3RyaWFsJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsaWNlbnNlLnBvc3Rfc3RhcnRfdHJpYWwnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMaWNlbnNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGljZW5zZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/license.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/logstash.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/logstash.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Logstash {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deletePipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'logstash.delete_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_logstash/pipeline';\n        }\n        const meta = {\n            name: 'logstash.get_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putPipeline(params, options) {\n        var _a;\n        const acceptedPath = ['id'];\n        const acceptedBody = ['pipeline'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'logstash.put_pipeline',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Logstash;\n//# sourceMappingURL=logstash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9sb2dzdGFzaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHlDQUF5QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHlDQUF5QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5Q0FBeUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvbG9nc3Rhc2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIExvZ3N0YXNoIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVQaXBlbGluZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbG9nc3Rhc2gvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbG9nc3Rhc2guZGVsZXRlX3BpcGVsaW5lJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRQaXBlbGluZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbG9nc3Rhc2gvcGlwZWxpbmUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19sb2dzdGFzaC9waXBlbGluZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdsb2dzdGFzaC5nZXRfcGlwZWxpbmUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dFBpcGVsaW5lKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydwaXBlbGluZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGxldCBib2R5ID0gKF9hID0gcGFyYW1zLmJvZHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2xvZ3N0YXNoL3BpcGVsaW5lLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ2xvZ3N0YXNoLnB1dF9waXBlbGluZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBMb2dzdGFzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ3N0YXNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/logstash.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mget.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/mget.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function MgetApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['docs', 'ids'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_mget`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_mget';\n    }\n    const meta = {\n        name: 'mget',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = MgetApi;\n//# sourceMappingURL=mget.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tZ2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvbWdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gTWdldEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkb2NzJywgJ2lkcyddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fbWdldGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9ICcvX21nZXQnO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnbWdldCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNZ2V0QXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWdldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mget.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/migration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/migration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Migration {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deprecations(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_migration/deprecations`;\n        }\n        else {\n            method = 'GET';\n            path = '/_migration/deprecations';\n        }\n        const meta = {\n            name: 'migration.deprecations',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getFeatureUpgradeStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_migration/system_features';\n        const meta = {\n            name: 'migration.get_feature_upgrade_status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postFeatureUpgrade(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_migration/system_features';\n        const meta = {\n            name: 'migration.post_feature_upgrade'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Migration;\n//# sourceMappingURL=migration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9taWdyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvbWlncmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBNaWdyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGRlcHJlY2F0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19taWdyYXRpb24vZGVwcmVjYXRpb25zYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21pZ3JhdGlvbi9kZXByZWNhdGlvbnMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWlncmF0aW9uLmRlcHJlY2F0aW9ucycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmVhdHVyZVVwZ3JhZGVTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX21pZ3JhdGlvbi9zeXN0ZW1fZmVhdHVyZXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21pZ3JhdGlvbi5nZXRfZmVhdHVyZV91cGdyYWRlX3N0YXR1cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwb3N0RmVhdHVyZVVwZ3JhZGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19taWdyYXRpb24vc3lzdGVtX2ZlYXR1cmVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtaWdyYXRpb24ucG9zdF9mZWF0dXJlX3VwZ3JhZGUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNaWdyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWdyYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/migration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ml.js":
/*!***************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ml.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ml {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async clearTrainedModelDeploymentCache(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/cache/_clear`;\n        const meta = {\n            name: 'ml.clear_trained_model_deployment_cache',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async closeJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_no_match', 'force', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_close`;\n        const meta = {\n            name: 'ml.close_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteCalendar(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_calendar',\n            pathParts: {\n                calendar_id: params.calendar_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteCalendarEvent(params, options) {\n        const acceptedPath = ['calendar_id', 'event_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events/${encodeURIComponent(params.event_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_calendar_event',\n            pathParts: {\n                calendar_id: params.calendar_id,\n                event_id: params.event_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteCalendarJob(params, options) {\n        const acceptedPath = ['calendar_id', 'job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_calendar_job',\n            pathParts: {\n                calendar_id: params.calendar_id,\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ml.delete_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteExpiredData(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['requests_per_second', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'DELETE';\n            path = `/_ml/_delete_expired_data/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = '/_ml/_delete_expired_data';\n        }\n        const meta = {\n            name: 'ml.delete_expired_data',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_filter',\n            pathParts: {\n                filter_id: params.filter_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteForecast(params, options) {\n        const acceptedPath = ['job_id', 'forecast_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.forecast_id != null) {\n            method = 'DELETE';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast/${encodeURIComponent(params.forecast_id.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;\n        }\n        const meta = {\n            name: 'ml.delete_forecast',\n            pathParts: {\n                job_id: params.job_id,\n                forecast_id: params.forecast_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_model_snapshot',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteTrainedModel(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        const meta = {\n            name: 'ml.delete_trained_model',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteTrainedModelAlias(params, options) {\n        const acceptedPath = ['model_alias', 'model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;\n        const meta = {\n            name: 'ml.delete_trained_model_alias',\n            pathParts: {\n                model_alias: params.model_alias,\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async estimateModelMemory(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['analysis_config', 'max_bucket_cardinality', 'overall_cardinality'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_estimate_model_memory';\n        const meta = {\n            name: 'ml.estimate_model_memory'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async evaluateDataFrame(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['evaluation', 'index', 'query'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/data_frame/_evaluate';\n        const meta = {\n            name: 'ml.evaluate_data_frame'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async explainDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['source', 'dest', 'analysis', 'description', 'model_memory_limit', 'max_num_threads', 'analyzed_fields', 'allow_lazy_start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_explain`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/data_frame/analytics/_explain';\n        }\n        const meta = {\n            name: 'ml.explain_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async flushJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['advance_time', 'calc_interim', 'end', 'skip_time', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_flush`;\n        const meta = {\n            name: 'ml.flush_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async forecast(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['duration', 'expires_in', 'max_model_memory'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;\n        const meta = {\n            name: 'ml.forecast',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getBuckets(params, options) {\n        const acceptedPath = ['job_id', 'timestamp'];\n        const acceptedBody = ['anomaly_score', 'desc', 'end', 'exclude_interim', 'expand', 'page', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.timestamp != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets/${encodeURIComponent(params.timestamp.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets`;\n        }\n        const meta = {\n            name: 'ml.get_buckets',\n            pathParts: {\n                job_id: params.job_id,\n                timestamp: params.timestamp\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getCalendarEvents(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;\n        const meta = {\n            name: 'ml.get_calendar_events',\n            pathParts: {\n                calendar_id: params.calendar_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getCalendars(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.calendar_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/calendars';\n        }\n        const meta = {\n            name: 'ml.get_calendars',\n            pathParts: {\n                calendar_id: params.calendar_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getCategories(params, options) {\n        const acceptedPath = ['job_id', 'category_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.category_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/${encodeURIComponent(params.category_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories`;\n        }\n        const meta = {\n            name: 'ml.get_categories',\n            pathParts: {\n                job_id: params.job_id,\n                category_id: params.category_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/data_frame/analytics';\n        }\n        const meta = {\n            name: 'ml.get_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDataFrameAnalyticsStats(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/data_frame/analytics/_stats';\n        }\n        const meta = {\n            name: 'ml.get_data_frame_analytics_stats',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDatafeedStats(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/datafeeds/_stats';\n        }\n        const meta = {\n            name: 'ml.get_datafeed_stats',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getDatafeeds(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/datafeeds';\n        }\n        const meta = {\n            name: 'ml.get_datafeeds',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getFilters(params, options) {\n        const acceptedPath = ['filter_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.filter_id != null) {\n            method = 'GET';\n            path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/filters';\n        }\n        const meta = {\n            name: 'ml.get_filters',\n            pathParts: {\n                filter_id: params.filter_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getInfluencers(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/influencers`;\n        const meta = {\n            name: 'ml.get_influencers',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getJobStats(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/anomaly_detectors/_stats';\n        }\n        const meta = {\n            name: 'ml.get_job_stats',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getJobs(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/anomaly_detectors';\n        }\n        const meta = {\n            name: 'ml.get_jobs',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getMemoryStats(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_ml/memory/${encodeURIComponent(params.node_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/memory/_stats';\n        }\n        const meta = {\n            name: 'ml.get_memory_stats',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getModelSnapshotUpgradeStats(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade/_stats`;\n        const meta = {\n            name: 'ml.get_model_snapshot_upgrade_stats',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getModelSnapshots(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['desc', 'end', 'page', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.snapshot_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots`;\n        }\n        const meta = {\n            name: 'ml.get_model_snapshots',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getOverallBuckets(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_no_match', 'bucket_span', 'end', 'exclude_interim', 'overall_score', 'start', 'top_n'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/overall_buckets`;\n        const meta = {\n            name: 'ml.get_overall_buckets',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRecords(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['desc', 'end', 'exclude_interim', 'page', 'record_score', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/records`;\n        const meta = {\n            name: 'ml.get_records',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTrainedModels(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/trained_models';\n        }\n        const meta = {\n            name: 'ml.get_trained_models',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTrainedModelsStats(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/trained_models/_stats';\n        }\n        const meta = {\n            name: 'ml.get_trained_models_stats',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async inferTrainedModel(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['docs', 'inference_config'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_infer`;\n        const meta = {\n            name: 'ml.infer_trained_model',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async info(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ml/info';\n        const meta = {\n            name: 'ml.info'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async openJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_open`;\n        const meta = {\n            name: 'ml.open_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postCalendarEvents(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['events'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;\n        const meta = {\n            name: 'ml.post_calendar_events',\n            pathParts: {\n                calendar_id: params.calendar_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postData(params, options) {\n        var _a;\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['data'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_data`;\n        const meta = {\n            name: 'ml.post_data',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n    }\n    async previewDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['config'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/data_frame/analytics/_preview';\n        }\n        const meta = {\n            name: 'ml.preview_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async previewDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['datafeed_config', 'job_config'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/datafeeds/_preview';\n        }\n        const meta = {\n            name: 'ml.preview_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putCalendar(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['job_ids', 'description'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        const meta = {\n            name: 'ml.put_calendar',\n            pathParts: {\n                calendar_id: params.calendar_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putCalendarJob(params, options) {\n        const acceptedPath = ['calendar_id', 'job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;\n        const meta = {\n            name: 'ml.put_calendar_job',\n            pathParts: {\n                calendar_id: params.calendar_id,\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['allow_lazy_start', 'analysis', 'analyzed_fields', 'description', 'dest', 'max_num_threads', 'model_memory_limit', 'source', 'headers', 'version'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'ml.put_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['aggregations', 'chunking_config', 'delayed_data_check_config', 'frequency', 'indices', 'indexes', 'indices_options', 'job_id', 'max_empty_searches', 'query', 'query_delay', 'runtime_mappings', 'script_fields', 'scroll_size', 'headers'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        const meta = {\n            name: 'ml.put_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const acceptedBody = ['description', 'items'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        const meta = {\n            name: 'ml.put_filter',\n            pathParts: {\n                filter_id: params.filter_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_lazy_open', 'analysis_config', 'analysis_limits', 'background_persist_interval', 'custom_settings', 'daily_model_snapshot_retention_after_days', 'data_description', 'datafeed_config', 'description', 'groups', 'model_plot_config', 'model_snapshot_retention_days', 'renormalization_window_days', 'results_index_name', 'results_retention_days'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        const meta = {\n            name: 'ml.put_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTrainedModel(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['compressed_definition', 'definition', 'description', 'inference_config', 'input', 'metadata', 'model_type', 'model_size_bytes', 'platform_architecture', 'tags', 'prefix_strings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        const meta = {\n            name: 'ml.put_trained_model',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTrainedModelAlias(params, options) {\n        const acceptedPath = ['model_alias', 'model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;\n        const meta = {\n            name: 'ml.put_trained_model_alias',\n            pathParts: {\n                model_alias: params.model_alias,\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTrainedModelDefinitionPart(params, options) {\n        const acceptedPath = ['model_id', 'part'];\n        const acceptedBody = ['definition', 'total_definition_length', 'total_parts'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/definition/${encodeURIComponent(params.part.toString())}`;\n        const meta = {\n            name: 'ml.put_trained_model_definition_part',\n            pathParts: {\n                model_id: params.model_id,\n                part: params.part\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTrainedModelVocabulary(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['vocabulary', 'merges', 'scores'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/vocabulary`;\n        const meta = {\n            name: 'ml.put_trained_model_vocabulary',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resetJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_reset`;\n        const meta = {\n            name: 'ml.reset_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async revertModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['delete_intervening_results'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_revert`;\n        const meta = {\n            name: 'ml.revert_model_snapshot',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async setUpgradeMode(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/set_upgrade_mode';\n        const meta = {\n            name: 'ml.set_upgrade_mode'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async startDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_start`;\n        const meta = {\n            name: 'ml.start_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async startDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['end', 'start', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_start`;\n        const meta = {\n            name: 'ml.start_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async startTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_start`;\n        const meta = {\n            name: 'ml.start_trained_model_deployment',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stopDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stop`;\n        const meta = {\n            name: 'ml.stop_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stopDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['allow_no_match', 'force', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stop`;\n        const meta = {\n            name: 'ml.stop_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stopTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stop`;\n        const meta = {\n            name: 'ml.stop_trained_model_deployment',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['description', 'model_memory_limit', 'max_num_threads', 'allow_lazy_start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_update`;\n        const meta = {\n            name: 'ml.update_data_frame_analytics',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['aggregations', 'chunking_config', 'delayed_data_check_config', 'frequency', 'indices', 'indexes', 'indices_options', 'job_id', 'max_empty_searches', 'query', 'query_delay', 'runtime_mappings', 'script_fields', 'scroll_size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_update`;\n        const meta = {\n            name: 'ml.update_datafeed',\n            pathParts: {\n                datafeed_id: params.datafeed_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const acceptedBody = ['add_items', 'description', 'remove_items'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}/_update`;\n        const meta = {\n            name: 'ml.update_filter',\n            pathParts: {\n                filter_id: params.filter_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_lazy_open', 'analysis_limits', 'background_persist_interval', 'custom_settings', 'categorization_filters', 'description', 'model_plot_config', 'model_prune_window', 'daily_model_snapshot_retention_after_days', 'model_snapshot_retention_days', 'renormalization_window_days', 'results_retention_days', 'groups', 'detectors', 'per_partition_categorization'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_update`;\n        const meta = {\n            name: 'ml.update_job',\n            pathParts: {\n                job_id: params.job_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['description', 'retain'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_update`;\n        const meta = {\n            name: 'ml.update_model_snapshot',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['number_of_allocations'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_update`;\n        const meta = {\n            name: 'ml.update_trained_model_deployment',\n            pathParts: {\n                model_id: params.model_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async upgradeJobSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade`;\n        const meta = {\n            name: 'ml.upgrade_job_snapshot',\n            pathParts: {\n                job_id: params.job_id,\n                snapshot_id: params.snapshot_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async validate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['job_id', 'analysis_config', 'analysis_limits', 'data_description', 'description', 'model_plot', 'model_snapshot_id', 'model_snapshot_retention_days', 'results_index_name'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_validate';\n        const meta = {\n            name: 'ml.validate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async validateDetector(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['detector'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_validate/detector';\n        const meta = {\n            name: 'ml.validate_detector'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Ml;\n//# sourceMappingURL=ml.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBa0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtELFVBQVUsK0NBQStDO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtELFFBQVEsNkNBQTZDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUNBQXlDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUFrRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNkNBQTZDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBZ0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDLGFBQWEsa0RBQWtEO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkMsbUJBQW1CLGtEQUFrRDtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0MsaUJBQWlCLGtEQUFrRDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkMsbUJBQW1CLGdEQUFnRDtBQUM3SjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBa0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtEQUFrRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkMsc0JBQXNCLGtEQUFrRDtBQUNsSztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHlDQUF5QztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsa0RBQWtEO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGtEQUFrRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnREFBZ0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZDQUE2QztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4Q0FBOEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QyxtQkFBbUIsa0RBQWtEO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw2Q0FBNkMsbUJBQW1CLGtEQUFrRDtBQUMvSjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsNkNBQTZDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtDQUErQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywrQ0FBK0M7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0NBQStDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpREFBaUQ7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5Q0FBeUM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxrREFBa0Q7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUFrRCxRQUFRLDZDQUE2QztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUNBQXlDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQWdEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsK0NBQStDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQyxpQkFBaUIsa0RBQWtEO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0MsY0FBYywyQ0FBMkM7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkM7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2Q0FBNkMsbUJBQW1CLGtEQUFrRDtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlDQUF5QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUFrRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QseUNBQXlDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0RBQWtEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLCtDQUErQztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlDQUF5QztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUFrRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFnRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QyxtQkFBbUIsa0RBQWtEO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QywrQ0FBK0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDLG1CQUFtQixrREFBa0Q7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL21sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBNbCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXJUcmFpbmVkTW9kZWxEZXBsb3ltZW50Q2FjaGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbW9kZWxfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC90cmFpbmVkX21vZGVscy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfaWQudG9TdHJpbmcoKSl9L2RlcGxveW1lbnQvY2FjaGUvX2NsZWFyYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5jbGVhcl90cmFpbmVkX21vZGVsX2RlcGxveW1lbnRfY2FjaGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbW9kZWxfaWQ6IHBhcmFtcy5tb2RlbF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNsb3NlSm9iKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FsbG93X25vX21hdGNoJywgJ2ZvcmNlJywgJ3RpbWVvdXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX2Nsb3NlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5jbG9zZV9qb2InLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlQ2FsZW5kYXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY2FsZW5kYXJfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2NhbGVuZGFycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY2FsZW5kYXJfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfY2FsZW5kYXInLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJfaWQ6IHBhcmFtcy5jYWxlbmRhcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUNhbGVuZGFyRXZlbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY2FsZW5kYXJfaWQnLCAnZXZlbnRfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2NhbGVuZGFycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuY2FsZW5kYXJfaWQudG9TdHJpbmcoKSl9L2V2ZW50cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuZXZlbnRfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfY2FsZW5kYXJfZXZlbnQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJfaWQ6IHBhcmFtcy5jYWxlbmRhcl9pZCxcbiAgICAgICAgICAgICAgICBldmVudF9pZDogcGFyYW1zLmV2ZW50X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlQ2FsZW5kYXJKb2IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY2FsZW5kYXJfaWQnLCAnam9iX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9jYWxlbmRhcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNhbGVuZGFyX2lkLnRvU3RyaW5nKCkpfS9qb2JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfY2FsZW5kYXJfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyX2lkOiBwYXJhbXMuY2FsZW5kYXJfaWQsXG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRGF0YUZyYW1lQW5hbHl0aWNzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9kYXRhX2ZyYW1lL2FuYWx5dGljcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfZGF0YV9mcmFtZV9hbmFseXRpY3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZURhdGFmZWVkKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2RhdGFmZWVkX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9kYXRhZmVlZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmRhdGFmZWVkX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZGVsZXRlX2RhdGFmZWVkJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGRhdGFmZWVkX2lkOiBwYXJhbXMuZGF0YWZlZWRfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVFeHBpcmVkRGF0YShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyZXF1ZXN0c19wZXJfc2Vjb25kJywgJ3RpbWVvdXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5qb2JfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvX2RlbGV0ZV9leHBpcmVkX2RhdGEvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gJy9fbWwvX2RlbGV0ZV9leHBpcmVkX2RhdGEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZGVsZXRlX2V4cGlyZWRfZGF0YScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVGaWx0ZXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnZmlsdGVyX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9maWx0ZXJzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5maWx0ZXJfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfZmlsdGVyJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGZpbHRlcl9pZDogcGFyYW1zLmZpbHRlcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUZvcmVjYXN0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCcsICdmb3JlY2FzdF9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5qb2JfaWQgIT0gbnVsbCAmJiBwYXJhbXMuZm9yZWNhc3RfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX2ZvcmVjYXN0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5mb3JlY2FzdF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX2ZvcmVjYXN0YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmRlbGV0ZV9mb3JlY2FzdCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWQsXG4gICAgICAgICAgICAgICAgZm9yZWNhc3RfaWQ6IHBhcmFtcy5mb3JlY2FzdF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUpvYihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2Fub21hbHlfZGV0ZWN0b3JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZU1vZGVsU25hcHNob3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJywgJ3NuYXBzaG90X2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9tb2RlbF9zbmFwc2hvdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90X2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZGVsZXRlX21vZGVsX3NuYXBzaG90JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZCxcbiAgICAgICAgICAgICAgICBzbmFwc2hvdF9pZDogcGFyYW1zLnNuYXBzaG90X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlVHJhaW5lZE1vZGVsKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC90cmFpbmVkX21vZGVscy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfdHJhaW5lZF9tb2RlbCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZDogcGFyYW1zLm1vZGVsX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlVHJhaW5lZE1vZGVsQWxpYXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbW9kZWxfYWxpYXMnLCAnbW9kZWxfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL3RyYWluZWRfbW9kZWxzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tb2RlbF9pZC50b1N0cmluZygpKX0vbW9kZWxfYWxpYXNlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfYWxpYXMudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5kZWxldGVfdHJhaW5lZF9tb2RlbF9hbGlhcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9hbGlhczogcGFyYW1zLm1vZGVsX2FsaWFzLFxuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBlc3RpbWF0ZU1vZGVsTWVtb3J5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbmFseXNpc19jb25maWcnLCAnbWF4X2J1Y2tldF9jYXJkaW5hbGl0eScsICdvdmVyYWxsX2NhcmRpbmFsaXR5J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19tbC9hbm9tYWx5X2RldGVjdG9ycy9fZXN0aW1hdGVfbW9kZWxfbWVtb3J5JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5lc3RpbWF0ZV9tb2RlbF9tZW1vcnknXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXZhbHVhdGVEYXRhRnJhbWUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2V2YWx1YXRpb24nLCAnaW5kZXgnLCAncXVlcnknXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fbWwvZGF0YV9mcmFtZS9fZXZhbHVhdGUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmV2YWx1YXRlX2RhdGFfZnJhbWUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhwbGFpbkRhdGFGcmFtZUFuYWx5dGljcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3NvdXJjZScsICdkZXN0JywgJ2FuYWx5c2lzJywgJ2Rlc2NyaXB0aW9uJywgJ21vZGVsX21lbW9yeV9saW1pdCcsICdtYXhfbnVtX3RocmVhZHMnLCAnYW5hbHl6ZWRfZmllbGRzJywgJ2FsbG93X2xhenlfc3RhcnQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9kYXRhX2ZyYW1lL2FuYWx5dGljcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9L19leHBsYWluYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzL19leHBsYWluJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmV4cGxhaW5fZGF0YV9mcmFtZV9hbmFseXRpY3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGZsdXNoSm9iKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FkdmFuY2VfdGltZScsICdjYWxjX2ludGVyaW0nLCAnZW5kJywgJ3NraXBfdGltZScsICdzdGFydCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9fZmx1c2hgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmZsdXNoX2pvYicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmb3JlY2FzdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkdXJhdGlvbicsICdleHBpcmVzX2luJywgJ21heF9tb2RlbF9tZW1vcnknXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX2ZvcmVjYXN0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5mb3JlY2FzdCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCdWNrZXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCcsICd0aW1lc3RhbXAnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbm9tYWx5X3Njb3JlJywgJ2Rlc2MnLCAnZW5kJywgJ2V4Y2x1ZGVfaW50ZXJpbScsICdleHBhbmQnLCAncGFnZScsICdzb3J0JywgJ3N0YXJ0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5qb2JfaWQgIT0gbnVsbCAmJiBwYXJhbXMudGltZXN0YW1wICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21sL2Fub21hbHlfZGV0ZWN0b3JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9L3Jlc3VsdHMvYnVja2V0cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudGltZXN0YW1wLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9yZXN1bHRzL2J1Y2tldHNgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X2J1Y2tldHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogcGFyYW1zLnRpbWVzdGFtcFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldENhbGVuZGFyRXZlbnRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2NhbGVuZGFyX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9jYWxlbmRhcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNhbGVuZGFyX2lkLnRvU3RyaW5nKCkpfS9ldmVudHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9jYWxlbmRhcl9ldmVudHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgY2FsZW5kYXJfaWQ6IHBhcmFtcy5jYWxlbmRhcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldENhbGVuZGFycyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjYWxlbmRhcl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3BhZ2UnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5jYWxlbmRhcl9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9jYWxlbmRhcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNhbGVuZGFyX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC9jYWxlbmRhcnMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X2NhbGVuZGFycycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcl9pZDogcGFyYW1zLmNhbGVuZGFyX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Q2F0ZWdvcmllcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnLCAnY2F0ZWdvcnlfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydwYWdlJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5qb2JfaWQgIT0gbnVsbCAmJiBwYXJhbXMuY2F0ZWdvcnlfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vcmVzdWx0cy9jYXRlZ29yaWVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jYXRlZ29yeV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vcmVzdWx0cy9jYXRlZ29yaWVzYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9jYXRlZ29yaWVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZCxcbiAgICAgICAgICAgICAgICBjYXRlZ29yeV9pZDogcGFyYW1zLmNhdGVnb3J5X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YUZyYW1lQW5hbHl0aWNzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9kYXRhX2ZyYW1lL2FuYWx5dGljcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9kYXRhX2ZyYW1lX2FuYWx5dGljcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YUZyYW1lQW5hbHl0aWNzU3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3N0YXRzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzL19zdGF0cyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5nZXRfZGF0YV9mcmFtZV9hbmFseXRpY3Nfc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldERhdGFmZWVkU3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnZGF0YWZlZWRfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmRhdGFmZWVkX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21sL2RhdGFmZWVkcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuZGF0YWZlZWRfaWQudG9TdHJpbmcoKSl9L19zdGF0c2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC9kYXRhZmVlZHMvX3N0YXRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9kYXRhZmVlZF9zdGF0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBkYXRhZmVlZF9pZDogcGFyYW1zLmRhdGFmZWVkX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGF0YWZlZWRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2RhdGFmZWVkX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5kYXRhZmVlZF9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9kYXRhZmVlZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmRhdGFmZWVkX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC9kYXRhZmVlZHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X2RhdGFmZWVkcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBkYXRhZmVlZF9pZDogcGFyYW1zLmRhdGFmZWVkX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RmlsdGVycyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydmaWx0ZXJfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmZpbHRlcl9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9maWx0ZXJzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5maWx0ZXJfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL2ZpbHRlcnMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X2ZpbHRlcnMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgZmlsdGVyX2lkOiBwYXJhbXMuZmlsdGVyX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0SW5mbHVlbmNlcnMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsncGFnZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2Fub21hbHlfZGV0ZWN0b3JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9L3Jlc3VsdHMvaW5mbHVlbmNlcnNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9pbmZsdWVuY2VycycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRKb2JTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmpvYl9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9fc3RhdHNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fbWwvYW5vbWFseV9kZXRlY3RvcnMvX3N0YXRzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9qb2Jfc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Sm9icyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmpvYl9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC9hbm9tYWx5X2RldGVjdG9ycyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5nZXRfam9icycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRNZW1vcnlTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21sL21lbW9yeS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vX3N0YXRzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL21lbW9yeS9fc3RhdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X21lbW9yeV9zdGF0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE1vZGVsU25hcHNob3RVcGdyYWRlU3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJywgJ3NuYXBzaG90X2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9tb2RlbF9zbmFwc2hvdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90X2lkLnRvU3RyaW5nKCkpfS9fdXBncmFkZS9fc3RhdHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9tb2RlbF9zbmFwc2hvdF91cGdyYWRlX3N0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZCxcbiAgICAgICAgICAgICAgICBzbmFwc2hvdF9pZDogcGFyYW1zLnNuYXBzaG90X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TW9kZWxTbmFwc2hvdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJywgJ3NuYXBzaG90X2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzYycsICdlbmQnLCAncGFnZScsICdzb3J0JywgJ3N0YXJ0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5qb2JfaWQgIT0gbnVsbCAmJiBwYXJhbXMuc25hcHNob3RfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vbW9kZWxfc25hcHNob3RzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zbmFwc2hvdF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vbW9kZWxfc25hcHNob3RzYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF9tb2RlbF9zbmFwc2hvdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkLFxuICAgICAgICAgICAgICAgIHNuYXBzaG90X2lkOiBwYXJhbXMuc25hcHNob3RfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRPdmVyYWxsQnVja2V0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbGxvd19ub19tYXRjaCcsICdidWNrZXRfc3BhbicsICdlbmQnLCAnZXhjbHVkZV9pbnRlcmltJywgJ292ZXJhbGxfc2NvcmUnLCAnc3RhcnQnLCAndG9wX24nXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9yZXN1bHRzL292ZXJhbGxfYnVja2V0c2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X292ZXJhbGxfYnVja2V0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNvcmRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2Rlc2MnLCAnZW5kJywgJ2V4Y2x1ZGVfaW50ZXJpbScsICdwYWdlJywgJ3JlY29yZF9zY29yZScsICdzb3J0JywgJ3N0YXJ0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vcmVzdWx0cy9yZWNvcmRzYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5nZXRfcmVjb3JkcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFpbmVkTW9kZWxzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5tb2RlbF9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC90cmFpbmVkX21vZGVscy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX21sL3RyYWluZWRfbW9kZWxzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLmdldF90cmFpbmVkX21vZGVscycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZDogcGFyYW1zLm1vZGVsX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhaW5lZE1vZGVsc1N0YXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5tb2RlbF9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC90cmFpbmVkX21vZGVscy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfaWQudG9TdHJpbmcoKSl9L19zdGF0c2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC90cmFpbmVkX21vZGVscy9fc3RhdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuZ2V0X3RyYWluZWRfbW9kZWxzX3N0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBpbmZlclRyYWluZWRNb2RlbChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydtb2RlbF9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RvY3MnLCAnaW5mZXJlbmNlX2NvbmZpZyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC90cmFpbmVkX21vZGVscy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubW9kZWxfaWQudG9TdHJpbmcoKSl9L19pbmZlcmA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuaW5mZXJfdHJhaW5lZF9tb2RlbCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZDogcGFyYW1zLm1vZGVsX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fbWwvaW5mbyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuaW5mbydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBvcGVuSm9iKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3RpbWVvdXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX29wZW5gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLm9wZW5fam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RDYWxlbmRhckV2ZW50cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydjYWxlbmRhcl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2V2ZW50cyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9jYWxlbmRhcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNhbGVuZGFyX2lkLnRvU3RyaW5nKCkpfS9ldmVudHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnBvc3RfY2FsZW5kYXJfZXZlbnRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyX2lkOiBwYXJhbXMuY2FsZW5kYXJfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwb3N0RGF0YShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RhdGEnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvYW5vbWFseV9kZXRlY3RvcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmpvYl9pZC50b1N0cmluZygpKX0vX2RhdGFgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnBvc3RfZGF0YScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBidWxrQm9keTogYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHJldmlld0RhdGFGcmFtZUFuYWx5dGljcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2NvbmZpZyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3ByZXZpZXdgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fbWwvZGF0YV9mcmFtZS9hbmFseXRpY3MvX3ByZXZpZXcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwucHJldmlld19kYXRhX2ZyYW1lX2FuYWx5dGljcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHJldmlld0RhdGFmZWVkKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2RhdGFmZWVkX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGF0YWZlZWRfY29uZmlnJywgJ2pvYl9jb25maWcnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5kYXRhZmVlZF9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19tbC9kYXRhZmVlZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmRhdGFmZWVkX2lkLnRvU3RyaW5nKCkpfS9fcHJldmlld2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19tbC9kYXRhZmVlZHMvX3ByZXZpZXcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwucHJldmlld19kYXRhZmVlZCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBkYXRhZmVlZF9pZDogcGFyYW1zLmRhdGFmZWVkX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0Q2FsZW5kYXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY2FsZW5kYXJfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydqb2JfaWRzJywgJ2Rlc2NyaXB0aW9uJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvY2FsZW5kYXJzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5jYWxlbmRhcl9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnB1dF9jYWxlbmRhcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhcl9pZDogcGFyYW1zLmNhbGVuZGFyX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0Q2FsZW5kYXJKb2IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY2FsZW5kYXJfaWQnLCAnam9iX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9jYWxlbmRhcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNhbGVuZGFyX2lkLnRvU3RyaW5nKCkpfS9qb2JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5wdXRfY2FsZW5kYXJfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyX2lkOiBwYXJhbXMuY2FsZW5kYXJfaWQsXG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0RGF0YUZyYW1lQW5hbHl0aWNzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWxsb3dfbGF6eV9zdGFydCcsICdhbmFseXNpcycsICdhbmFseXplZF9maWVsZHMnLCAnZGVzY3JpcHRpb24nLCAnZGVzdCcsICdtYXhfbnVtX3RocmVhZHMnLCAnbW9kZWxfbWVtb3J5X2xpbWl0JywgJ3NvdXJjZScsICdoZWFkZXJzJywgJ3ZlcnNpb24nXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9kYXRhX2ZyYW1lL2FuYWx5dGljcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5wdXRfZGF0YV9mcmFtZV9hbmFseXRpY3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dERhdGFmZWVkKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2RhdGFmZWVkX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWdncmVnYXRpb25zJywgJ2NodW5raW5nX2NvbmZpZycsICdkZWxheWVkX2RhdGFfY2hlY2tfY29uZmlnJywgJ2ZyZXF1ZW5jeScsICdpbmRpY2VzJywgJ2luZGV4ZXMnLCAnaW5kaWNlc19vcHRpb25zJywgJ2pvYl9pZCcsICdtYXhfZW1wdHlfc2VhcmNoZXMnLCAncXVlcnknLCAncXVlcnlfZGVsYXknLCAncnVudGltZV9tYXBwaW5ncycsICdzY3JpcHRfZmllbGRzJywgJ3Njcm9sbF9zaXplJywgJ2hlYWRlcnMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9kYXRhZmVlZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmRhdGFmZWVkX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwucHV0X2RhdGFmZWVkJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGRhdGFmZWVkX2lkOiBwYXJhbXMuZGF0YWZlZWRfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRGaWx0ZXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnZmlsdGVyX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzY3JpcHRpb24nLCAnaXRlbXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9maWx0ZXJzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5maWx0ZXJfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5wdXRfZmlsdGVyJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGZpbHRlcl9pZDogcGFyYW1zLmZpbHRlcl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dEpvYihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhbGxvd19sYXp5X29wZW4nLCAnYW5hbHlzaXNfY29uZmlnJywgJ2FuYWx5c2lzX2xpbWl0cycsICdiYWNrZ3JvdW5kX3BlcnNpc3RfaW50ZXJ2YWwnLCAnY3VzdG9tX3NldHRpbmdzJywgJ2RhaWx5X21vZGVsX3NuYXBzaG90X3JldGVudGlvbl9hZnRlcl9kYXlzJywgJ2RhdGFfZGVzY3JpcHRpb24nLCAnZGF0YWZlZWRfY29uZmlnJywgJ2Rlc2NyaXB0aW9uJywgJ2dyb3VwcycsICdtb2RlbF9wbG90X2NvbmZpZycsICdtb2RlbF9zbmFwc2hvdF9yZXRlbnRpb25fZGF5cycsICdyZW5vcm1hbGl6YXRpb25fd2luZG93X2RheXMnLCAncmVzdWx0c19pbmRleF9uYW1lJywgJ3Jlc3VsdHNfcmV0ZW50aW9uX2RheXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwucHV0X2pvYicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRUcmFpbmVkTW9kZWwocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbW9kZWxfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjb21wcmVzc2VkX2RlZmluaXRpb24nLCAnZGVmaW5pdGlvbicsICdkZXNjcmlwdGlvbicsICdpbmZlcmVuY2VfY29uZmlnJywgJ2lucHV0JywgJ21ldGFkYXRhJywgJ21vZGVsX3R5cGUnLCAnbW9kZWxfc2l6ZV9ieXRlcycsICdwbGF0Zm9ybV9hcmNoaXRlY3R1cmUnLCAndGFncycsICdwcmVmaXhfc3RyaW5ncyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL3RyYWluZWRfbW9kZWxzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tb2RlbF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnB1dF90cmFpbmVkX21vZGVsJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRUcmFpbmVkTW9kZWxBbGlhcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydtb2RlbF9hbGlhcycsICdtb2RlbF9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfS9tb2RlbF9hbGlhc2VzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tb2RlbF9hbGlhcy50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnB1dF90cmFpbmVkX21vZGVsX2FsaWFzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2FsaWFzOiBwYXJhbXMubW9kZWxfYWxpYXMsXG4gICAgICAgICAgICAgICAgbW9kZWxfaWQ6IHBhcmFtcy5tb2RlbF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dFRyYWluZWRNb2RlbERlZmluaXRpb25QYXJ0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJywgJ3BhcnQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkZWZpbml0aW9uJywgJ3RvdGFsX2RlZmluaXRpb25fbGVuZ3RoJywgJ3RvdGFsX3BhcnRzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfS9kZWZpbml0aW9uLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5wYXJ0LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwucHV0X3RyYWluZWRfbW9kZWxfZGVmaW5pdGlvbl9wYXJ0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWQsXG4gICAgICAgICAgICAgICAgcGFydDogcGFyYW1zLnBhcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRUcmFpbmVkTW9kZWxWb2NhYnVsYXJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsndm9jYWJ1bGFyeScsICdtZXJnZXMnLCAnc2NvcmVzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfS92b2NhYnVsYXJ5YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5wdXRfdHJhaW5lZF9tb2RlbF92b2NhYnVsYXJ5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1vZGVsX2lkOiBwYXJhbXMubW9kZWxfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXNldEpvYihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9fcmVzZXRgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnJlc2V0X2pvYicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXZlcnRNb2RlbFNuYXBzaG90KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2pvYl9pZCcsICdzbmFwc2hvdF9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RlbGV0ZV9pbnRlcnZlbmluZ19yZXN1bHRzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2Fub21hbHlfZGV0ZWN0b3JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9L21vZGVsX3NuYXBzaG90cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc25hcHNob3RfaWQudG9TdHJpbmcoKSl9L19yZXZlcnRgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnJldmVydF9tb2RlbF9zbmFwc2hvdCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWQsXG4gICAgICAgICAgICAgICAgc25hcHNob3RfaWQ6IHBhcmFtcy5zbmFwc2hvdF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFVwZ3JhZGVNb2RlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fbWwvc2V0X3VwZ3JhZGVfbW9kZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuc2V0X3VwZ3JhZGVfbW9kZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydERhdGFGcmFtZUFuYWx5dGljcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3N0YXJ0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5zdGFydF9kYXRhX2ZyYW1lX2FuYWx5dGljcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnREYXRhZmVlZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydkYXRhZmVlZF9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2VuZCcsICdzdGFydCcsICd0aW1lb3V0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2RhdGFmZWVkcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuZGF0YWZlZWRfaWQudG9TdHJpbmcoKSl9L19zdGFydGA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwuc3RhcnRfZGF0YWZlZWQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgZGF0YWZlZWRfaWQ6IHBhcmFtcy5kYXRhZmVlZF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0VHJhaW5lZE1vZGVsRGVwbG95bWVudChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydtb2RlbF9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL3RyYWluZWRfbW9kZWxzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tb2RlbF9pZC50b1N0cmluZygpKX0vZGVwbG95bWVudC9fc3RhcnRgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnN0YXJ0X3RyYWluZWRfbW9kZWxfZGVwbG95bWVudCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZDogcGFyYW1zLm1vZGVsX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcERhdGFGcmFtZUFuYWx5dGljcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3N0b3BgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnN0b3BfZGF0YV9mcmFtZV9hbmFseXRpY3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BEYXRhZmVlZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydkYXRhZmVlZF9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FsbG93X25vX21hdGNoJywgJ2ZvcmNlJywgJ3RpbWVvdXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvZGF0YWZlZWRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5kYXRhZmVlZF9pZC50b1N0cmluZygpKX0vX3N0b3BgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnN0b3BfZGF0YWZlZWQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgZGF0YWZlZWRfaWQ6IHBhcmFtcy5kYXRhZmVlZF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BUcmFpbmVkTW9kZWxEZXBsb3ltZW50KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21vZGVsX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfS9kZXBsb3ltZW50L19zdG9wYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC5zdG9wX3RyYWluZWRfbW9kZWxfZGVwbG95bWVudCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBtb2RlbF9pZDogcGFyYW1zLm1vZGVsX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlRGF0YUZyYW1lQW5hbHl0aWNzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzY3JpcHRpb24nLCAnbW9kZWxfbWVtb3J5X2xpbWl0JywgJ21heF9udW1fdGhyZWFkcycsICdhbGxvd19sYXp5X3N0YXJ0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2RhdGFfZnJhbWUvYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3VwZGF0ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwudXBkYXRlX2RhdGFfZnJhbWVfYW5hbHl0aWNzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVEYXRhZmVlZChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydkYXRhZmVlZF9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FnZ3JlZ2F0aW9ucycsICdjaHVua2luZ19jb25maWcnLCAnZGVsYXllZF9kYXRhX2NoZWNrX2NvbmZpZycsICdmcmVxdWVuY3knLCAnaW5kaWNlcycsICdpbmRleGVzJywgJ2luZGljZXNfb3B0aW9ucycsICdqb2JfaWQnLCAnbWF4X2VtcHR5X3NlYXJjaGVzJywgJ3F1ZXJ5JywgJ3F1ZXJ5X2RlbGF5JywgJ3J1bnRpbWVfbWFwcGluZ3MnLCAnc2NyaXB0X2ZpZWxkcycsICdzY3JvbGxfc2l6ZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9kYXRhZmVlZHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmRhdGFmZWVkX2lkLnRvU3RyaW5nKCkpfS9fdXBkYXRlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC51cGRhdGVfZGF0YWZlZWQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgZGF0YWZlZWRfaWQ6IHBhcmFtcy5kYXRhZmVlZF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUZpbHRlcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydmaWx0ZXJfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhZGRfaXRlbXMnLCAnZGVzY3JpcHRpb24nLCAncmVtb3ZlX2l0ZW1zJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2ZpbHRlcnMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmZpbHRlcl9pZC50b1N0cmluZygpKX0vX3VwZGF0ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwudXBkYXRlX2ZpbHRlcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJfaWQ6IHBhcmFtcy5maWx0ZXJfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVKb2IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWxsb3dfbGF6eV9vcGVuJywgJ2FuYWx5c2lzX2xpbWl0cycsICdiYWNrZ3JvdW5kX3BlcnNpc3RfaW50ZXJ2YWwnLCAnY3VzdG9tX3NldHRpbmdzJywgJ2NhdGVnb3JpemF0aW9uX2ZpbHRlcnMnLCAnZGVzY3JpcHRpb24nLCAnbW9kZWxfcGxvdF9jb25maWcnLCAnbW9kZWxfcHJ1bmVfd2luZG93JywgJ2RhaWx5X21vZGVsX3NuYXBzaG90X3JldGVudGlvbl9hZnRlcl9kYXlzJywgJ21vZGVsX3NuYXBzaG90X3JldGVudGlvbl9kYXlzJywgJ3Jlbm9ybWFsaXphdGlvbl93aW5kb3dfZGF5cycsICdyZXN1bHRzX3JldGVudGlvbl9kYXlzJywgJ2dyb3VwcycsICdkZXRlY3RvcnMnLCAncGVyX3BhcnRpdGlvbl9jYXRlZ29yaXphdGlvbiddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9fdXBkYXRlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC51cGRhdGVfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGpvYl9pZDogcGFyYW1zLmpvYl9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZU1vZGVsU25hcHNob3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnam9iX2lkJywgJ3NuYXBzaG90X2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzY3JpcHRpb24nLCAncmV0YWluJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX21sL2Fub21hbHlfZGV0ZWN0b3JzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5qb2JfaWQudG9TdHJpbmcoKSl9L21vZGVsX3NuYXBzaG90cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc25hcHNob3RfaWQudG9TdHJpbmcoKSl9L191cGRhdGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnVwZGF0ZV9tb2RlbF9zbmFwc2hvdCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBqb2JfaWQ6IHBhcmFtcy5qb2JfaWQsXG4gICAgICAgICAgICAgICAgc25hcHNob3RfaWQ6IHBhcmFtcy5zbmFwc2hvdF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVRyYWluZWRNb2RlbERlcGxveW1lbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbW9kZWxfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydudW1iZXJfb2ZfYWxsb2NhdGlvbnMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbWwvdHJhaW5lZF9tb2RlbHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1vZGVsX2lkLnRvU3RyaW5nKCkpfS9kZXBsb3ltZW50L191cGRhdGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ21sLnVwZGF0ZV90cmFpbmVkX21vZGVsX2RlcGxveW1lbnQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbW9kZWxfaWQ6IHBhcmFtcy5tb2RlbF9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZ3JhZGVKb2JTbmFwc2hvdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydqb2JfaWQnLCAnc25hcHNob3RfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19tbC9hbm9tYWx5X2RldGVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuam9iX2lkLnRvU3RyaW5nKCkpfS9tb2RlbF9zbmFwc2hvdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90X2lkLnRvU3RyaW5nKCkpfS9fdXBncmFkZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwudXBncmFkZV9qb2Jfc25hcHNob3QnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgam9iX2lkOiBwYXJhbXMuam9iX2lkLFxuICAgICAgICAgICAgICAgIHNuYXBzaG90X2lkOiBwYXJhbXMuc25hcHNob3RfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnam9iX2lkJywgJ2FuYWx5c2lzX2NvbmZpZycsICdhbmFseXNpc19saW1pdHMnLCAnZGF0YV9kZXNjcmlwdGlvbicsICdkZXNjcmlwdGlvbicsICdtb2RlbF9wbG90JywgJ21vZGVsX3NuYXBzaG90X2lkJywgJ21vZGVsX3NuYXBzaG90X3JldGVudGlvbl9kYXlzJywgJ3Jlc3VsdHNfaW5kZXhfbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fbWwvYW5vbWFseV9kZXRlY3RvcnMvX3ZhbGlkYXRlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdtbC52YWxpZGF0ZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZURldGVjdG9yKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RldGVjdG9yJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX21sL2Fub21hbHlfZGV0ZWN0b3JzL192YWxpZGF0ZS9kZXRlY3Rvcic7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbWwudmFsaWRhdGVfZGV0ZWN0b3InXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1sLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ml.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Monitoring {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async bulk(params, options) {\n        var _a;\n        const acceptedPath = ['type'];\n        const acceptedBody = ['operations'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_monitoring/bulk';\n        const meta = {\n            name: 'monitoring.bulk',\n            pathParts: {\n                type: params.type\n            }\n        };\n        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n    }\n}\nexports[\"default\"] = Monitoring;\n//# sourceMappingURL=monitoring.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tb25pdG9yaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlEQUFpRDtBQUMvRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvbW9uaXRvcmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTW9uaXRvcmluZyB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgYnVsayhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3R5cGUnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydvcGVyYXRpb25zJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX21vbml0b3JpbmcvYnVsayc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbW9uaXRvcmluZy5idWxrJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtcy50eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYnVsa0JvZHk6IGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTW9uaXRvcmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbml0b3JpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/msearch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function MsearchApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['searches'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_msearch`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_msearch';\n    }\n    const meta = {\n        name: 'msearch',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n}\nexports[\"default\"] = MsearchApi;\n//# sourceMappingURL=msearch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tc2VhcmNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFpRDtBQUMzRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL21zZWFyY2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIE1zZWFyY2hBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3NlYXJjaGVzJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX21zZWFyY2hgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSAnL19tc2VhcmNoJztcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ21zZWFyY2gnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBidWxrQm9keTogYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE1zZWFyY2hBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2VhcmNoLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function MsearchTemplateApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['search_templates'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_msearch/template`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_msearch/template';\n    }\n    const meta = {\n        name: 'msearch_template',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n}\nexports[\"default\"] = MsearchTemplateApi;\n//# sourceMappingURL=msearch_template.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tc2VhcmNoX3RlbXBsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGlEQUFpRDtBQUMzRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL21zZWFyY2hfdGVtcGxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIE1zZWFyY2hUZW1wbGF0ZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc2VhcmNoX3RlbXBsYXRlcyddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGxldCBib2R5ID0gKF9hID0gcGFyYW1zLmJvZHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19tc2VhcmNoL3RlbXBsYXRlYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gJy9fbXNlYXJjaC90ZW1wbGF0ZSc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdtc2VhcmNoX3RlbXBsYXRlJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYnVsa0JvZHk6IGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNc2VhcmNoVGVtcGxhdGVBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2VhcmNoX3RlbXBsYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function MtermvectorsApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['docs', 'ids'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_mtermvectors`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_mtermvectors';\n    }\n    const meta = {\n        name: 'mtermvectors',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = MtermvectorsApi;\n//# sourceMappingURL=mtermvectors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tdGVybXZlY3RvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9tdGVybXZlY3RvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIE10ZXJtdmVjdG9yc0FwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydkb2NzJywgJ2lkcyddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fbXRlcm12ZWN0b3JzYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gJy9fbXRlcm12ZWN0b3JzJztcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ210ZXJtdmVjdG9ycycsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBNdGVybXZlY3RvcnNBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdGVybXZlY3RvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/nodes.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/nodes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Nodes {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async clearRepositoriesMeteringArchive(params, options) {\n        const acceptedPath = ['node_id', 'max_archive_version'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering/${encodeURIComponent(params.max_archive_version.toString())}`;\n        const meta = {\n            name: 'nodes.clear_repositories_metering_archive',\n            pathParts: {\n                node_id: params.node_id,\n                max_archive_version: params.max_archive_version\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRepositoriesMeteringInfo(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering`;\n        const meta = {\n            name: 'nodes.get_repositories_metering_info',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async hotThreads(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/hot_threads`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/hot_threads';\n        }\n        const meta = {\n            name: 'nodes.hot_threads',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async info(params, options) {\n        const acceptedPath = ['node_id', 'metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes';\n        }\n        const meta = {\n            name: 'nodes.info',\n            pathParts: {\n                node_id: params.node_id,\n                metric: params.metric\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async reloadSecureSettings(params, options) {\n        const acceptedPath = ['node_id'];\n        const acceptedBody = ['secure_settings_password'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'POST';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/reload_secure_settings`;\n        }\n        else {\n            method = 'POST';\n            path = '/_nodes/reload_secure_settings';\n        }\n        const meta = {\n            name: 'nodes.reload_secure_settings',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['node_id', 'metric', 'index_metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null && params.index_metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;\n        }\n        else if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.metric != null && params.index_metric != null) {\n            method = 'GET';\n            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/stats';\n        }\n        const meta = {\n            name: 'nodes.stats',\n            pathParts: {\n                node_id: params.node_id,\n                metric: params.metric,\n                index_metric: params.index_metric\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async usage(params, options) {\n        const acceptedPath = ['node_id', 'metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/usage/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/usage';\n        }\n        const meta = {\n            name: 'nodes.usage',\n            pathParts: {\n                node_id: params.node_id,\n                metric: params.metric\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Nodes;\n//# sourceMappingURL=nodes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9ub2Rlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhDQUE4QywwQkFBMEIsMERBQTBEO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOENBQThDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQThDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QyxHQUFHLDZDQUE2QztBQUM1SDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQThDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEMsU0FBUyw2Q0FBNkMsR0FBRyxtREFBbUQ7QUFDeEw7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QyxTQUFTLDZDQUE2QztBQUNsSTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkNBQTZDLEdBQUcsbURBQW1EO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZDQUE2QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQThDLFNBQVMsNkNBQTZDO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZDQUE2QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9ub2Rlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTm9kZXMge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFyUmVwb3NpdG9yaWVzTWV0ZXJpbmdBcmNoaXZlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25vZGVfaWQnLCAnbWF4X2FyY2hpdmVfdmVyc2lvbiddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbm9kZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5vZGVfaWQudG9TdHJpbmcoKSl9L19yZXBvc2l0b3JpZXNfbWV0ZXJpbmcvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1heF9hcmNoaXZlX3ZlcnNpb24udG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdub2Rlcy5jbGVhcl9yZXBvc2l0b3JpZXNfbWV0ZXJpbmdfYXJjaGl2ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZCxcbiAgICAgICAgICAgICAgICBtYXhfYXJjaGl2ZV92ZXJzaW9uOiBwYXJhbXMubWF4X2FyY2hpdmVfdmVyc2lvblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlcG9zaXRvcmllc01ldGVyaW5nSW5mbyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19ub2Rlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vX3JlcG9zaXRvcmllc19tZXRlcmluZ2A7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbm9kZXMuZ2V0X3JlcG9zaXRvcmllc19tZXRlcmluZ19pbmZvJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5vZGVfaWQ6IHBhcmFtcy5ub2RlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgaG90VGhyZWFkcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfS9ob3RfdGhyZWFkc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19ub2Rlcy9ob3RfdGhyZWFkcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdub2Rlcy5ob3RfdGhyZWFkcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGluZm8ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbm9kZV9pZCcsICdtZXRyaWMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVfaWQgIT0gbnVsbCAmJiBwYXJhbXMubWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubWV0cmljLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm5vZGVfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbm9kZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5vZGVfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tZXRyaWMudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX25vZGVzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ25vZGVzLmluZm8nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWQsXG4gICAgICAgICAgICAgICAgbWV0cmljOiBwYXJhbXMubWV0cmljXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVsb2FkU2VjdXJlU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbm9kZV9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3NlY3VyZV9zZXR0aW5nc19wYXNzd29yZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfS9yZWxvYWRfc2VjdXJlX3NldHRpbmdzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19ub2Rlcy9yZWxvYWRfc2VjdXJlX3NldHRpbmdzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ25vZGVzLnJlbG9hZF9zZWN1cmVfc2V0dGluZ3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJywgJ21ldHJpYycsICdpbmRleF9tZXRyaWMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVfaWQgIT0gbnVsbCAmJiBwYXJhbXMubWV0cmljICE9IG51bGwgJiYgcGFyYW1zLmluZGV4X21ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19ub2Rlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vc3RhdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4X21ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwgJiYgcGFyYW1zLm1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19ub2Rlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vc3RhdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5tZXRyaWMgIT0gbnVsbCAmJiBwYXJhbXMuaW5kZXhfbWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzL3N0YXRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5tZXRyaWMudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleF9tZXRyaWMudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubm9kZV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19ub2Rlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vc3RhdHNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5tZXRyaWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbm9kZXMvc3RhdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fbm9kZXMvc3RhdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnbm9kZXMuc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWQsXG4gICAgICAgICAgICAgICAgbWV0cmljOiBwYXJhbXMubWV0cmljLFxuICAgICAgICAgICAgICAgIGluZGV4X21ldHJpYzogcGFyYW1zLmluZGV4X21ldHJpY1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVzYWdlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25vZGVfaWQnLCAnbWV0cmljJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwgJiYgcGFyYW1zLm1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19ub2Rlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vdXNhZ2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ub2RlX2lkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfS91c2FnZWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm1ldHJpYyAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19ub2Rlcy91c2FnZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubWV0cmljLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19ub2Rlcy91c2FnZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdub2Rlcy51c2FnZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZCxcbiAgICAgICAgICAgICAgICBtZXRyaWM6IHBhcmFtcy5tZXRyaWNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE5vZGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/nodes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function OpenPointInTimeApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['index_filter'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_pit`;\n    const meta = {\n        name: 'open_point_in_time',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = OpenPointInTimeApi;\n//# sourceMappingURL=open_point_in_time.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9vcGVuX3BvaW50X2luX3RpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9vcGVuX3BvaW50X2luX3RpbWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIE9wZW5Qb2ludEluVGltZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydpbmRleF9maWx0ZXInXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fcGl0YDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnb3Blbl9wb2ludF9pbl90aW1lJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IE9wZW5Qb2ludEluVGltZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW5fcG9pbnRfaW5fdGltZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ping.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ping.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function PingApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = '/';\n    const meta = {\n        name: 'ping'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = PingApi;\n//# sourceMappingURL=ping.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9waW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcGluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gUGluZ0FwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnSEVBRCc7XG4gICAgY29uc3QgcGF0aCA9ICcvJztcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAncGluZydcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBpbmdBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ping.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/profiling.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/profiling.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Profiling {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async flamegraph(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_profiling/flamegraph';\n        const meta = {\n            name: 'profiling.flamegraph'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stacktraces(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_profiling/stacktraces';\n        const meta = {\n            name: 'profiling.stacktraces'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async status(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_profiling/status';\n        const meta = {\n            name: 'profiling.status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async topnFunctions(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_profiling/topn/functions';\n        const meta = {\n            name: 'profiling.topn_functions'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Profiling;\n//# sourceMappingURL=profiling.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9wcm9maWxpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcHJvZmlsaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBQcm9maWxpbmcge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGZsYW1lZ3JhcGgocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3Byb2ZpbGluZy9mbGFtZWdyYXBoJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdwcm9maWxpbmcuZmxhbWVncmFwaCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGFja3RyYWNlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fcHJvZmlsaW5nL3N0YWNrdHJhY2VzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdwcm9maWxpbmcuc3RhY2t0cmFjZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhdHVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3Byb2ZpbGluZy9zdGF0dXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3Byb2ZpbGluZy5zdGF0dXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdG9wbkZ1bmN0aW9ucyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fcHJvZmlsaW5nL3RvcG4vZnVuY3Rpb25zJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdwcm9maWxpbmcudG9wbl9mdW5jdGlvbnMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQcm9maWxpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9maWxpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/profiling.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/put_script.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/put_script.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function PutScriptApi(params, options) {\n    const acceptedPath = ['id', 'context'];\n    const acceptedBody = ['script'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.id != null && params.context != null) {\n        method = 'PUT';\n        path = `/_scripts/${encodeURIComponent(params.id.toString())}/${encodeURIComponent(params.context.toString())}`;\n    }\n    else {\n        method = 'PUT';\n        path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    }\n    const meta = {\n        name: 'put_script',\n        pathParts: {\n            id: params.id,\n            context: params.context\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = PutScriptApi;\n//# sourceMappingURL=put_script.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9wdXRfc2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlDQUF5QyxHQUFHLDhDQUE4QztBQUN0SDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseUNBQXlDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcHV0X3NjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gUHV0U2NyaXB0QXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnLCAnY29udGV4dCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc2NyaXB0J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsICYmIHBhcmFtcy5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIHBhdGggPSBgL19zY3JpcHRzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbnRleHQudG9TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBwYXRoID0gYC9fc2NyaXB0cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3B1dF9zY3JpcHQnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBjb250ZXh0OiBwYXJhbXMuY29udGV4dFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQdXRTY3JpcHRBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXRfc2NyaXB0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/put_script.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js":
/*!************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass QueryRules {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteRule(params, options) {\n        const acceptedPath = ['ruleset_id', 'rule_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'query_rules.delete_rule',\n            pathParts: {\n                ruleset_id: params.ruleset_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteRuleset(params, options) {\n        const acceptedPath = ['ruleset_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;\n        const meta = {\n            name: 'query_rules.delete_ruleset',\n            pathParts: {\n                ruleset_id: params.ruleset_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRule(params, options) {\n        const acceptedPath = ['ruleset_id', 'rule_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'query_rules.get_rule',\n            pathParts: {\n                ruleset_id: params.ruleset_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRuleset(params, options) {\n        const acceptedPath = ['ruleset_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;\n        const meta = {\n            name: 'query_rules.get_ruleset',\n            pathParts: {\n                ruleset_id: params.ruleset_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async listRulesets(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_query_rules';\n        const meta = {\n            name: 'query_rules.list_rulesets'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putRule(params, options) {\n        const acceptedPath = ['ruleset_id', 'rule_id'];\n        const acceptedBody = ['type', 'criteria', 'actions', 'priority'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_rule/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'query_rules.put_rule',\n            pathParts: {\n                ruleset_id: params.ruleset_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putRuleset(params, options) {\n        const acceptedPath = ['ruleset_id'];\n        const acceptedBody = ['rules'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}`;\n        const meta = {\n            name: 'query_rules.put_ruleset',\n            pathParts: {\n                ruleset_id: params.ruleset_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async test(params, options) {\n        const acceptedPath = ['ruleset_id'];\n        const acceptedBody = ['match_criteria'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_query_rules/${encodeURIComponent(params.ruleset_id.toString())}/_test`;\n        const meta = {\n            name: 'query_rules.test',\n            pathParts: {\n                ruleset_id: params.ruleset_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = QueryRules;\n//# sourceMappingURL=query_rules.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9xdWVyeV9ydWxlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRCxTQUFTLDhDQUE4QztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQsU0FBUyw4Q0FBOEM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpREFBaUQsU0FBUyw4Q0FBOEM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlEQUFpRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9xdWVyeV9ydWxlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgUXVlcnlSdWxlcyB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUnVsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJywgJ3J1bGVfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3F1ZXJ5X3J1bGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ydWxlc2V0X2lkLnRvU3RyaW5nKCkpfS9fcnVsZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLmRlbGV0ZV9ydWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkLFxuICAgICAgICAgICAgICAgIHJ1bGVfaWQ6IHBhcmFtcy5ydWxlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUnVsZXNldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19xdWVyeV9ydWxlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZXNldF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLmRlbGV0ZV9ydWxlc2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJywgJ3J1bGVfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3F1ZXJ5X3J1bGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ydWxlc2V0X2lkLnRvU3RyaW5nKCkpfS9fcnVsZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLmdldF9ydWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkLFxuICAgICAgICAgICAgICAgIHJ1bGVfaWQ6IHBhcmFtcy5ydWxlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVsZXNldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19xdWVyeV9ydWxlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZXNldF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLmdldF9ydWxlc2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdFJ1bGVzZXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19xdWVyeV9ydWxlcyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAncXVlcnlfcnVsZXMubGlzdF9ydWxlc2V0cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRSdWxlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3J1bGVzZXRfaWQnLCAncnVsZV9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3R5cGUnLCAnY3JpdGVyaWEnLCAnYWN0aW9ucycsICdwcmlvcml0eSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3F1ZXJ5X3J1bGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ydWxlc2V0X2lkLnRvU3RyaW5nKCkpfS9fcnVsZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLnB1dF9ydWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkLFxuICAgICAgICAgICAgICAgIHJ1bGVfaWQ6IHBhcmFtcy5ydWxlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0UnVsZXNldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsncnVsZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19xdWVyeV9ydWxlcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucnVsZXNldF9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5X3J1bGVzLnB1dF9ydWxlc2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdGVzdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydydWxlc2V0X2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbWF0Y2hfY3JpdGVyaWEnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fcXVlcnlfcnVsZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJ1bGVzZXRfaWQudG9TdHJpbmcoKSl9L190ZXN0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdxdWVyeV9ydWxlcy50ZXN0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJ1bGVzZXRfaWQ6IHBhcmFtcy5ydWxlc2V0X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBRdWVyeVJ1bGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVlcnlfcnVsZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function RankEvalApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['requests', 'metric'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_rank_eval`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_rank_eval';\n    }\n    const meta = {\n        name: 'rank_eval',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = RankEvalApi;\n//# sourceMappingURL=rank_eval.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yYW5rX2V2YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcmFua19ldmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBSYW5rRXZhbEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyZXF1ZXN0cycsICdtZXRyaWMnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgbGV0IHBhdGggPSAnJztcbiAgICBpZiAocGFyYW1zLmluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3JhbmtfZXZhbGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9ICcvX3JhbmtfZXZhbCc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdyYW5rX2V2YWwnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmFua0V2YWxBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5rX2V2YWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/reindex.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ReindexApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['conflicts', 'dest', 'max_docs', 'script', 'size', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = '/_reindex';\n    const meta = {\n        name: 'reindex'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ReindexApi;\n//# sourceMappingURL=reindex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yZWluZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcmVpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gUmVpbmRleEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2NvbmZsaWN0cycsICdkZXN0JywgJ21heF9kb2NzJywgJ3NjcmlwdCcsICdzaXplJywgJ3NvdXJjZSddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCBwYXRoID0gJy9fcmVpbmRleCc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3JlaW5kZXgnXG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZWluZGV4QXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVpbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ReindexRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_reindex/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    const meta = {\n        name: 'reindex_rethrottle',\n        pathParts: {\n            task_id: params.task_id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ReindexRethrottleApi;\n//# sourceMappingURL=reindex_rethrottle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yZWluZGV4X3JldGhyb3R0bGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcmVpbmRleF9yZXRocm90dGxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBSZWluZGV4UmV0aHJvdHRsZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3Rhc2tfaWQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvX3JlaW5kZXgvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhc2tfaWQudG9TdHJpbmcoKSl9L19yZXRocm90dGxlYDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAncmVpbmRleF9yZXRocm90dGxlJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICB0YXNrX2lkOiBwYXJhbXMudGFza19pZFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZWluZGV4UmV0aHJvdHRsZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlaW5kZXhfcmV0aHJvdHRsZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function RenderSearchTemplateApi(params, options) {\n    const acceptedPath = ['id'];\n    const acceptedBody = ['file', 'params', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.id != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/_render/template/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_render/template';\n    }\n    const meta = {\n        name: 'render_search_template',\n        pathParts: {\n            id: params.id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = RenderSearchTemplateApi;\n//# sourceMappingURL=render_search_template.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yZW5kZXJfc2VhcmNoX3RlbXBsYXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQXlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvcmVuZGVyX3NlYXJjaF90ZW1wbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gUmVuZGVyU2VhcmNoVGVtcGxhdGVBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZmlsZScsICdwYXJhbXMnLCAnc291cmNlJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC9fcmVuZGVyL3RlbXBsYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSAnL19yZW5kZXIvdGVtcGxhdGUnO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAncmVuZGVyX3NlYXJjaF90ZW1wbGF0ZScsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBSZW5kZXJTZWFyY2hUZW1wbGF0ZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcl9zZWFyY2hfdGVtcGxhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rollup.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/rollup.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Rollup {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'rollup.delete_job',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getJobs(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_rollup/job';\n        }\n        const meta = {\n            name: 'rollup.get_jobs',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRollupCaps(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_rollup/data/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_rollup/data';\n        }\n        const meta = {\n            name: 'rollup.get_rollup_caps',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRollupIndexCaps(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_rollup/data`;\n        const meta = {\n            name: 'rollup.get_rollup_index_caps',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putJob(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['cron', 'groups', 'index_pattern', 'metrics', 'page_size', 'rollup_index', 'timeout', 'headers'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'rollup.put_job',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async rollupSearch(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'query', 'size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_rollup_search`;\n        const meta = {\n            name: 'rollup.rollup_search',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async startJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_start`;\n        const meta = {\n            name: 'rollup.start_job',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stopJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_stop`;\n        const meta = {\n            name: 'rollup.stop_job',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Rollup;\n//# sourceMappingURL=rollup.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yb2xsdXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5Q0FBeUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQXlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5Q0FBeUM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0Q0FBNEM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlDQUF5QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9yb2xsdXAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFJvbGx1cCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlSm9iKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19yb2xsdXAvam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3JvbGx1cC5kZWxldGVfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRKb2JzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19yb2xsdXAvam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fcm9sbHVwL2pvYic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdyb2xsdXAuZ2V0X2pvYnMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJvbGx1cENhcHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX3JvbGx1cC9kYXRhLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fcm9sbHVwL2RhdGEnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAncm9sbHVwLmdldF9yb2xsdXBfY2FwcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Um9sbHVwSW5kZXhDYXBzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3JvbGx1cC9kYXRhYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdyb2xsdXAuZ2V0X3JvbGx1cF9pbmRleF9jYXBzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRKb2IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjcm9uJywgJ2dyb3VwcycsICdpbmRleF9wYXR0ZXJuJywgJ21ldHJpY3MnLCAncGFnZV9zaXplJywgJ3JvbGx1cF9pbmRleCcsICd0aW1lb3V0JywgJ2hlYWRlcnMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19yb2xsdXAvam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3JvbGx1cC5wdXRfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByb2xsdXBTZWFyY2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhZ2dyZWdhdGlvbnMnLCAnYWdncycsICdxdWVyeScsICdzaXplJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19yb2xsdXBfc2VhcmNoYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdyb2xsdXAucm9sbHVwX3NlYXJjaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RhcnRKb2IocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19yb2xsdXAvam9iLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX3N0YXJ0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdyb2xsdXAuc3RhcnRfam9iJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wSm9iKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fcm9sbHVwL2pvYi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9L19zdG9wYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdyb2xsdXAuc3RvcF9qb2InLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUm9sbHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9sbHVwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rollup.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ScriptsPainlessExecuteApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['context', 'context_setup', 'script'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = '/_scripts/painless/_execute';\n    const meta = {\n        name: 'scripts_painless_execute'\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ScriptsPainlessExecuteApi;\n//# sourceMappingURL=scripts_painless_execute.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zY3JpcHRzX3BhaW5sZXNzX2V4ZWN1dGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3NjcmlwdHNfcGFpbmxlc3NfZXhlY3V0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gU2NyaXB0c1BhaW5sZXNzRXhlY3V0ZUFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2NvbnRleHQnLCAnY29udGV4dF9zZXR1cCcsICdzY3JpcHQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gJy9fc2NyaXB0cy9wYWlubGVzcy9fZXhlY3V0ZSc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3NjcmlwdHNfcGFpbmxlc3NfZXhlY3V0ZSdcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcmlwdHNQYWlubGVzc0V4ZWN1dGVBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JpcHRzX3BhaW5sZXNzX2V4ZWN1dGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scroll.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/scroll.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function ScrollApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['scroll', 'scroll_id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = '/_search/scroll';\n    const meta = {\n        name: 'scroll',\n        pathParts: {\n            scroll_id: params.scroll_id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = ScrollApi;\n//# sourceMappingURL=scroll.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zY3JvbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zY3JvbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIFNjcm9sbEFwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3Njcm9sbCcsICdzY3JvbGxfaWQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gJy9fc2VhcmNoL3Njcm9sbCc7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3Njcm9sbCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgc2Nyb2xsX2lkOiBwYXJhbXMuc2Nyb2xsX2lkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjcm9sbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scroll.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/search.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function SearchApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'ext', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'knn', 'rank', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'retriever', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) { // eslint-disable-line\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n            else {\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search';\n    }\n    const meta = {\n        name: 'search',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = SearchApi;\n//# sourceMappingURL=search.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvc2VhcmNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBTZWFyY2hBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWdncmVnYXRpb25zJywgJ2FnZ3MnLCAnY29sbGFwc2UnLCAnZXhwbGFpbicsICdleHQnLCAnZnJvbScsICdoaWdobGlnaHQnLCAndHJhY2tfdG90YWxfaGl0cycsICdpbmRpY2VzX2Jvb3N0JywgJ2RvY3ZhbHVlX2ZpZWxkcycsICdrbm4nLCAncmFuaycsICdtaW5fc2NvcmUnLCAncG9zdF9maWx0ZXInLCAncHJvZmlsZScsICdxdWVyeScsICdyZXNjb3JlJywgJ3JldHJpZXZlcicsICdzY3JpcHRfZmllbGRzJywgJ3NlYXJjaF9hZnRlcicsICdzaXplJywgJ3NsaWNlJywgJ3NvcnQnLCAnX3NvdXJjZScsICdmaWVsZHMnLCAnc3VnZ2VzdCcsICd0ZXJtaW5hdGVfYWZ0ZXInLCAndGltZW91dCcsICd0cmFja19zY29yZXMnLCAndmVyc2lvbicsICdzZXFfbm9fcHJpbWFyeV90ZXJtJywgJ3N0b3JlZF9maWVsZHMnLCAncGl0JywgJ3J1bnRpbWVfbWFwcGluZ3MnLCAnc3RhdHMnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnc29ydCcgJiYgdHlwZW9mIHBhcmFtc1trZXldID09PSAnc3RyaW5nJyAmJiBwYXJhbXNba2V5XS5pbmNsdWRlcygnOicpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBtZXRob2QgPSAnJztcbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fc2VhcmNoYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gJy9fc2VhcmNoJztcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3NlYXJjaCcsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZWFyY2hBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_application.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/search_application.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass SearchApplication {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'search_application.delete',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteBehavioralAnalytics(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'search_application.delete_behavioral_analytics',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'search_application.get',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getBehavioralAnalytics(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_application/analytics';\n        }\n        const meta = {\n            name: 'search_application.get_behavioral_analytics',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async list(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_application/search_application';\n        const meta = {\n            name: 'search_application.list'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async postBehavioralAnalyticsEvent(params, options) {\n        const acceptedPath = ['collection_name', 'event_type'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_application/analytics/${encodeURIComponent(params.collection_name.toString())}/event/${encodeURIComponent(params.event_type.toString())}`;\n        const meta = {\n            name: 'search_application.post_behavioral_analytics_event',\n            pathParts: {\n                collection_name: params.collection_name,\n                event_type: params.event_type\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async put(params, options) {\n        var _a;\n        const acceptedPath = ['name'];\n        const acceptedBody = ['search_application'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'search_application.put',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putBehavioralAnalytics(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_application/analytics/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'search_application.put_behavioral_analytics',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async renderQuery(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_render_query`;\n        const meta = {\n            name: 'search_application.render_query',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async search(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['params'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_application/search_application/${encodeURIComponent(params.name.toString())}/_search`;\n        const meta = {\n            name: 'search_application.search',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = SearchApplication;\n//# sourceMappingURL=search_application.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfYXBwbGljYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDJDQUEyQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDJDQUEyQztBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0RBQXNELFNBQVMsaURBQWlEO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDJDQUEyQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDJDQUEyQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfYXBwbGljYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNlYXJjaEFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fYXBwbGljYXRpb24vc2VhcmNoX2FwcGxpY2F0aW9uLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoX2FwcGxpY2F0aW9uLmRlbGV0ZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUJlaGF2aW9yYWxBbmFseXRpY3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fYXBwbGljYXRpb24vYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoX2FwcGxpY2F0aW9uLmRlbGV0ZV9iZWhhdmlvcmFsX2FuYWx5dGljcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hcHBsaWNhdGlvbi9zZWFyY2hfYXBwbGljYXRpb24vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2hfYXBwbGljYXRpb24uZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QmVoYXZpb3JhbEFuYWx5dGljcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX2FwcGxpY2F0aW9uL2FuYWx5dGljcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fYXBwbGljYXRpb24vYW5hbHl0aWNzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlYXJjaF9hcHBsaWNhdGlvbi5nZXRfYmVoYXZpb3JhbF9hbmFseXRpY3MnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBsaXN0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19hcHBsaWNhdGlvbi9zZWFyY2hfYXBwbGljYXRpb24nO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlYXJjaF9hcHBsaWNhdGlvbi5saXN0J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHBvc3RCZWhhdmlvcmFsQW5hbHl0aWNzRXZlbnQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnY29sbGVjdGlvbl9uYW1lJywgJ2V2ZW50X3R5cGUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hcHBsaWNhdGlvbi9hbmFseXRpY3MvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmNvbGxlY3Rpb25fbmFtZS50b1N0cmluZygpKX0vZXZlbnQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmV2ZW50X3R5cGUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2hfYXBwbGljYXRpb24ucG9zdF9iZWhhdmlvcmFsX2FuYWx5dGljc19ldmVudCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uX25hbWU6IHBhcmFtcy5jb2xsZWN0aW9uX25hbWUsXG4gICAgICAgICAgICAgICAgZXZlbnRfdHlwZTogcGFyYW1zLmV2ZW50X3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnc2VhcmNoX2FwcGxpY2F0aW9uJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbGV0IGJvZHkgPSAoX2EgPSBwYXJhbXMuYm9keSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5ID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fYXBwbGljYXRpb24vc2VhcmNoX2FwcGxpY2F0aW9uLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoX2FwcGxpY2F0aW9uLnB1dCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dEJlaGF2aW9yYWxBbmFseXRpY3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fYXBwbGljYXRpb24vYW5hbHl0aWNzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoX2FwcGxpY2F0aW9uLnB1dF9iZWhhdmlvcmFsX2FuYWx5dGljcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlbmRlclF1ZXJ5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19hcHBsaWNhdGlvbi9zZWFyY2hfYXBwbGljYXRpb24vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9L19yZW5kZXJfcXVlcnlgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlYXJjaF9hcHBsaWNhdGlvbi5yZW5kZXJfcXVlcnknLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzZWFyY2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3BhcmFtcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX2FwcGxpY2F0aW9uL3NlYXJjaF9hcHBsaWNhdGlvbi8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vX3NlYXJjaGA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoX2FwcGxpY2F0aW9uLnNlYXJjaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2VhcmNoQXBwbGljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWFyY2hfYXBwbGljYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_application.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function SearchMvtApi(params, options) {\n    const acceptedPath = ['index', 'field', 'zoom', 'x', 'y'];\n    const acceptedBody = ['aggs', 'buffer', 'exact_bounds', 'extent', 'fields', 'grid_agg', 'grid_precision', 'grid_type', 'query', 'runtime_mappings', 'size', 'sort', 'track_total_hits', 'with_labels'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_mvt/${encodeURIComponent(params.field.toString())}/${encodeURIComponent(params.zoom.toString())}/${encodeURIComponent(params.x.toString())}/${encodeURIComponent(params.y.toString())}`;\n    const meta = {\n        name: 'search_mvt',\n        pathParts: {\n            index: params.index,\n            field: params.field,\n            zoom: params.zoom,\n            x: params.x,\n            y: params.y\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = SearchMvtApi;\n//# sourceMappingURL=search_mvt.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfbXZ0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QyxRQUFRLDRDQUE0QyxHQUFHLDJDQUEyQyxHQUFHLHdDQUF3QyxHQUFHLHdDQUF3QztBQUN6UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfbXZ0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5hc3luYyBmdW5jdGlvbiBTZWFyY2hNdnRBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCcsICdmaWVsZCcsICd6b29tJywgJ3gnLCAneSddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWdncycsICdidWZmZXInLCAnZXhhY3RfYm91bmRzJywgJ2V4dGVudCcsICdmaWVsZHMnLCAnZ3JpZF9hZ2cnLCAnZ3JpZF9wcmVjaXNpb24nLCAnZ3JpZF90eXBlJywgJ3F1ZXJ5JywgJ3J1bnRpbWVfbWFwcGluZ3MnLCAnc2l6ZScsICdzb3J0JywgJ3RyYWNrX3RvdGFsX2hpdHMnLCAnd2l0aF9sYWJlbHMnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19tdnQvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmZpZWxkLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuem9vbS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLngudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy55LnRvU3RyaW5nKCkpfWA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3NlYXJjaF9tdnQnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXgsXG4gICAgICAgICAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgICAgICAgICAgem9vbTogcGFyYW1zLnpvb20sXG4gICAgICAgICAgICB4OiBwYXJhbXMueCxcbiAgICAgICAgICAgIHk6IHBhcmFtcy55XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlYXJjaE12dEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaF9tdnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function SearchShardsApi(params, options) {\n    const acceptedPath = ['index'];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search_shards`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search_shards';\n    }\n    const meta = {\n        name: 'search_shards',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = SearchShardsApi;\n//# sourceMappingURL=search_shards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfc2hhcmRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUE0QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3NlYXJjaF9zaGFyZHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIFNlYXJjaFNoYXJkc0FwaShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zZWFyY2hfc2hhcmRzYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gJy9fc2VhcmNoX3NoYXJkcyc7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICdzZWFyY2hfc2hhcmRzJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlYXJjaFNoYXJkc0FwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlYXJjaF9zaGFyZHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_template.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/search_template.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function SearchTemplateApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['explain', 'id', 'params', 'profile', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search/template`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search/template';\n    }\n    const meta = {\n        name: 'search_template',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = SearchTemplateApi;\n//# sourceMappingURL=search_template.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfdGVtcGxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hfdGVtcGxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIFNlYXJjaFRlbXBsYXRlQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2V4cGxhaW4nLCAnaWQnLCAncGFyYW1zJywgJ3Byb2ZpbGUnLCAnc291cmNlJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zZWFyY2gvdGVtcGxhdGVgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIHBhdGggPSAnL19zZWFyY2gvdGVtcGxhdGUnO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAnc2VhcmNoX3RlbXBsYXRlJyxcbiAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlYXJjaFRlbXBsYXRlQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoX3RlbXBsYXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_template.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass SearchableSnapshots {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cacheStats(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_searchable_snapshots/${encodeURIComponent(params.node_id.toString())}/cache/stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_searchable_snapshots/cache/stats';\n        }\n        const meta = {\n            name: 'searchable_snapshots.cache_stats',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCache(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/cache/clear`;\n        }\n        else {\n            method = 'POST';\n            path = '/_searchable_snapshots/cache/clear';\n        }\n        const meta = {\n            name: 'searchable_snapshots.clear_cache',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async mount(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['index', 'renamed_index', 'index_settings', 'ignore_index_settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_mount`;\n        const meta = {\n            name: 'searchable_snapshots.mount',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_searchable_snapshots/stats';\n        }\n        const meta = {\n            name: 'searchable_snapshots.stats',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = SearchableSnapshots;\n//# sourceMappingURL=searchable_snapshots.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWFyY2hhYmxlX3NuYXBzaG90cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOENBQThDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQsR0FBRywrQ0FBK0M7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRDQUE0QztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvc2VhcmNoYWJsZV9zbmFwc2hvdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNlYXJjaGFibGVTbmFwc2hvdHMge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGNhY2hlU3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbm9kZV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubm9kZV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWFyY2hhYmxlX3NuYXBzaG90cy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubm9kZV9pZC50b1N0cmluZygpKX0vY2FjaGUvc3RhdHNgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fc2VhcmNoYWJsZV9zbmFwc2hvdHMvY2FjaGUvc3RhdHMnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoYWJsZV9zbmFwc2hvdHMuY2FjaGVfc3RhdHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjbGVhckNhY2hlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2luZGV4J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zZWFyY2hhYmxlX3NuYXBzaG90cy9jYWNoZS9jbGVhcmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fc2VhcmNoYWJsZV9zbmFwc2hvdHMvY2FjaGUvY2xlYXInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VhcmNoYWJsZV9zbmFwc2hvdHMuY2xlYXJfY2FjaGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG1vdW50KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3JlcG9zaXRvcnknLCAnc25hcHNob3QnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydpbmRleCcsICdyZW5hbWVkX2luZGV4JywgJ2luZGV4X3NldHRpbmdzJywgJ2lnbm9yZV9pbmRleF9zZXR0aW5ncyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucmVwb3NpdG9yeS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90LnRvU3RyaW5nKCkpfS9fbW91bnRgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlYXJjaGFibGVfc25hcHNob3RzLm1vdW50JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnk6IHBhcmFtcy5yZXBvc2l0b3J5LFxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBwYXJhbXMuc25hcHNob3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L19zZWFyY2hhYmxlX3NuYXBzaG90cy9zdGF0c2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zZWFyY2hhYmxlX3NuYXBzaG90cy9zdGF0cyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWFyY2hhYmxlX3NuYXBzaG90cy5zdGF0cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZWFyY2hhYmxlU25hcHNob3RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VhcmNoYWJsZV9zbmFwc2hvdHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/security.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/security.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Security {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async activateUserProfile(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['access_token', 'grant_type', 'password', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/profile/_activate';\n        const meta = {\n            name: 'security.activate_user_profile'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async authenticate(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/_authenticate';\n        const meta = {\n            name: 'security.authenticate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async bulkDeleteRole(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['names'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_security/role';\n        const meta = {\n            name: 'security.bulk_delete_role'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async bulkPutRole(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['roles'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/role';\n        const meta = {\n            name: 'security.bulk_put_role'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async bulkUpdateApiKeys(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/api_key/_bulk_update';\n        const meta = {\n            name: 'security.bulk_update_api_keys'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async changePassword(params, options) {\n        const acceptedPath = ['username'];\n        const acceptedBody = ['password', 'password_hash'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.username != null) {\n            method = 'PUT';\n            path = `/_security/user/${encodeURIComponent(params.username.toString())}/_password`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_security/user/_password';\n        }\n        const meta = {\n            name: 'security.change_password',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearApiKeyCache(params, options) {\n        const acceptedPath = ['ids'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/api_key/${encodeURIComponent(params.ids.toString())}/_clear_cache`;\n        const meta = {\n            name: 'security.clear_api_key_cache',\n            pathParts: {\n                ids: params.ids\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCachedPrivileges(params, options) {\n        const acceptedPath = ['application'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/_clear_cache`;\n        const meta = {\n            name: 'security.clear_cached_privileges',\n            pathParts: {\n                application: params.application\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCachedRealms(params, options) {\n        const acceptedPath = ['realms'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/realm/${encodeURIComponent(params.realms.toString())}/_clear_cache`;\n        const meta = {\n            name: 'security.clear_cached_realms',\n            pathParts: {\n                realms: params.realms\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCachedRoles(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}/_clear_cache`;\n        const meta = {\n            name: 'security.clear_cached_roles',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clearCachedServiceTokens(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}/_clear_cache`;\n        const meta = {\n            name: 'security.clear_cached_service_tokens',\n            pathParts: {\n                namespace: params.namespace,\n                service: params.service,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async createApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['expiration', 'name', 'role_descriptors', 'metadata'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_security/api_key';\n        const meta = {\n            name: 'security.create_api_key'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async createCrossClusterApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['access', 'expiration', 'metadata', 'name'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/cross_cluster/api_key';\n        const meta = {\n            name: 'security.create_cross_cluster_api_key'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async createServiceToken(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.namespace != null && params.service != null && params.name != null) {\n            method = 'PUT';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token`;\n        }\n        const meta = {\n            name: 'security.create_service_token',\n            pathParts: {\n                namespace: params.namespace,\n                service: params.service,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deletePrivileges(params, options) {\n        const acceptedPath = ['application', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.delete_privileges',\n            pathParts: {\n                application: params.application,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteRole(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.delete_role',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.delete_role_mapping',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteServiceToken(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.delete_service_token',\n            pathParts: {\n                namespace: params.namespace,\n                service: params.service,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        const meta = {\n            name: 'security.delete_user',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async disableUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_disable`;\n        const meta = {\n            name: 'security.disable_user',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async disableUserProfile(params, options) {\n        const acceptedPath = ['uid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_disable`;\n        const meta = {\n            name: 'security.disable_user_profile',\n            pathParts: {\n                uid: params.uid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async enableUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_enable`;\n        const meta = {\n            name: 'security.enable_user',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async enableUserProfile(params, options) {\n        const acceptedPath = ['uid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_enable`;\n        const meta = {\n            name: 'security.enable_user_profile',\n            pathParts: {\n                uid: params.uid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async enrollKibana(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/enroll/kibana';\n        const meta = {\n            name: 'security.enroll_kibana'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async enrollNode(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/enroll/node';\n        const meta = {\n            name: 'security.enroll_node'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getApiKey(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/api_key';\n        const meta = {\n            name: 'security.get_api_key'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getBuiltinPrivileges(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/privilege/_builtin';\n        const meta = {\n            name: 'security.get_builtin_privileges'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getPrivileges(params, options) {\n        const acceptedPath = ['application', 'name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.application != null && params.name != null) {\n            method = 'GET';\n            path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.application != null) {\n            method = 'GET';\n            path = `/_security/privilege/${encodeURIComponent(params.application.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/privilege';\n        }\n        const meta = {\n            name: 'security.get_privileges',\n            pathParts: {\n                application: params.application,\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRole(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/role';\n        }\n        const meta = {\n            name: 'security.get_role',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/role_mapping';\n        }\n        const meta = {\n            name: 'security.get_role_mapping',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getServiceAccounts(params, options) {\n        const acceptedPath = ['namespace', 'service'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.namespace != null && params.service != null) {\n            method = 'GET';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}`;\n        }\n        else if (params.namespace != null) {\n            method = 'GET';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/service';\n        }\n        const meta = {\n            name: 'security.get_service_accounts',\n            pathParts: {\n                namespace: params.namespace,\n                service: params.service\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getServiceCredentials(params, options) {\n        const acceptedPath = ['namespace', 'service'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential`;\n        const meta = {\n            name: 'security.get_service_credentials',\n            pathParts: {\n                namespace: params.namespace,\n                service: params.service\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/settings';\n        const meta = {\n            name: 'security.get_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getToken(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['grant_type', 'scope', 'password', 'kerberos_ticket', 'refresh_token', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/oauth2/token';\n        const meta = {\n            name: 'security.get_token'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.username != null) {\n            method = 'GET';\n            path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/user';\n        }\n        const meta = {\n            name: 'security.get_user',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getUserPrivileges(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/user/_privileges';\n        const meta = {\n            name: 'security.get_user_privileges'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getUserProfile(params, options) {\n        const acceptedPath = ['uid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}`;\n        const meta = {\n            name: 'security.get_user_profile',\n            pathParts: {\n                uid: params.uid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async grantApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['api_key', 'grant_type', 'access_token', 'username', 'password', 'run_as'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/api_key/grant';\n        const meta = {\n            name: 'security.grant_api_key'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async hasPrivileges(params, options) {\n        const acceptedPath = ['user'];\n        const acceptedBody = ['application', 'cluster', 'index'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.user != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_security/user/${encodeURIComponent(params.user.toString())}/_has_privileges`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_security/user/_has_privileges';\n        }\n        const meta = {\n            name: 'security.has_privileges',\n            pathParts: {\n                user: params.user\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async hasPrivilegesUserProfile(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['uids', 'privileges'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/profile/_has_privileges';\n        const meta = {\n            name: 'security.has_privileges_user_profile'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async invalidateApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['id', 'ids', 'name', 'owner', 'realm_name', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_security/api_key';\n        const meta = {\n            name: 'security.invalidate_api_key'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async invalidateToken(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['token', 'refresh_token', 'realm_name', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_security/oauth2/token';\n        const meta = {\n            name: 'security.invalidate_token'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async oidcAuthenticate(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/oidc/authenticate';\n        const meta = {\n            name: 'security.oidc_authenticate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async oidcLogout(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/oidc/logout';\n        const meta = {\n            name: 'security.oidc_logout'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async oidcPrepareAuthentication(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/oidc/prepare';\n        const meta = {\n            name: 'security.oidc_prepare_authentication'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putPrivileges(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['privileges'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_security/privilege';\n        const meta = {\n            name: 'security.put_privileges'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putRole(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['applications', 'cluster', 'global', 'indices', 'remote_indices', 'metadata', 'run_as', 'description', 'transient_metadata'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.put_role',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['enabled', 'metadata', 'roles', 'role_templates', 'rules', 'run_as'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'security.put_role_mapping',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putUser(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['username', 'email', 'full_name', 'metadata', 'password', 'password_hash', 'roles', 'enabled'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        const meta = {\n            name: 'security.put_user',\n            pathParts: {\n                username: params.username\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async queryApiKeys(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['aggregations', 'aggs', 'query', 'from', 'sort', 'size', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/_query/api_key';\n        const meta = {\n            name: 'security.query_api_keys'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async queryRole(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['query', 'from', 'sort', 'size', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/_query/role';\n        const meta = {\n            name: 'security.query_role'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async queryUser(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['query', 'from', 'sort', 'size', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/_query/user';\n        const meta = {\n            name: 'security.query_user'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlAuthenticate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['content', 'ids', 'realm'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/authenticate';\n        const meta = {\n            name: 'security.saml_authenticate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlCompleteLogout(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['realm', 'ids', 'query_string', 'content'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/complete_logout';\n        const meta = {\n            name: 'security.saml_complete_logout'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlInvalidate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['acs', 'query_string', 'realm'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/invalidate';\n        const meta = {\n            name: 'security.saml_invalidate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlLogout(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['token', 'refresh_token'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/logout';\n        const meta = {\n            name: 'security.saml_logout'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlPrepareAuthentication(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['acs', 'realm', 'relay_state'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/prepare';\n        const meta = {\n            name: 'security.saml_prepare_authentication'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async samlServiceProviderMetadata(params, options) {\n        const acceptedPath = ['realm_name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_security/saml/metadata/${encodeURIComponent(params.realm_name.toString())}`;\n        const meta = {\n            name: 'security.saml_service_provider_metadata',\n            pathParts: {\n                realm_name: params.realm_name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async suggestUserProfiles(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['name', 'size', 'data', 'hint'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/profile/_suggest';\n        const meta = {\n            name: 'security.suggest_user_profiles'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateApiKey(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['role_descriptors', 'metadata', 'expiration'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/api_key/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'security.update_api_key',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateCrossClusterApiKey(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['access', 'expiration', 'metadata'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/cross_cluster/api_key/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'security.update_cross_cluster_api_key',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_security/settings';\n        const meta = {\n            name: 'security.update_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateUserProfileData(params, options) {\n        const acceptedPath = ['uid'];\n        const acceptedBody = ['labels', 'data'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/profile/${encodeURIComponent(params.uid.toString())}/_data`;\n        const meta = {\n            name: 'security.update_user_profile_data',\n            pathParts: {\n                uid: params.uid\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Security;\n//# sourceMappingURL=security.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zZWN1cml0eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQStDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBMEM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsa0RBQWtEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDZDQUE2QztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0RBQWdELEdBQUcsOENBQThDLG9CQUFvQiwyQ0FBMkM7QUFDM007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0RBQWdELEdBQUcsOENBQThDLG9CQUFvQiwyQ0FBMkM7QUFDek07QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFnRCxHQUFHLDhDQUE4QztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrREFBa0QsR0FBRywyQ0FBMkM7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdEQUFnRCxHQUFHLDhDQUE4QyxvQkFBb0IsMkNBQTJDO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQ0FBK0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQStDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDBDQUEwQztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQ0FBK0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMENBQTBDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtELEdBQUcsMkNBQTJDO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrREFBa0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBMkM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkNBQTJDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFnRCxHQUFHLDhDQUE4QztBQUMxSTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0RBQWdEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdEQUFnRCxHQUFHLDhDQUE4QztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQStDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwQ0FBMEM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJDQUEyQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkNBQTJDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMkNBQTJDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0NBQStDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaURBQWlEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCx5Q0FBeUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMENBQTBDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3NlY3VyaXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBTZWN1cml0eSB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgYWN0aXZhdGVVc2VyUHJvZmlsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWNjZXNzX3Rva2VuJywgJ2dyYW50X3R5cGUnLCAncGFzc3dvcmQnLCAndXNlcm5hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvcHJvZmlsZS9fYWN0aXZhdGUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmFjdGl2YXRlX3VzZXJfcHJvZmlsZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhdXRoZW50aWNhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L19hdXRoZW50aWNhdGUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmF1dGhlbnRpY2F0ZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBidWxrRGVsZXRlUm9sZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbmFtZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9yb2xlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5idWxrX2RlbGV0ZV9yb2xlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGJ1bGtQdXRSb2xlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyb2xlcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9yb2xlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5idWxrX3B1dF9yb2xlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGJ1bGtVcGRhdGVBcGlLZXlzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9hcGlfa2V5L19idWxrX3VwZGF0ZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuYnVsa191cGRhdGVfYXBpX2tleXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlUGFzc3dvcmQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndXNlcm5hbWUnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydwYXNzd29yZCcsICdwYXNzd29yZF9oYXNoJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMudXNlcm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fc2VjdXJpdHkvdXNlci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudXNlcm5hbWUudG9TdHJpbmcoKSl9L19wYXNzd29yZGA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zZWN1cml0eS91c2VyL19wYXNzd29yZCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5jaGFuZ2VfcGFzc3dvcmQnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHBhcmFtcy51c2VybmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFyQXBpS2V5Q2FjaGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWRzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvYXBpX2tleS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWRzLnRvU3RyaW5nKCkpfS9fY2xlYXJfY2FjaGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmNsZWFyX2FwaV9rZXlfY2FjaGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWRzOiBwYXJhbXMuaWRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXJDYWNoZWRQcml2aWxlZ2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2FwcGxpY2F0aW9uJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvcHJpdmlsZWdlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5hcHBsaWNhdGlvbi50b1N0cmluZygpKX0vX2NsZWFyX2NhY2hlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5jbGVhcl9jYWNoZWRfcHJpdmlsZWdlcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbjogcGFyYW1zLmFwcGxpY2F0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXJDYWNoZWRSZWFsbXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsncmVhbG1zJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvcmVhbG0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJlYWxtcy50b1N0cmluZygpKX0vX2NsZWFyX2NhY2hlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5jbGVhcl9jYWNoZWRfcmVhbG1zJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlYWxtczogcGFyYW1zLnJlYWxtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFyQ2FjaGVkUm9sZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3JvbGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9L19jbGVhcl9jYWNoZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuY2xlYXJfY2FjaGVkX3JvbGVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY2xlYXJDYWNoZWRTZXJ2aWNlVG9rZW5zKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWVzcGFjZScsICdzZXJ2aWNlJywgJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXJ2aWNlLnRvU3RyaW5nKCkpfS9jcmVkZW50aWFsL3Rva2VuLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfS9fY2xlYXJfY2FjaGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmNsZWFyX2NhY2hlZF9zZXJ2aWNlX3Rva2VucycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHBhcmFtcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgc2VydmljZTogcGFyYW1zLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVBcGlLZXkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2V4cGlyYXRpb24nLCAnbmFtZScsICdyb2xlX2Rlc2NyaXB0b3JzJywgJ21ldGFkYXRhJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L2FwaV9rZXknO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmNyZWF0ZV9hcGlfa2V5J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUNyb3NzQ2x1c3RlckFwaUtleShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWNjZXNzJywgJ2V4cGlyYXRpb24nLCAnbWV0YWRhdGEnLCAnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9jcm9zc19jbHVzdGVyL2FwaV9rZXknO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmNyZWF0ZV9jcm9zc19jbHVzdGVyX2FwaV9rZXknXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlU2VydmljZVRva2VuKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWVzcGFjZScsICdzZXJ2aWNlJywgJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZXNwYWNlICE9IG51bGwgJiYgcGFyYW1zLnNlcnZpY2UgIT0gbnVsbCAmJiBwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXJ2aWNlLnRvU3RyaW5nKCkpfS9jcmVkZW50aWFsL3Rva2VuLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fc2VjdXJpdHkvc2VydmljZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZXNwYWNlLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc2VydmljZS50b1N0cmluZygpKX0vY3JlZGVudGlhbC90b2tlbmA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5jcmVhdGVfc2VydmljZV90b2tlbicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHBhcmFtcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgc2VydmljZTogcGFyYW1zLnNlcnZpY2UsXG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVQcml2aWxlZ2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2FwcGxpY2F0aW9uJywgJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3ByaXZpbGVnZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuYXBwbGljYXRpb24udG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZGVsZXRlX3ByaXZpbGVnZXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb246IHBhcmFtcy5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVJvbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvcm9sZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmRlbGV0ZV9yb2xlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlUm9sZU1hcHBpbmcocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvcm9sZV9tYXBwaW5nLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZGVsZXRlX3JvbGVfbWFwcGluZycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVNlcnZpY2VUb2tlbihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lc3BhY2UnLCAnc2VydmljZScsICduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXJ2aWNlLnRvU3RyaW5nKCkpfS9jcmVkZW50aWFsL3Rva2VuLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZGVsZXRlX3NlcnZpY2VfdG9rZW4nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBwYXJhbXMubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IHBhcmFtcy5zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlVXNlcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd1c2VybmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvdXNlci8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudXNlcm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5kZWxldGVfdXNlcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogcGFyYW1zLnVzZXJuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGlzYWJsZVVzZXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndXNlcm5hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3VzZXIvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnVzZXJuYW1lLnRvU3RyaW5nKCkpfS9fZGlzYWJsZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZGlzYWJsZV91c2VyJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBwYXJhbXMudXNlcm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkaXNhYmxlVXNlclByb2ZpbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndWlkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9wcm9maWxlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy51aWQudG9TdHJpbmcoKSl9L19kaXNhYmxlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5kaXNhYmxlX3VzZXJfcHJvZmlsZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB1aWQ6IHBhcmFtcy51aWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBlbmFibGVVc2VyKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3VzZXJuYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS91c2VyLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy51c2VybmFtZS50b1N0cmluZygpKX0vX2VuYWJsZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZW5hYmxlX3VzZXInLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHBhcmFtcy51c2VybmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGVuYWJsZVVzZXJQcm9maWxlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3VpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2VjdXJpdHkvcHJvZmlsZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudWlkLnRvU3RyaW5nKCkpfS9fZW5hYmxlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5lbmFibGVfdXNlcl9wcm9maWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHVpZDogcGFyYW1zLnVpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGVucm9sbEtpYmFuYShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvZW5yb2xsL2tpYmFuYSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZW5yb2xsX2tpYmFuYSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBlbnJvbGxOb2RlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9lbnJvbGwvbm9kZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZW5yb2xsX25vZGUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QXBpS2V5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9hcGlfa2V5JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfYXBpX2tleSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRCdWlsdGluUHJpdmlsZWdlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvcHJpdmlsZWdlL19idWlsdGluJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfYnVpbHRpbl9wcml2aWxlZ2VzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFByaXZpbGVnZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnYXBwbGljYXRpb24nLCAnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuYXBwbGljYXRpb24gIT0gbnVsbCAmJiBwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9wcml2aWxlZ2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmFwcGxpY2F0aW9uLnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmFtcy5hcHBsaWNhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9wcml2aWxlZ2UvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmFwcGxpY2F0aW9uLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zZWN1cml0eS9wcml2aWxlZ2UnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZ2V0X3ByaXZpbGVnZXMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgYXBwbGljYXRpb246IHBhcmFtcy5hcHBsaWNhdGlvbixcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFJvbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9yb2xlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zZWN1cml0eS9yb2xlJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmdldF9yb2xlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Um9sZU1hcHBpbmcocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9yb2xlX21hcHBpbmcvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NlY3VyaXR5L3JvbGVfbWFwcGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfcm9sZV9tYXBwaW5nJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VydmljZUFjY291bnRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWVzcGFjZScsICdzZXJ2aWNlJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5uYW1lc3BhY2UgIT0gbnVsbCAmJiBwYXJhbXMuc2VydmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXJ2aWNlLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyYW1zLm5hbWVzcGFjZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NlY3VyaXR5L3NlcnZpY2UnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZ2V0X3NlcnZpY2VfYWNjb3VudHMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBwYXJhbXMubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHNlcnZpY2U6IHBhcmFtcy5zZXJ2aWNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VydmljZUNyZWRlbnRpYWxzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWVzcGFjZScsICdzZXJ2aWNlJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9zZXJ2aWNlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lc3BhY2UudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXJ2aWNlLnRvU3RyaW5nKCkpfS9jcmVkZW50aWFsYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfc2VydmljZV9jcmVkZW50aWFscycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IHBhcmFtcy5uYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgc2VydmljZTogcGFyYW1zLnNlcnZpY2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9zZXR0aW5ncyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuZ2V0X3NldHRpbmdzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFRva2VuKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydncmFudF90eXBlJywgJ3Njb3BlJywgJ3Bhc3N3b3JkJywgJ2tlcmJlcm9zX3RpY2tldCcsICdyZWZyZXNoX3Rva2VuJywgJ3VzZXJuYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9vYXV0aDIvdG9rZW4nO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmdldF90b2tlbidcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRVc2VyKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3VzZXJuYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy51c2VybmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zZWN1cml0eS91c2VyLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy51c2VybmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fc2VjdXJpdHkvdXNlcic7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfdXNlcicsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogcGFyYW1zLnVzZXJuYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXNlclByaXZpbGVnZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L3VzZXIvX3ByaXZpbGVnZXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmdldF91c2VyX3ByaXZpbGVnZXMnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VXNlclByb2ZpbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndWlkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9wcm9maWxlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy51aWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5nZXRfdXNlcl9wcm9maWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHVpZDogcGFyYW1zLnVpZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdyYW50QXBpS2V5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhcGlfa2V5JywgJ2dyYW50X3R5cGUnLCAnYWNjZXNzX3Rva2VuJywgJ3VzZXJuYW1lJywgJ3Bhc3N3b3JkJywgJ3J1bl9hcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9hcGlfa2V5L2dyYW50JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5ncmFudF9hcGlfa2V5J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGhhc1ByaXZpbGVnZXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndXNlciddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FwcGxpY2F0aW9uJywgJ2NsdXN0ZXInLCAnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy51c2VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX3NlY3VyaXR5L3VzZXIvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnVzZXIudG9TdHJpbmcoKSl9L19oYXNfcHJpdmlsZWdlc2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zZWN1cml0eS91c2VyL19oYXNfcHJpdmlsZWdlcyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5oYXNfcHJpdmlsZWdlcycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB1c2VyOiBwYXJhbXMudXNlclxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGhhc1ByaXZpbGVnZXNVc2VyUHJvZmlsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsndWlkcycsICdwcml2aWxlZ2VzJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvcHJvZmlsZS9faGFzX3ByaXZpbGVnZXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5Lmhhc19wcml2aWxlZ2VzX3VzZXJfcHJvZmlsZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBpbnZhbGlkYXRlQXBpS2V5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydpZCcsICdpZHMnLCAnbmFtZScsICdvd25lcicsICdyZWFsbV9uYW1lJywgJ3VzZXJuYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L2FwaV9rZXknO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmludmFsaWRhdGVfYXBpX2tleSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBpbnZhbGlkYXRlVG9rZW4ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3Rva2VuJywgJ3JlZnJlc2hfdG9rZW4nLCAncmVhbG1fbmFtZScsICd1c2VybmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9vYXV0aDIvdG9rZW4nO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LmludmFsaWRhdGVfdG9rZW4nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgb2lkY0F1dGhlbnRpY2F0ZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvb2lkYy9hdXRoZW50aWNhdGUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5Lm9pZGNfYXV0aGVudGljYXRlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIG9pZGNMb2dvdXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L29pZGMvbG9nb3V0JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5vaWRjX2xvZ291dCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBvaWRjUHJlcGFyZUF1dGhlbnRpY2F0aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9vaWRjL3ByZXBhcmUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5Lm9pZGNfcHJlcGFyZV9hdXRoZW50aWNhdGlvbidcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRQcml2aWxlZ2VzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3ByaXZpbGVnZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9wcml2aWxlZ2UnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnB1dF9wcml2aWxlZ2VzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dFJvbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FwcGxpY2F0aW9ucycsICdjbHVzdGVyJywgJ2dsb2JhbCcsICdpbmRpY2VzJywgJ3JlbW90ZV9pbmRpY2VzJywgJ21ldGFkYXRhJywgJ3J1bl9hcycsICdkZXNjcmlwdGlvbicsICd0cmFuc2llbnRfbWV0YWRhdGEnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9yb2xlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5uYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkucHV0X3JvbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRSb2xlTWFwcGluZyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZW5hYmxlZCcsICdtZXRhZGF0YScsICdyb2xlcycsICdyb2xlX3RlbXBsYXRlcycsICdydWxlcycsICdydW5fYXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9yb2xlX21hcHBpbmcvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5wdXRfcm9sZV9tYXBwaW5nJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0VXNlcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsndXNlcm5hbWUnLCAnZW1haWwnLCAnZnVsbF9uYW1lJywgJ21ldGFkYXRhJywgJ3Bhc3N3b3JkJywgJ3Bhc3N3b3JkX2hhc2gnLCAncm9sZXMnLCAnZW5hYmxlZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3VzZXIvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnVzZXJuYW1lLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkucHV0X3VzZXInLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdXNlcm5hbWU6IHBhcmFtcy51c2VybmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHF1ZXJ5QXBpS2V5cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWdncmVnYXRpb25zJywgJ2FnZ3MnLCAncXVlcnknLCAnZnJvbScsICdzb3J0JywgJ3NpemUnLCAnc2VhcmNoX2FmdGVyJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L19xdWVyeS9hcGlfa2V5JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5xdWVyeV9hcGlfa2V5cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeVJvbGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3F1ZXJ5JywgJ2Zyb20nLCAnc29ydCcsICdzaXplJywgJ3NlYXJjaF9hZnRlciddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9fcXVlcnkvcm9sZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkucXVlcnlfcm9sZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeVVzZXIocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3F1ZXJ5JywgJ2Zyb20nLCAnc29ydCcsICdzaXplJywgJ3NlYXJjaF9hZnRlciddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9fcXVlcnkvdXNlcic7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkucXVlcnlfdXNlcidcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzYW1sQXV0aGVudGljYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjb250ZW50JywgJ2lkcycsICdyZWFsbSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9zYW1sL2F1dGhlbnRpY2F0ZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuc2FtbF9hdXRoZW50aWNhdGUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2FtbENvbXBsZXRlTG9nb3V0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyZWFsbScsICdpZHMnLCAncXVlcnlfc3RyaW5nJywgJ2NvbnRlbnQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvc2FtbC9jb21wbGV0ZV9sb2dvdXQnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnNhbWxfY29tcGxldGVfbG9nb3V0J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNhbWxJbnZhbGlkYXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhY3MnLCAncXVlcnlfc3RyaW5nJywgJ3JlYWxtJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L3NhbWwvaW52YWxpZGF0ZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkuc2FtbF9pbnZhbGlkYXRlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNhbWxMb2dvdXQocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3Rva2VuJywgJ3JlZnJlc2hfdG9rZW4nXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvc2FtbC9sb2dvdXQnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnNhbWxfbG9nb3V0J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNhbWxQcmVwYXJlQXV0aGVudGljYXRpb24ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FjcycsICdyZWFsbScsICdyZWxheV9zdGF0ZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2VjdXJpdHkvc2FtbC9wcmVwYXJlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5zYW1sX3ByZXBhcmVfYXV0aGVudGljYXRpb24nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc2FtbFNlcnZpY2VQcm92aWRlck1ldGFkYXRhKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3JlYWxtX25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3NhbWwvbWV0YWRhdGEvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJlYWxtX25hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS5zYW1sX3NlcnZpY2VfcHJvdmlkZXJfbWV0YWRhdGEnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgcmVhbG1fbmFtZTogcGFyYW1zLnJlYWxtX25hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdWdnZXN0VXNlclByb2ZpbGVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWyduYW1lJywgJ3NpemUnLCAnZGF0YScsICdoaW50J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NlY3VyaXR5L3Byb2ZpbGUvX3N1Z2dlc3QnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnN1Z2dlc3RfdXNlcl9wcm9maWxlcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVBcGlLZXkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydyb2xlX2Rlc2NyaXB0b3JzJywgJ21ldGFkYXRhJywgJ2V4cGlyYXRpb24nXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zZWN1cml0eS9hcGlfa2V5LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnVwZGF0ZV9hcGlfa2V5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDcm9zc0NsdXN0ZXJBcGlLZXkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydhY2Nlc3MnLCAnZXhwaXJhdGlvbicsICdtZXRhZGF0YSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L2Nyb3NzX2NsdXN0ZXIvYXBpX2tleS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzZWN1cml0eS51cGRhdGVfY3Jvc3NfY2x1c3Rlcl9hcGlfa2V5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVTZXR0aW5ncyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zZWN1cml0eS9zZXR0aW5ncyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2VjdXJpdHkudXBkYXRlX3NldHRpbmdzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVVzZXJQcm9maWxlRGF0YShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd1aWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydsYWJlbHMnLCAnZGF0YSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NlY3VyaXR5L3Byb2ZpbGUvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnVpZC50b1N0cmluZygpKX0vX2RhdGFgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NlY3VyaXR5LnVwZGF0ZV91c2VyX3Byb2ZpbGVfZGF0YScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB1aWQ6IHBhcmFtcy51aWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlY3VyaXR5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjdXJpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/security.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Shutdown {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        const meta = {\n            name: 'shutdown.delete_node',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/shutdown';\n        }\n        const meta = {\n            name: 'shutdown.get_node',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const acceptedBody = ['type', 'reason', 'allocation_delay', 'target_node_name'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        const meta = {\n            name: 'shutdown.put_node',\n            pathParts: {\n                node_id: params.node_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Shutdown;\n//# sourceMappingURL=shutdown.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zaHV0ZG93bi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhDQUE4QztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhDQUE4QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBOEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvc2h1dGRvd24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNodXRkb3duIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVOb2RlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25vZGVfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX25vZGVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ub2RlX2lkLnRvU3RyaW5nKCkpfS9zaHV0ZG93bmA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2h1dGRvd24uZGVsZXRlX25vZGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbm9kZV9pZDogcGFyYW1zLm5vZGVfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXROb2RlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25vZGVfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVfaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fbm9kZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5vZGVfaWQudG9TdHJpbmcoKSl9L3NodXRkb3duYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX25vZGVzL3NodXRkb3duJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NodXRkb3duLmdldF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5vZGVfaWQ6IHBhcmFtcy5ub2RlX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0Tm9kZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydub2RlX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsndHlwZScsICdyZWFzb24nLCAnYWxsb2NhdGlvbl9kZWxheScsICd0YXJnZXRfbm9kZV9uYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fbm9kZXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5vZGVfaWQudG9TdHJpbmcoKSl9L3NodXRkb3duYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzaHV0ZG93bi5wdXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBub2RlX2lkOiBwYXJhbXMubm9kZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2h1dGRvd247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaHV0ZG93bi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/simulate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/simulate.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Simulate {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async ingest(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ingest/${encodeURIComponent(params.index.toString())}/_simulate`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ingest/_simulate';\n        }\n        const meta = {\n            name: 'simulate.ingest',\n            pathParts: {\n                index: params.index\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Simulate;\n//# sourceMappingURL=simulate.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zaW11bGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRDQUE0QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvc2ltdWxhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNpbXVsYXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBpbmdlc3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMuaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9faW5nZXN0LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pbmRleC50b1N0cmluZygpKX0vX3NpbXVsYXRlYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX2luZ2VzdC9fc2ltdWxhdGUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2ltdWxhdGUuaW5nZXN0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNpbXVsYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2ltdWxhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/simulate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/slm.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/slm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Slm {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        const meta = {\n            name: 'slm.delete_lifecycle',\n            pathParts: {\n                policy_id: params.policy_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async executeLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}/_execute`;\n        const meta = {\n            name: 'slm.execute_lifecycle',\n            pathParts: {\n                policy_id: params.policy_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async executeRetention(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/_execute_retention';\n        const meta = {\n            name: 'slm.execute_retention'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.policy_id != null) {\n            method = 'GET';\n            path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_slm/policy';\n        }\n        const meta = {\n            name: 'slm.get_lifecycle',\n            pathParts: {\n                policy_id: params.policy_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getStats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_slm/stats';\n        const meta = {\n            name: 'slm.get_stats'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_slm/status';\n        const meta = {\n            name: 'slm.get_status'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const acceptedBody = ['config', 'name', 'repository', 'retention', 'schedule'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        const meta = {\n            name: 'slm.put_lifecycle',\n            pathParts: {\n                policy_id: params.policy_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/start';\n        const meta = {\n            name: 'slm.start'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/stop';\n        const meta = {\n            name: 'slm.stop'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Slm;\n//# sourceMappingURL=slm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zbG0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnREFBZ0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQWdEO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQWdEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdEQUFnRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zbG0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNsbSB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlTGlmZWN5Y2xlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3BvbGljeV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc2xtL3BvbGljeS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucG9saWN5X2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2xtLmRlbGV0ZV9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgcG9saWN5X2lkOiBwYXJhbXMucG9saWN5X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZUxpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydwb2xpY3lfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NsbS9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnBvbGljeV9pZC50b1N0cmluZygpKX0vX2V4ZWN1dGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NsbS5leGVjdXRlX2xpZmVjeWNsZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBwb2xpY3lfaWQ6IHBhcmFtcy5wb2xpY3lfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlUmV0ZW50aW9uKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2xtL19leGVjdXRlX3JldGVudGlvbic7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2xtLmV4ZWN1dGVfcmV0ZW50aW9uJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldExpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydwb2xpY3lfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLnBvbGljeV9pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zbG0vcG9saWN5LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5wb2xpY3lfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NsbS9wb2xpY3knO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2xtLmdldF9saWZlY3ljbGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgcG9saWN5X2lkOiBwYXJhbXMucG9saWN5X2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3RhdHMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NsbS9zdGF0cyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc2xtLmdldF9zdGF0cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NsbS9zdGF0dXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NsbS5nZXRfc3RhdHVzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dExpZmVjeWNsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydwb2xpY3lfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydjb25maWcnLCAnbmFtZScsICdyZXBvc2l0b3J5JywgJ3JldGVudGlvbicsICdzY2hlZHVsZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NsbS9wb2xpY3kvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnBvbGljeV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NsbS5wdXRfbGlmZWN5Y2xlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHBvbGljeV9pZDogcGFyYW1zLnBvbGljeV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc2xtL3N0YXJ0JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbG0uc3RhcnQnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NsbS9zdG9wJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbG0uc3RvcCdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNsbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNsbS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/slm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Snapshot {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cleanupRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_cleanup`;\n        const meta = {\n            name: 'snapshot.cleanup_repository',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async clone(params, options) {\n        const acceptedPath = ['repository', 'snapshot', 'target_snapshot'];\n        const acceptedBody = ['indices'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_clone/${encodeURIComponent(params.target_snapshot.toString())}`;\n        const meta = {\n            name: 'snapshot.clone',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot,\n                target_snapshot: params.target_snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async create(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['ignore_unavailable', 'include_global_state', 'indices', 'feature_states', 'metadata', 'partial'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        const meta = {\n            name: 'snapshot.create',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async createRepository(params, options) {\n        var _a;\n        const acceptedPath = ['name'];\n        const acceptedBody = ['repository'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'snapshot.create_repository',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async delete(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        const meta = {\n            name: 'snapshot.delete',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        const meta = {\n            name: 'snapshot.delete_repository',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        const meta = {\n            name: 'snapshot.get',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_snapshot';\n        }\n        const meta = {\n            name: 'snapshot.get_repository',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async repositoryAnalyze(params, options) {\n        const acceptedPath = ['repository'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_analyze`;\n        const meta = {\n            name: 'snapshot.repository_analyze',\n            pathParts: {\n                repository: params.repository\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async repositoryVerifyIntegrity(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify_integrity`;\n        const meta = {\n            name: 'snapshot.repository_verify_integrity',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async restore(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['feature_states', 'ignore_index_settings', 'ignore_unavailable', 'include_aliases', 'include_global_state', 'index_settings', 'indices', 'partial', 'rename_pattern', 'rename_replacement'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_restore`;\n        const meta = {\n            name: 'snapshot.restore',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async status(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.repository != null && params.snapshot != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_status`;\n        }\n        else if (params.repository != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_status`;\n        }\n        else {\n            method = 'GET';\n            path = '/_snapshot/_status';\n        }\n        const meta = {\n            name: 'snapshot.status',\n            pathParts: {\n                repository: params.repository,\n                snapshot: params.snapshot\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async verifyRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify`;\n        const meta = {\n            name: 'snapshot.verify_repository',\n            pathParts: {\n                name: params.name\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Snapshot;\n//# sourceMappingURL=snapshot.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zbmFwc2hvdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJDQUEyQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlEQUFpRCxHQUFHLCtDQUErQyxVQUFVLHNEQUFzRDtBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQsR0FBRywrQ0FBK0M7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJDQUEyQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQsR0FBRywrQ0FBK0M7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBMkM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQWlELEdBQUcsK0NBQStDO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlEQUFpRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBMkM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpREFBaUQsR0FBRywrQ0FBK0M7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlEQUFpRCxHQUFHLCtDQUErQztBQUNwSTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQWlEO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDJDQUEyQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zbmFwc2hvdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgU25hcHNob3Qge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGNsZWFudXBSZXBvc2l0b3J5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX0vX2NsZWFudXBgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NuYXBzaG90LmNsZWFudXBfcmVwb3NpdG9yeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGNsb25lKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3JlcG9zaXRvcnknLCAnc25hcHNob3QnLCAndGFyZ2V0X3NuYXBzaG90J107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnaW5kaWNlcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NuYXBzaG90LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5yZXBvc2l0b3J5LnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc25hcHNob3QudG9TdHJpbmcoKSl9L19jbG9uZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudGFyZ2V0X3NuYXBzaG90LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc25hcHNob3QuY2xvbmUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgcmVwb3NpdG9yeTogcGFyYW1zLnJlcG9zaXRvcnksXG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHBhcmFtcy5zbmFwc2hvdCxcbiAgICAgICAgICAgICAgICB0YXJnZXRfc25hcHNob3Q6IHBhcmFtcy50YXJnZXRfc25hcHNob3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsncmVwb3NpdG9yeScsICdzbmFwc2hvdCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2lnbm9yZV91bmF2YWlsYWJsZScsICdpbmNsdWRlX2dsb2JhbF9zdGF0ZScsICdpbmRpY2VzJywgJ2ZlYXR1cmVfc3RhdGVzJywgJ21ldGFkYXRhJywgJ3BhcnRpYWwnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucmVwb3NpdG9yeS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc25hcHNob3QuY3JlYXRlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnk6IHBhcmFtcy5yZXBvc2l0b3J5LFxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBwYXJhbXMuc25hcHNob3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjcmVhdGVSZXBvc2l0b3J5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3JlcG9zaXRvcnknXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMubmFtZS50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NuYXBzaG90LmNyZWF0ZV9yZXBvc2l0b3J5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3JlcG9zaXRvcnknLCAnc25hcHNob3QnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NuYXBzaG90LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5yZXBvc2l0b3J5LnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc25hcHNob3QudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbmFwc2hvdC5kZWxldGUnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgcmVwb3NpdG9yeTogcGFyYW1zLnJlcG9zaXRvcnksXG4gICAgICAgICAgICAgICAgc25hcHNob3Q6IHBhcmFtcy5zbmFwc2hvdFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVJlcG9zaXRvcnkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnbmFtZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc25hcHNob3QvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbmFwc2hvdC5kZWxldGVfcmVwb3NpdG9yeScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXJhbXMubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydyZXBvc2l0b3J5JywgJ3NuYXBzaG90J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucmVwb3NpdG9yeS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90LnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc25hcHNob3QuZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnk6IHBhcmFtcy5yZXBvc2l0b3J5LFxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBwYXJhbXMuc25hcHNob3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZXBvc2l0b3J5KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ25hbWUnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBpZiAocGFyYW1zLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fc25hcHNob3QvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3NuYXBzaG90JztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NuYXBzaG90LmdldF9yZXBvc2l0b3J5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwb3NpdG9yeUFuYWx5emUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsncmVwb3NpdG9yeSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NuYXBzaG90LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5yZXBvc2l0b3J5LnRvU3RyaW5nKCkpfS9fYW5hbHl6ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc25hcHNob3QucmVwb3NpdG9yeV9hbmFseXplJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnk6IHBhcmFtcy5yZXBvc2l0b3J5XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwb3NpdG9yeVZlcmlmeUludGVncml0eShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc25hcHNob3QvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9L192ZXJpZnlfaW50ZWdyaXR5YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbmFwc2hvdC5yZXBvc2l0b3J5X3ZlcmlmeV9pbnRlZ3JpdHknLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGFyYW1zLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXN0b3JlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3JlcG9zaXRvcnknLCAnc25hcHNob3QnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydmZWF0dXJlX3N0YXRlcycsICdpZ25vcmVfaW5kZXhfc2V0dGluZ3MnLCAnaWdub3JlX3VuYXZhaWxhYmxlJywgJ2luY2x1ZGVfYWxpYXNlcycsICdpbmNsdWRlX2dsb2JhbF9zdGF0ZScsICdpbmRleF9zZXR0aW5ncycsICdpbmRpY2VzJywgJ3BhcnRpYWwnLCAncmVuYW1lX3BhdHRlcm4nLCAncmVuYW1lX3JlcGxhY2VtZW50J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3NuYXBzaG90LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5yZXBvc2l0b3J5LnRvU3RyaW5nKCkpfS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuc25hcHNob3QudG9TdHJpbmcoKSl9L19yZXN0b3JlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzbmFwc2hvdC5yZXN0b3JlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHJlcG9zaXRvcnk6IHBhcmFtcy5yZXBvc2l0b3J5LFxuICAgICAgICAgICAgICAgIHNuYXBzaG90OiBwYXJhbXMuc25hcHNob3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGF0dXMocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsncmVwb3NpdG9yeScsICdzbmFwc2hvdCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMucmVwb3NpdG9yeSAhPSBudWxsICYmIHBhcmFtcy5zbmFwc2hvdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucmVwb3NpdG9yeS50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNuYXBzaG90LnRvU3RyaW5nKCkpfS9fc3RhdHVzYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMucmVwb3NpdG9yeSAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSBgL19zbmFwc2hvdC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMucmVwb3NpdG9yeS50b1N0cmluZygpKX0vX3N0YXR1c2A7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHBhdGggPSAnL19zbmFwc2hvdC9fc3RhdHVzJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NuYXBzaG90LnN0YXR1cycsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICByZXBvc2l0b3J5OiBwYXJhbXMucmVwb3NpdG9yeSxcbiAgICAgICAgICAgICAgICBzbmFwc2hvdDogcGFyYW1zLnNuYXBzaG90XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdmVyaWZ5UmVwb3NpdG9yeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyduYW1lJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc25hcHNob3QvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm5hbWUudG9TdHJpbmcoKSl9L192ZXJpZnlgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NuYXBzaG90LnZlcmlmeV9yZXBvc2l0b3J5JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtcy5uYW1lXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTbmFwc2hvdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNuYXBzaG90LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/sql.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/sql.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Sql {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async clearCursor(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['cursor'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_sql/close';\n        const meta = {\n            name: 'sql.clear_cursor'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteAsync(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_sql/async/delete/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'sql.delete_async',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAsync(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_sql/async/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'sql.get_async',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getAsyncStatus(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_sql/async/status/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'sql.get_async_status',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async query(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['catalog', 'columnar', 'cursor', 'fetch_size', 'filter', 'query', 'request_timeout', 'page_timeout', 'time_zone', 'field_multi_value_leniency', 'runtime_mappings', 'wait_for_completion_timeout', 'params', 'keep_alive', 'keep_on_completion', 'index_using_frozen'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_sql';\n        const meta = {\n            name: 'sql.query'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async translate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['fetch_size', 'filter', 'query', 'time_zone'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_sql/translate';\n        const meta = {\n            name: 'sql.translate'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Sql;\n//# sourceMappingURL=sql.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zcWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5Q0FBeUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUNBQXlDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHlDQUF5QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3NxbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgU3FsIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBjbGVhckN1cnNvcihwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnY3Vyc29yJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NxbC9jbG9zZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc3FsLmNsZWFyX2N1cnNvcidcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVBc3luYyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc3FsL2FzeW5jL2RlbGV0ZS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzcWwuZGVsZXRlX2FzeW5jJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRBc3luYyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc3FsL2FzeW5jLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NxbC5nZXRfYXN5bmMnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldEFzeW5jU3RhdHVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zcWwvYXN5bmMvc3RhdHVzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NxbC5nZXRfYXN5bmNfc3RhdHVzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBxdWVyeShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnY2F0YWxvZycsICdjb2x1bW5hcicsICdjdXJzb3InLCAnZmV0Y2hfc2l6ZScsICdmaWx0ZXInLCAncXVlcnknLCAncmVxdWVzdF90aW1lb3V0JywgJ3BhZ2VfdGltZW91dCcsICd0aW1lX3pvbmUnLCAnZmllbGRfbXVsdGlfdmFsdWVfbGVuaWVuY3knLCAncnVudGltZV9tYXBwaW5ncycsICd3YWl0X2Zvcl9jb21wbGV0aW9uX3RpbWVvdXQnLCAncGFyYW1zJywgJ2tlZXBfYWxpdmUnLCAna2VlcF9vbl9jb21wbGV0aW9uJywgJ2luZGV4X3VzaW5nX2Zyb3plbiddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zcWwnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NxbC5xdWVyeSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB0cmFuc2xhdGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2ZldGNoX3NpemUnLCAnZmlsdGVyJywgJ3F1ZXJ5JywgJ3RpbWVfem9uZSddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3NxbC90cmFuc2xhdGUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3NxbC50cmFuc2xhdGUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTcWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zcWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/sql.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ssl.js":
/*!****************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/ssl.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Ssl {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async certificates(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ssl/certificates';\n        const meta = {\n            name: 'ssl.certificates'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Ssl;\n//# sourceMappingURL=ssl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zc2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zc2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFNzbCB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgY2VydGlmaWNhdGVzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL19zc2wvY2VydGlmaWNhdGVzJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzc2wuY2VydGlmaWNhdGVzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3NsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3NsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ssl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Synonyms {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteSynonym(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'synonyms.delete_synonym',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteSynonymRule(params, options) {\n        const acceptedPath = ['set_id', 'rule_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'synonyms.delete_synonym_rule',\n            pathParts: {\n                set_id: params.set_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSynonym(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'synonyms.get_synonym',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSynonymRule(params, options) {\n        const acceptedPath = ['set_id', 'rule_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'synonyms.get_synonym_rule',\n            pathParts: {\n                set_id: params.set_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSynonymsSets(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_synonyms';\n        const meta = {\n            name: 'synonyms.get_synonyms_sets'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putSynonym(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['synonyms_set'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_synonyms/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'synonyms.put_synonym',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putSynonymRule(params, options) {\n        const acceptedPath = ['set_id', 'rule_id'];\n        const acceptedBody = ['synonyms'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_synonyms/${encodeURIComponent(params.set_id.toString())}/${encodeURIComponent(params.rule_id.toString())}`;\n        const meta = {\n            name: 'synonyms.put_synonym_rule',\n            pathParts: {\n                set_id: params.set_id,\n                rule_id: params.rule_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Synonyms;\n//# sourceMappingURL=synonyms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zeW5vbnltcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBNkMsR0FBRyw4Q0FBOEM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkNBQTZDLEdBQUcsOENBQThDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx5Q0FBeUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2Q0FBNkMsR0FBRyw4Q0FBOEM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS9zeW5vbnltcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgU3lub255bXMge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZVN5bm9ueW0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnREVMRVRFJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3N5bm9ueW1zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3N5bm9ueW1zLmRlbGV0ZV9zeW5vbnltJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVTeW5vbnltUnVsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydzZXRfaWQnLCAncnVsZV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc3lub255bXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNldF9pZC50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJ1bGVfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5vbnltcy5kZWxldGVfc3lub255bV9ydWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHNldF9pZDogcGFyYW1zLnNldF9pZCxcbiAgICAgICAgICAgICAgICBydWxlX2lkOiBwYXJhbXMucnVsZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN5bm9ueW0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3N5bm9ueW1zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3N5bm9ueW1zLmdldF9zeW5vbnltJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTeW5vbnltUnVsZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydzZXRfaWQnLCAncnVsZV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fc3lub255bXMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnNldF9pZC50b1N0cmluZygpKX0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnJ1bGVfaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5vbnltcy5nZXRfc3lub255bV9ydWxlJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHNldF9pZDogcGFyYW1zLnNldF9pZCxcbiAgICAgICAgICAgICAgICBydWxlX2lkOiBwYXJhbXMucnVsZV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFN5bm9ueW1zU2V0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fc3lub255bXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3N5bm9ueW1zLmdldF9zeW5vbnltc19zZXRzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHB1dFN5bm9ueW0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydzeW5vbnltc19zZXQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL19zeW5vbnltcy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5vbnltcy5wdXRfc3lub255bScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0U3lub255bVJ1bGUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnc2V0X2lkJywgJ3J1bGVfaWQnXTtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRCb2R5ID0gWydzeW5vbnltcyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3N5bm9ueW1zLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5zZXRfaWQudG9TdHJpbmcoKSl9LyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5ydWxlX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnc3lub255bXMucHV0X3N5bm9ueW1fcnVsZScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBzZXRfaWQ6IHBhcmFtcy5zZXRfaWQsXG4gICAgICAgICAgICAgICAgcnVsZV9pZDogcGFyYW1zLnJ1bGVfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFN5bm9ueW1zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lub255bXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/tasks.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/tasks.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Tasks {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cancel(params, options) {\n        const acceptedPath = ['task_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_id != null) {\n            method = 'POST';\n            path = `/_tasks/${encodeURIComponent(params.task_id.toString())}/_cancel`;\n        }\n        else {\n            method = 'POST';\n            path = '/_tasks/_cancel';\n        }\n        const meta = {\n            name: 'tasks.cancel',\n            pathParts: {\n                task_id: params.task_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['task_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_tasks/${encodeURIComponent(params.task_id.toString())}`;\n        const meta = {\n            name: 'tasks.get',\n            pathParts: {\n                task_id: params.task_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async list(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_tasks';\n        const meta = {\n            name: 'tasks.list'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Tasks;\n//# sourceMappingURL=tasks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS90YXNrcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOENBQThDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBOEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvdGFza3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFRhc2tzIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBjYW5jZWwocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndGFza19pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMudGFza19pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fdGFza3MvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhc2tfaWQudG9TdHJpbmcoKSl9L19jYW5jZWxgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3Rhc2tzL19jYW5jZWwnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAndGFza3MuY2FuY2VsJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRhc2tfaWQ6IHBhcmFtcy50YXNrX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3Rhc2tfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3Rhc2tzLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50YXNrX2lkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAndGFza3MuZ2V0JyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRhc2tfaWQ6IHBhcmFtcy50YXNrX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fdGFza3MnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3Rhc2tzLmxpc3QnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBUYXNrcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhc2tzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/tasks.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function TermsEnumApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['field', 'size', 'timeout', 'case_insensitive', 'index_filter', 'string', 'search_after'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_terms_enum`;\n    const meta = {\n        name: 'terms_enum',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = TermsEnumApi;\n//# sourceMappingURL=terms_enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS90ZXJtc19lbnVtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDRDQUE0QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvdGVybXNfZW51bS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gVGVybXNFbnVtQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2ZpZWxkJywgJ3NpemUnLCAndGltZW91dCcsICdjYXNlX2luc2Vuc2l0aXZlJywgJ2luZGV4X2ZpbHRlcicsICdzdHJpbmcnLCAnc2VhcmNoX2FmdGVyJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fdGVybXNfZW51bWA7XG4gICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgbmFtZTogJ3Rlcm1zX2VudW0nLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gVGVybXNFbnVtQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVybXNfZW51bS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js":
/*!************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function TermvectorsApi(params, options) {\n    const acceptedPath = ['index', 'id'];\n    const acceptedBody = ['doc', 'filter', 'per_field_analyzer'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null && params.id != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_termvectors/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_termvectors`;\n    }\n    const meta = {\n        name: 'termvectors',\n        pathParts: {\n            index: params.index,\n            id: params.id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = TermvectorsApi;\n//# sourceMappingURL=termvectors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS90ZXJtdmVjdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0Q0FBNEMsZ0JBQWdCLHlDQUF5QztBQUN4SDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQTRDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUNBQXVDO0FBQ2pGO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvdGVybXZlY3RvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIFRlcm12ZWN0b3JzQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaW5kZXgnLCAnaWQnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RvYycsICdmaWx0ZXInLCAncGVyX2ZpZWxkX2FuYWx5emVyJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICBsZXQgYm9keTtcbiAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1ldGhvZCA9ICcnO1xuICAgIGxldCBwYXRoID0gJyc7XG4gICAgaWYgKHBhcmFtcy5pbmRleCAhPSBudWxsICYmIHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L190ZXJtdmVjdG9ycy8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L190ZXJtdmVjdG9yc2A7XG4gICAgfVxuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICd0ZXJtdmVjdG9ycycsXG4gICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgaW5kZXg6IHBhcmFtcy5pbmRleCxcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gVGVybXZlY3RvcnNBcGk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZXJtdmVjdG9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass TextStructure {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async findFieldStructure(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_text_structure/find_field_structure';\n        const meta = {\n            name: 'text_structure.find_field_structure'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async findMessageStructure(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_text_structure/find_message_structure';\n        const meta = {\n            name: 'text_structure.find_message_structure'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async findStructure(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['text_files'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_text_structure/find_structure';\n        const meta = {\n            name: 'text_structure.find_structure'\n        };\n        return await this.transport.request({ path, method, querystring, bulkBody: body, meta }, options);\n    }\n    async testGrokPattern(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['grok_pattern', 'text'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_text_structure/test_grok_pattern';\n        const meta = {\n            name: 'text_structure.test_grok_pattern'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = TextStructure;\n//# sourceMappingURL=text_structure.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS90ZXh0X3N0cnVjdHVyZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlEQUFpRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9hcGkvdGV4dF9zdHJ1Y3R1cmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFRleHRTdHJ1Y3R1cmUge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGZpbmRGaWVsZFN0cnVjdHVyZShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL190ZXh0X3N0cnVjdHVyZS9maW5kX2ZpZWxkX3N0cnVjdHVyZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAndGV4dF9zdHJ1Y3R1cmUuZmluZF9maWVsZF9zdHJ1Y3R1cmUnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZmluZE1lc3NhZ2VTdHJ1Y3R1cmUocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fdGV4dF9zdHJ1Y3R1cmUvZmluZF9tZXNzYWdlX3N0cnVjdHVyZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAndGV4dF9zdHJ1Y3R1cmUuZmluZF9tZXNzYWdlX3N0cnVjdHVyZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBmaW5kU3RydWN0dXJlKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ3RleHRfZmlsZXMnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsZXQgYm9keSA9IChfYSA9IHBhcmFtcy5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHkgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fdGV4dF9zdHJ1Y3R1cmUvZmluZF9zdHJ1Y3R1cmUnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RleHRfc3RydWN0dXJlLmZpbmRfc3RydWN0dXJlJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJ1bGtCb2R5OiBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyB0ZXN0R3Jva1BhdHRlcm4ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2dyb2tfcGF0dGVybicsICd0ZXh0J107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fdGV4dF9zdHJ1Y3R1cmUvdGVzdF9ncm9rX3BhdHRlcm4nO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RleHRfc3RydWN0dXJlLnRlc3RfZ3Jva19wYXR0ZXJuJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVGV4dFN0cnVjdHVyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleHRfc3RydWN0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/transform.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/transform.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Transform {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        const meta = {\n            name: 'transform.delete_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getNodeStats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_transform/_node_stats';\n        const meta = {\n            name: 'transform.get_node_stats'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = 'GET';\n            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_transform';\n        }\n        const meta = {\n            name: 'transform.get_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getTransformStats(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stats`;\n        const meta = {\n            name: 'transform.get_transform_stats',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async previewTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', 'pivot', 'source', 'settings', 'sync', 'retention_policy', 'latest'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_transform/_preview';\n        }\n        const meta = {\n            name: 'transform.preview_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', 'latest', '_meta', 'pivot', 'retention_policy', 'settings', 'source', 'sync'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        const meta = {\n            name: 'transform.put_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async resetTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_reset`;\n        const meta = {\n            name: 'transform.reset_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async scheduleNowTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_schedule_now`;\n        const meta = {\n            name: 'transform.schedule_now_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async startTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_start`;\n        const meta = {\n            name: 'transform.start_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stopTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stop`;\n        const meta = {\n            name: 'transform.stop_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', '_meta', 'source', 'settings', 'sync', 'retention_policy'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_update`;\n        const meta = {\n            name: 'transform.update_transform',\n            pathParts: {\n                transform_id: params.transform_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async upgradeTransforms(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_transform/_upgrade';\n        const meta = {\n            name: 'transform.upgrade_transforms'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Transform;\n//# sourceMappingURL=transform.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS90cmFuc2Zvcm0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQW1EO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1EQUFtRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFtRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtREFBbUQ7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbURBQW1EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3RyYW5zZm9ybS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidHJhbnNwb3J0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVUcmFuc2Zvcm0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndHJhbnNmb3JtX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0RFTEVURSc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL190cmFuc2Zvcm0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRyYW5zZm9ybV9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RyYW5zZm9ybS5kZWxldGVfdHJhbnNmb3JtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldE5vZGVTdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL190cmFuc2Zvcm0vX25vZGVfc3RhdHMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RyYW5zZm9ybS5nZXRfbm9kZV9zdGF0cydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2Zvcm0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndHJhbnNmb3JtX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy50cmFuc2Zvcm1faWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fdHJhbnNmb3JtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3RyYW5zZm9ybSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0uZ2V0X3RyYW5zZm9ybScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1faWQ6IHBhcmFtcy50cmFuc2Zvcm1faWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc2Zvcm1TdGF0cyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0cmFuc2Zvcm1faWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3RyYW5zZm9ybS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudHJhbnNmb3JtX2lkLnRvU3RyaW5nKCkpfS9fc3RhdHNgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RyYW5zZm9ybS5nZXRfdHJhbnNmb3JtX3N0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHByZXZpZXdUcmFuc2Zvcm0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndHJhbnNmb3JtX2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZGVzdCcsICdkZXNjcmlwdGlvbicsICdmcmVxdWVuY3knLCAncGl2b3QnLCAnc291cmNlJywgJ3NldHRpbmdzJywgJ3N5bmMnLCAncmV0ZW50aW9uX3BvbGljeScsICdsYXRlc3QnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy50cmFuc2Zvcm1faWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gYm9keSAhPSBudWxsID8gJ1BPU1QnIDogJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fdHJhbnNmb3JtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9L19wcmV2aWV3YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1ldGhvZCA9IGJvZHkgIT0gbnVsbCA/ICdQT1NUJyA6ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9ICcvX3RyYW5zZm9ybS9fcHJldmlldyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0ucHJldmlld190cmFuc2Zvcm0nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtX2lkOiBwYXJhbXMudHJhbnNmb3JtX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgcHV0VHJhbnNmb3JtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3RyYW5zZm9ybV9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2Rlc3QnLCAnZGVzY3JpcHRpb24nLCAnZnJlcXVlbmN5JywgJ2xhdGVzdCcsICdfbWV0YScsICdwaXZvdCcsICdyZXRlbnRpb25fcG9saWN5JywgJ3NldHRpbmdzJywgJ3NvdXJjZScsICdzeW5jJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fdHJhbnNmb3JtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0ucHV0X3RyYW5zZm9ybScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1faWQ6IHBhcmFtcy50cmFuc2Zvcm1faWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyByZXNldFRyYW5zZm9ybShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0cmFuc2Zvcm1faWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL190cmFuc2Zvcm0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRyYW5zZm9ybV9pZC50b1N0cmluZygpKX0vX3Jlc2V0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0ucmVzZXRfdHJhbnNmb3JtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHNjaGVkdWxlTm93VHJhbnNmb3JtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3RyYW5zZm9ybV9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3RyYW5zZm9ybS8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMudHJhbnNmb3JtX2lkLnRvU3RyaW5nKCkpfS9fc2NoZWR1bGVfbm93YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0uc2NoZWR1bGVfbm93X3RyYW5zZm9ybScsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1faWQ6IHBhcmFtcy50cmFuc2Zvcm1faWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydFRyYW5zZm9ybShwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0cmFuc2Zvcm1faWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL190cmFuc2Zvcm0vJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRyYW5zZm9ybV9pZC50b1N0cmluZygpKX0vX3N0YXJ0YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0uc3RhcnRfdHJhbnNmb3JtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3BUcmFuc2Zvcm0ocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsndHJhbnNmb3JtX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fdHJhbnNmb3JtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9L19zdG9wYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0uc3RvcF90cmFuc2Zvcm0nLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtX2lkOiBwYXJhbXMudHJhbnNmb3JtX2lkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlVHJhbnNmb3JtKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3RyYW5zZm9ybV9pZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2Rlc3QnLCAnZGVzY3JpcHRpb24nLCAnZnJlcXVlbmN5JywgJ19tZXRhJywgJ3NvdXJjZScsICdzZXR0aW5ncycsICdzeW5jJywgJ3JldGVudGlvbl9wb2xpY3knXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IGJvZHkgIT09IG51bGwgJiYgYm9keSAhPT0gdm9pZCAwID8gYm9keSA6IHt9O1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fdHJhbnNmb3JtLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy50cmFuc2Zvcm1faWQudG9TdHJpbmcoKSl9L191cGRhdGVgO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3RyYW5zZm9ybS51cGRhdGVfdHJhbnNmb3JtJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybV9pZDogcGFyYW1zLnRyYW5zZm9ybV9pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZ3JhZGVUcmFuc2Zvcm1zKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fdHJhbnNmb3JtL191cGdyYWRlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd0cmFuc2Zvcm0udXBncmFkZV90cmFuc2Zvcm1zJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNmb3JtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/transform.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/update.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function UpdateApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['detect_noop', 'doc', 'doc_as_upsert', 'script', 'scripted_upsert', '_source', 'upsert'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_update/${encodeURIComponent(params.id.toString())}`;\n    const meta = {\n        name: 'update',\n        pathParts: {\n            id: params.id,\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = UpdateApi;\n//# sourceMappingURL=update.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS91cGRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDLFdBQVcseUNBQXlDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVDQUF1QztBQUNqRjtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3VwZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gVXBkYXRlQXBpKHBhcmFtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnaWQnLCAnaW5kZXgnXTtcbiAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2RldGVjdF9ub29wJywgJ2RvYycsICdkb2NfYXNfdXBzZXJ0JywgJ3NjcmlwdCcsICdzY3JpcHRlZF91cHNlcnQnLCAnX3NvdXJjZScsICd1cHNlcnQnXTtcbiAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgIGxldCBib2R5O1xuICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGFjY2VwdGVkQm9keS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBib2R5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgY29uc3QgcGF0aCA9IGAvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmluZGV4LnRvU3RyaW5nKCkpfS9fdXBkYXRlLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICd1cGRhdGUnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBpbmRleDogcGFyYW1zLmluZGV4XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFVwZGF0ZUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function UpdateByQueryApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['max_docs', 'query', 'script', 'slice', 'conflicts'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_update_by_query`;\n    const meta = {\n        name: 'update_by_query',\n        pathParts: {\n            index: params.index\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = UpdateByQueryApi;\n//# sourceMappingURL=update_by_query.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS91cGRhdGVfYnlfcXVlcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQTRDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS91cGRhdGVfYnlfcXVlcnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmFzeW5jIGZ1bmN0aW9uIFVwZGF0ZUJ5UXVlcnlBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpbmRleCddO1xuICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnbWF4X2RvY3MnLCAncXVlcnknLCAnc2NyaXB0JywgJ3NsaWNlJywgJ2NvbmZsaWN0cyddO1xuICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICBjb25zdCBwYXRoID0gYC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaW5kZXgudG9TdHJpbmcoKSl9L191cGRhdGVfYnlfcXVlcnlgO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgIG5hbWU6ICd1cGRhdGVfYnlfcXVlcnknLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJhbXMuaW5kZXhcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gVXBkYXRlQnlRdWVyeUFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZV9ieV9xdWVyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nasync function UpdateByQueryRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_update_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    const meta = {\n        name: 'update_by_query_rethrottle',\n        pathParts: {\n            task_id: params.task_id\n        }\n    };\n    return await this.transport.request({ path, method, querystring, body, meta }, options);\n}\nexports[\"default\"] = UpdateByQueryRethrottleApi;\n//# sourceMappingURL=update_by_query_rethrottle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS91cGRhdGVfYnlfcXVlcnlfcmV0aHJvdHRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOENBQThDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx1Q0FBdUM7QUFDakY7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS91cGRhdGVfYnlfcXVlcnlfcmV0aHJvdHRsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuYXN5bmMgZnVuY3Rpb24gVXBkYXRlQnlRdWVyeVJldGhyb3R0bGVBcGkocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWyd0YXNrX2lkJ107XG4gICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gJ1BPU1QnO1xuICAgIGNvbnN0IHBhdGggPSBgL191cGRhdGVfYnlfcXVlcnkvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLnRhc2tfaWQudG9TdHJpbmcoKSl9L19yZXRocm90dGxlYDtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICBuYW1lOiAndXBkYXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGUnLFxuICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgIHRhc2tfaWQ6IHBhcmFtcy50YXNrX2lkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFVwZGF0ZUJ5UXVlcnlSZXRocm90dGxlQXBpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/watcher.js":
/*!********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/watcher.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Watcher {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async ackWatch(params, options) {\n        const acceptedPath = ['watch_id', 'action_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.watch_id != null && params.action_id != null) {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack/${encodeURIComponent(params.action_id.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack`;\n        }\n        const meta = {\n            name: 'watcher.ack_watch',\n            pathParts: {\n                watch_id: params.watch_id,\n                action_id: params.action_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async activateWatch(params, options) {\n        const acceptedPath = ['watch_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_activate`;\n        const meta = {\n            name: 'watcher.activate_watch',\n            pathParts: {\n                watch_id: params.watch_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deactivateWatch(params, options) {\n        const acceptedPath = ['watch_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_deactivate`;\n        const meta = {\n            name: 'watcher.deactivate_watch',\n            pathParts: {\n                watch_id: params.watch_id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async deleteWatch(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'watcher.delete_watch',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async executeWatch(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['action_modes', 'alternative_input', 'ignore_condition', 'record_execution', 'simulated_actions', 'trigger_data', 'watch'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}/_execute`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_watcher/watch/_execute';\n        }\n        const meta = {\n            name: 'watcher.execute_watch',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_watcher/settings';\n        const meta = {\n            name: 'watcher.get_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async getWatch(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'watcher.get_watch',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async putWatch(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['actions', 'condition', 'input', 'metadata', 'throttle_period', 'transform', 'trigger'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        const meta = {\n            name: 'watcher.put_watch',\n            pathParts: {\n                id: params.id\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async queryWatches(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['from', 'size', 'query', 'sort', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_watcher/_query/watches';\n        const meta = {\n            name: 'watcher.query_watches'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_watcher/_start';\n        const meta = {\n            name: 'watcher.start'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.metric != null) {\n            method = 'GET';\n            path = `/_watcher/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_watcher/stats';\n        }\n        const meta = {\n            name: 'watcher.stats',\n            pathParts: {\n                metric: params.metric\n            }\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_watcher/_stop';\n        const meta = {\n            name: 'watcher.stop'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async updateSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_watcher/settings';\n        const meta = {\n            name: 'watcher.update_settings'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Watcher;\n//# sourceMappingURL=watcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS93YXRjaGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQStDLFFBQVEsZ0RBQWdEO0FBQzdJO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywrQ0FBK0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtDQUErQztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywrQ0FBK0M7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseUNBQXlDO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5Q0FBeUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx5Q0FBeUM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsdUNBQXVDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZDQUE2QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHVDQUF1QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3dhdGNoZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFdhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0cmFuc3BvcnRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgfVxuICAgIGFzeW5jIGFja1dhdGNoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3dhdGNoX2lkJywgJ2FjdGlvbl9pZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy53YXRjaF9pZCAhPSBudWxsICYmIHBhcmFtcy5hY3Rpb25faWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fd2F0Y2hlci93YXRjaC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMud2F0Y2hfaWQudG9TdHJpbmcoKSl9L19hY2svJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmFjdGlvbl9pZC50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICBwYXRoID0gYC9fd2F0Y2hlci93YXRjaC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMud2F0Y2hfaWQudG9TdHJpbmcoKSl9L19hY2tgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnd2F0Y2hlci5hY2tfd2F0Y2gnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgd2F0Y2hfaWQ6IHBhcmFtcy53YXRjaF9pZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25faWQ6IHBhcmFtcy5hY3Rpb25faWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhY3RpdmF0ZVdhdGNoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ3dhdGNoX2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL193YXRjaGVyL3dhdGNoLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy53YXRjaF9pZC50b1N0cmluZygpKX0vX2FjdGl2YXRlYDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLmFjdGl2YXRlX3dhdGNoJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHdhdGNoX2lkOiBwYXJhbXMud2F0Y2hfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWFjdGl2YXRlV2F0Y2gocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFsnd2F0Y2hfaWQnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3dhdGNoZXIvd2F0Y2gvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLndhdGNoX2lkLnRvU3RyaW5nKCkpfS9fZGVhY3RpdmF0ZWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnd2F0Y2hlci5kZWFjdGl2YXRlX3dhdGNoJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIHdhdGNoX2lkOiBwYXJhbXMud2F0Y2hfaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVXYXRjaChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBjb25zdCBwYXRoID0gYC9fd2F0Y2hlci93YXRjaC8ke2VuY29kZVVSSUNvbXBvbmVudChwYXJhbXMuaWQudG9TdHJpbmcoKSl9YDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLmRlbGV0ZV93YXRjaCcsXG4gICAgICAgICAgICBwYXRoUGFydHM6IHtcbiAgICAgICAgICAgICAgICBpZDogcGFyYW1zLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVdhdGNoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnYWN0aW9uX21vZGVzJywgJ2FsdGVybmF0aXZlX2lucHV0JywgJ2lnbm9yZV9jb25kaXRpb24nLCAncmVjb3JkX2V4ZWN1dGlvbicsICdzaW11bGF0ZWRfYWN0aW9ucycsICd0cmlnZ2VyX2RhdGEnLCAnd2F0Y2gnXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB1c2VyQm9keSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5ib2R5O1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VyQm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB1c2VyQm9keSAhPSBudWxsID8geyAuLi51c2VyQm9keSB9IDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZEJvZHkuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5ICE9PSBudWxsICYmIGJvZHkgIT09IHZvaWQgMCA/IGJvZHkgOiB7fTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgYm9keVtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBtZXRob2QgPSAnJztcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgaWYgKHBhcmFtcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgICAgIHBhdGggPSBgL193YXRjaGVyL3dhdGNoLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX0vX2V4ZWN1dGVgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BVVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fd2F0Y2hlci93YXRjaC9fZXhlY3V0ZSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLmV4ZWN1dGVfd2F0Y2gnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNldHRpbmdzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbXTtcbiAgICAgICAgY29uc3QgcXVlcnlzdHJpbmcgPSB7fTtcbiAgICAgICAgY29uc3QgYm9keSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zICE9PSBudWxsICYmIHBhcmFtcyAhPT0gdm9pZCAwID8gcGFyYW1zIDoge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3dhdGNoZXIvc2V0dGluZ3MnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3dhdGNoZXIuZ2V0X3NldHRpbmdzJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFdhdGNoKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ2lkJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGFjY2VwdGVkUGF0aC5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChrZXkgIT09ICdib2R5Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBxdWVyeXN0cmluZ1trZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgL193YXRjaGVyL3dhdGNoLyR7ZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtcy5pZC50b1N0cmluZygpKX1gO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3dhdGNoZXIuZ2V0X3dhdGNoJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIGlkOiBwYXJhbXMuaWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBwdXRXYXRjaChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gWydpZCddO1xuICAgICAgICBjb25zdCBhY2NlcHRlZEJvZHkgPSBbJ2FjdGlvbnMnLCAnY29uZGl0aW9uJywgJ2lucHV0JywgJ21ldGFkYXRhJywgJ3Rocm90dGxlX3BlcmlvZCcsICd0cmFuc2Zvcm0nLCAndHJpZ2dlciddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHVzZXJCb2R5ID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLmJvZHk7XG4gICAgICAgIGxldCBib2R5O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJCb2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IHVzZXJCb2R5ICE9IG51bGwgPyB7IC4uLnVzZXJCb2R5IH0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUFVUJztcbiAgICAgICAgY29uc3QgcGF0aCA9IGAvX3dhdGNoZXIvd2F0Y2gvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLmlkLnRvU3RyaW5nKCkpfWA7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnd2F0Y2hlci5wdXRfd2F0Y2gnLFxuICAgICAgICAgICAgcGF0aFBhcnRzOiB7XG4gICAgICAgICAgICAgICAgaWQ6IHBhcmFtcy5pZFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHF1ZXJ5V2F0Y2hlcyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkQm9keSA9IFsnZnJvbScsICdzaXplJywgJ3F1ZXJ5JywgJ3NvcnQnLCAnc2VhcmNoX2FmdGVyJ107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY29uc3QgdXNlckJvZHkgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYm9keTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlckJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBib2R5ID0gdXNlckJvZHkgIT0gbnVsbCA/IHsgLi4udXNlckJvZHkgfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRCb2R5LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gYm9keSAhPT0gbnVsbCAmJiBib2R5ICE9PSB2b2lkIDAgPyBib2R5IDoge307XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIGJvZHlba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSBib2R5ICE9IG51bGwgPyAnUE9TVCcgOiAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3dhdGNoZXIvX3F1ZXJ5L3dhdGNoZXMnO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3dhdGNoZXIucXVlcnlfd2F0Y2hlcydcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBzdGFydChwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3dhdGNoZXIvX3N0YXJ0JztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLnN0YXJ0J1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0YXRzKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY2NlcHRlZFBhdGggPSBbJ21ldHJpYyddO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWV0aG9kID0gJyc7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGlmIChwYXJhbXMubWV0cmljICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICAgICAgcGF0aCA9IGAvX3dhdGNoZXIvc3RhdHMvJHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zLm1ldHJpYy50b1N0cmluZygpKX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBwYXRoID0gJy9fd2F0Y2hlci9zdGF0cyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLnN0YXRzJyxcbiAgICAgICAgICAgIHBhdGhQYXJ0czoge1xuICAgICAgICAgICAgICAgIG1ldHJpYzogcGFyYW1zLm1ldHJpY1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVxdWVzdCh7IHBhdGgsIG1ldGhvZCwgcXVlcnlzdHJpbmcsIGJvZHksIG1ldGEgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHN0b3AocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGNvbnN0IHBhdGggPSAnL193YXRjaGVyL19zdG9wJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd3YXRjaGVyLnN0b3AnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlU2V0dGluZ3MocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQVVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9fd2F0Y2hlci9zZXR0aW5ncyc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBuYW1lOiAnd2F0Y2hlci51cGRhdGVfc2V0dGluZ3MnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBXYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2F0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/watcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/xpack.js":
/*!******************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/api/xpack.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Xpack {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async info(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_xpack';\n        const meta = {\n            name: 'xpack.info'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n    async usage(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_xpack/usage';\n        const meta = {\n            name: 'xpack.usage'\n        };\n        return await this.transport.request({ path, method, querystring, body, meta }, options);\n    }\n}\nexports[\"default\"] = Xpack;\n//# sourceMappingURL=xpack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2FwaS94cGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1Q0FBdUM7QUFDckY7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy9lbGFzdGljc2VhcmNoL2xpYi9hcGkvYXBpL3hwYWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBYcGFjayB7XG4gICAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB9XG4gICAgYXN5bmMgaW5mbyhwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYWNjZXB0ZWRQYXRoID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXJ5c3RyaW5nID0ge307XG4gICAgICAgIGNvbnN0IGJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyAhPT0gbnVsbCAmJiBwYXJhbXMgIT09IHZvaWQgMCA/IHBhcmFtcyA6IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmIChhY2NlcHRlZFBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ICE9PSAnYm9keScpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcXVlcnlzdHJpbmdba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdHRVQnO1xuICAgICAgICBjb25zdCBwYXRoID0gJy9feHBhY2snO1xuICAgICAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICAgICAgbmFtZTogJ3hwYWNrLmluZm8nXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zcG9ydC5yZXF1ZXN0KHsgcGF0aCwgbWV0aG9kLCBxdWVyeXN0cmluZywgYm9keSwgbWV0YSB9LCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgdXNhZ2UocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY2VwdGVkUGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBxdWVyeXN0cmluZyA9IHt9O1xuICAgICAgICBjb25zdCBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0ZWRQYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSAhPT0gJ2JvZHknKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHF1ZXJ5c3RyaW5nW2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgY29uc3QgcGF0aCA9ICcvX3hwYWNrL3VzYWdlJztcbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6ICd4cGFjay51c2FnZSdcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNwb3J0LnJlcXVlc3QoeyBwYXRoLCBtZXRob2QsIHF1ZXJ5c3RyaW5nLCBib2R5LCBtZXRhIH0sIG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFhwYWNrO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eHBhY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/xpack.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/api/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/api/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-misused-new */\n/* eslint-disable @typescript-eslint/no-extraneous-class */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// This file was automatically generated by elastic/elastic-client-generator-js\n// DO NOT MODIFY IT BY HAND. Instead, modify the source open api file,\n// and elastic/elastic-client-generator-js to regenerate this file again.\nconst async_search_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/async_search */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/async_search.js\"));\nconst autoscaling_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/autoscaling */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js\"));\nconst bulk_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/bulk */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/bulk.js\"));\nconst capabilities_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/capabilities */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/capabilities.js\"));\nconst cat_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/cat */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cat.js\"));\nconst ccr_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ccr */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ccr.js\"));\nconst clear_scroll_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/clear_scroll */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js\"));\nconst close_point_in_time_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/close_point_in_time */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js\"));\nconst cluster_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/cluster */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/cluster.js\"));\nconst connector_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/connector */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/connector.js\"));\nconst count_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/count */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/count.js\"));\nconst create_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/create */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/create.js\"));\nconst dangling_indices_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/dangling_indices */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js\"));\nconst delete_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/delete */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete.js\"));\nconst delete_by_query_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/delete_by_query */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js\"));\nconst delete_by_query_rethrottle_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/delete_by_query_rethrottle */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js\"));\nconst delete_script_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/delete_script */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js\"));\nconst enrich_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/enrich */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/enrich.js\"));\nconst eql_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/eql */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/eql.js\"));\nconst esql_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/esql */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/esql.js\"));\nconst exists_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/exists */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists.js\"));\nconst exists_source_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/exists_source */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js\"));\nconst explain_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/explain */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/explain.js\"));\nconst features_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/features */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/features.js\"));\nconst field_caps_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/field_caps */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js\"));\nconst fleet_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/fleet */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/fleet.js\"));\nconst get_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/get */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get.js\"));\nconst get_script_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/get_script */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script.js\"));\nconst get_script_context_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/get_script_context */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js\"));\nconst get_script_languages_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/get_script_languages */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js\"));\nconst get_source_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/get_source */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/get_source.js\"));\nconst graph_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/graph */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/graph.js\"));\nconst health_report_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/health_report */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/health_report.js\"));\nconst ilm_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ilm */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ilm.js\"));\nconst index_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/index */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/index.js\"));\nconst indices_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/indices */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/indices.js\"));\nconst inference_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/inference */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/inference.js\"));\nconst info_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/info */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/info.js\"));\nconst ingest_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ingest */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ingest.js\"));\nconst knn_search_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/knn_search */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js\"));\nconst license_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/license */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/license.js\"));\nconst logstash_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/logstash */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/logstash.js\"));\nconst mget_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/mget */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mget.js\"));\nconst migration_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/migration */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/migration.js\"));\nconst ml_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ml */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ml.js\"));\nconst monitoring_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/monitoring */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js\"));\nconst msearch_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/msearch */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch.js\"));\nconst msearch_template_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/msearch_template */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js\"));\nconst mtermvectors_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/mtermvectors */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js\"));\nconst nodes_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/nodes */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/nodes.js\"));\nconst open_point_in_time_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/open_point_in_time */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js\"));\nconst ping_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ping */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ping.js\"));\nconst profiling_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/profiling */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/profiling.js\"));\nconst put_script_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/put_script */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/put_script.js\"));\nconst query_rules_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/query_rules */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/query_rules.js\"));\nconst rank_eval_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/rank_eval */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js\"));\nconst reindex_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/reindex */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex.js\"));\nconst reindex_rethrottle_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/reindex_rethrottle */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js\"));\nconst render_search_template_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/render_search_template */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js\"));\nconst rollup_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/rollup */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/rollup.js\"));\nconst scripts_painless_execute_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/scripts_painless_execute */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js\"));\nconst scroll_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/scroll */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/scroll.js\"));\nconst search_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/search */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search.js\"));\nconst search_application_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/search_application */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_application.js\"));\nconst search_mvt_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/search_mvt */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js\"));\nconst search_shards_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/search_shards */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js\"));\nconst search_template_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/search_template */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/search_template.js\"));\nconst searchable_snapshots_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/searchable_snapshots */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js\"));\nconst security_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/security */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/security.js\"));\nconst shutdown_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/shutdown */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js\"));\nconst simulate_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/simulate */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/simulate.js\"));\nconst slm_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/slm */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/slm.js\"));\nconst snapshot_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/snapshot */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js\"));\nconst sql_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/sql */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/sql.js\"));\nconst ssl_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/ssl */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/ssl.js\"));\nconst synonyms_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/synonyms */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/synonyms.js\"));\nconst tasks_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/tasks */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/tasks.js\"));\nconst terms_enum_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/terms_enum */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js\"));\nconst termvectors_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/termvectors */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js\"));\nconst text_structure_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/text_structure */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js\"));\nconst transform_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/transform */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/transform.js\"));\nconst update_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/update */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update.js\"));\nconst update_by_query_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/update_by_query */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js\"));\nconst update_by_query_rethrottle_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/update_by_query_rethrottle */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js\"));\nconst watcher_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/watcher */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/watcher.js\"));\nconst xpack_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api/xpack */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/api/xpack.js\"));\nconst kAsyncSearch = Symbol('AsyncSearch');\nconst kAutoscaling = Symbol('Autoscaling');\nconst kCat = Symbol('Cat');\nconst kCcr = Symbol('Ccr');\nconst kCluster = Symbol('Cluster');\nconst kConnector = Symbol('Connector');\nconst kDanglingIndices = Symbol('DanglingIndices');\nconst kEnrich = Symbol('Enrich');\nconst kEql = Symbol('Eql');\nconst kEsql = Symbol('Esql');\nconst kFeatures = Symbol('Features');\nconst kFleet = Symbol('Fleet');\nconst kGraph = Symbol('Graph');\nconst kIlm = Symbol('Ilm');\nconst kIndices = Symbol('Indices');\nconst kInference = Symbol('Inference');\nconst kIngest = Symbol('Ingest');\nconst kLicense = Symbol('License');\nconst kLogstash = Symbol('Logstash');\nconst kMigration = Symbol('Migration');\nconst kMl = Symbol('Ml');\nconst kMonitoring = Symbol('Monitoring');\nconst kNodes = Symbol('Nodes');\nconst kProfiling = Symbol('Profiling');\nconst kQueryRules = Symbol('QueryRules');\nconst kRollup = Symbol('Rollup');\nconst kSearchApplication = Symbol('SearchApplication');\nconst kSearchableSnapshots = Symbol('SearchableSnapshots');\nconst kSecurity = Symbol('Security');\nconst kShutdown = Symbol('Shutdown');\nconst kSimulate = Symbol('Simulate');\nconst kSlm = Symbol('Slm');\nconst kSnapshot = Symbol('Snapshot');\nconst kSql = Symbol('Sql');\nconst kSsl = Symbol('Ssl');\nconst kSynonyms = Symbol('Synonyms');\nconst kTasks = Symbol('Tasks');\nconst kTextStructure = Symbol('TextStructure');\nconst kTransform = Symbol('Transform');\nconst kWatcher = Symbol('Watcher');\nconst kXpack = Symbol('Xpack');\nclass API {\n    constructor() {\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _d, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _e, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _f, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _g, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _h, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _j, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _k, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _l, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _m, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _o, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _p, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _q, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _r, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _s, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _t, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _u, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _v, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _w, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _x, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _y, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _z, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _0, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _1, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _2, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _3, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _4, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _5, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _6, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _7, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _8, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _9, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _10, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _11, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _12, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _13, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _14, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _15, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _16, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[kAsyncSearch] = null;\n        this[kAutoscaling] = null;\n        this[kCat] = null;\n        this[kCcr] = null;\n        this[kCluster] = null;\n        this[kConnector] = null;\n        this[kDanglingIndices] = null;\n        this[kEnrich] = null;\n        this[kEql] = null;\n        this[kEsql] = null;\n        this[kFeatures] = null;\n        this[kFleet] = null;\n        this[kGraph] = null;\n        this[kIlm] = null;\n        this[kIndices] = null;\n        this[kInference] = null;\n        this[kIngest] = null;\n        this[kLicense] = null;\n        this[kLogstash] = null;\n        this[kMigration] = null;\n        this[kMl] = null;\n        this[kMonitoring] = null;\n        this[kNodes] = null;\n        this[kProfiling] = null;\n        this[kQueryRules] = null;\n        this[kRollup] = null;\n        this[kSearchApplication] = null;\n        this[kSearchableSnapshots] = null;\n        this[kSecurity] = null;\n        this[kShutdown] = null;\n        this[kSimulate] = null;\n        this[kSlm] = null;\n        this[kSnapshot] = null;\n        this[kSql] = null;\n        this[kSsl] = null;\n        this[kSynonyms] = null;\n        this[kTasks] = null;\n        this[kTextStructure] = null;\n        this[kTransform] = null;\n        this[kWatcher] = null;\n        this[kXpack] = null;\n    }\n}\nexports[\"default\"] = API;\n_a = kAsyncSearch, _b = kAutoscaling, _c = kCat, _d = kCcr, _e = kCluster, _f = kConnector, _g = kDanglingIndices, _h = kEnrich, _j = kEql, _k = kEsql, _l = kFeatures, _m = kFleet, _o = kGraph, _p = kIlm, _q = kIndices, _r = kInference, _s = kIngest, _t = kLicense, _u = kLogstash, _v = kMigration, _w = kMl, _x = kMonitoring, _y = kNodes, _z = kProfiling, _0 = kQueryRules, _1 = kRollup, _2 = kSearchApplication, _3 = kSearchableSnapshots, _4 = kSecurity, _5 = kShutdown, _6 = kSimulate, _7 = kSlm, _8 = kSnapshot, _9 = kSql, _10 = kSsl, _11 = kSynonyms, _12 = kTasks, _13 = kTextStructure, _14 = kTransform, _15 = kWatcher, _16 = kXpack;\nAPI.prototype.bulk = bulk_1.default;\nAPI.prototype.capabilities = capabilities_1.default;\nAPI.prototype.clearScroll = clear_scroll_1.default;\nAPI.prototype.closePointInTime = close_point_in_time_1.default;\nAPI.prototype.count = count_1.default;\nAPI.prototype.create = create_1.default;\nAPI.prototype.delete = delete_1.default;\nAPI.prototype.deleteByQuery = delete_by_query_1.default;\nAPI.prototype.deleteByQueryRethrottle = delete_by_query_rethrottle_1.default;\nAPI.prototype.deleteScript = delete_script_1.default;\nAPI.prototype.exists = exists_1.default;\nAPI.prototype.existsSource = exists_source_1.default;\nAPI.prototype.explain = explain_1.default;\nAPI.prototype.fieldCaps = field_caps_1.default;\nAPI.prototype.get = get_1.default;\nAPI.prototype.getScript = get_script_1.default;\nAPI.prototype.getScriptContext = get_script_context_1.default;\nAPI.prototype.getScriptLanguages = get_script_languages_1.default;\nAPI.prototype.getSource = get_source_1.default;\nAPI.prototype.healthReport = health_report_1.default;\nAPI.prototype.index = index_1.default;\nAPI.prototype.info = info_1.default;\nAPI.prototype.knnSearch = knn_search_1.default;\nAPI.prototype.mget = mget_1.default;\nAPI.prototype.msearch = msearch_1.default;\nAPI.prototype.msearchTemplate = msearch_template_1.default;\nAPI.prototype.mtermvectors = mtermvectors_1.default;\nAPI.prototype.openPointInTime = open_point_in_time_1.default;\nAPI.prototype.ping = ping_1.default;\nAPI.prototype.putScript = put_script_1.default;\nAPI.prototype.rankEval = rank_eval_1.default;\nAPI.prototype.reindex = reindex_1.default;\nAPI.prototype.reindexRethrottle = reindex_rethrottle_1.default;\nAPI.prototype.renderSearchTemplate = render_search_template_1.default;\nAPI.prototype.scriptsPainlessExecute = scripts_painless_execute_1.default;\nAPI.prototype.scroll = scroll_1.default;\nAPI.prototype.search = search_1.default;\nAPI.prototype.searchMvt = search_mvt_1.default;\nAPI.prototype.searchShards = search_shards_1.default;\nAPI.prototype.searchTemplate = search_template_1.default;\nAPI.prototype.termsEnum = terms_enum_1.default;\nAPI.prototype.termvectors = termvectors_1.default;\nAPI.prototype.update = update_1.default;\nAPI.prototype.updateByQuery = update_by_query_1.default;\nAPI.prototype.updateByQueryRethrottle = update_by_query_rethrottle_1.default;\nObject.defineProperties(API.prototype, {\n    asyncSearch: {\n        get() { return this[kAsyncSearch] === null ? (this[kAsyncSearch] = new async_search_1.default(this.transport)) : this[kAsyncSearch]; }\n    },\n    autoscaling: {\n        get() { return this[kAutoscaling] === null ? (this[kAutoscaling] = new autoscaling_1.default(this.transport)) : this[kAutoscaling]; }\n    },\n    cat: {\n        get() { return this[kCat] === null ? (this[kCat] = new cat_1.default(this.transport)) : this[kCat]; }\n    },\n    ccr: {\n        get() { return this[kCcr] === null ? (this[kCcr] = new ccr_1.default(this.transport)) : this[kCcr]; }\n    },\n    cluster: {\n        get() { return this[kCluster] === null ? (this[kCluster] = new cluster_1.default(this.transport)) : this[kCluster]; }\n    },\n    connector: {\n        get() { return this[kConnector] === null ? (this[kConnector] = new connector_1.default(this.transport)) : this[kConnector]; }\n    },\n    danglingIndices: {\n        get() { return this[kDanglingIndices] === null ? (this[kDanglingIndices] = new dangling_indices_1.default(this.transport)) : this[kDanglingIndices]; }\n    },\n    enrich: {\n        get() { return this[kEnrich] === null ? (this[kEnrich] = new enrich_1.default(this.transport)) : this[kEnrich]; }\n    },\n    eql: {\n        get() { return this[kEql] === null ? (this[kEql] = new eql_1.default(this.transport)) : this[kEql]; }\n    },\n    esql: {\n        get() { return this[kEsql] === null ? (this[kEsql] = new esql_1.default(this.transport)) : this[kEsql]; }\n    },\n    features: {\n        get() { return this[kFeatures] === null ? (this[kFeatures] = new features_1.default(this.transport)) : this[kFeatures]; }\n    },\n    fleet: {\n        get() { return this[kFleet] === null ? (this[kFleet] = new fleet_1.default(this.transport)) : this[kFleet]; }\n    },\n    graph: {\n        get() { return this[kGraph] === null ? (this[kGraph] = new graph_1.default(this.transport)) : this[kGraph]; }\n    },\n    ilm: {\n        get() { return this[kIlm] === null ? (this[kIlm] = new ilm_1.default(this.transport)) : this[kIlm]; }\n    },\n    indices: {\n        get() { return this[kIndices] === null ? (this[kIndices] = new indices_1.default(this.transport)) : this[kIndices]; }\n    },\n    inference: {\n        get() { return this[kInference] === null ? (this[kInference] = new inference_1.default(this.transport)) : this[kInference]; }\n    },\n    ingest: {\n        get() { return this[kIngest] === null ? (this[kIngest] = new ingest_1.default(this.transport)) : this[kIngest]; }\n    },\n    license: {\n        get() { return this[kLicense] === null ? (this[kLicense] = new license_1.default(this.transport)) : this[kLicense]; }\n    },\n    logstash: {\n        get() { return this[kLogstash] === null ? (this[kLogstash] = new logstash_1.default(this.transport)) : this[kLogstash]; }\n    },\n    migration: {\n        get() { return this[kMigration] === null ? (this[kMigration] = new migration_1.default(this.transport)) : this[kMigration]; }\n    },\n    ml: {\n        get() { return this[kMl] === null ? (this[kMl] = new ml_1.default(this.transport)) : this[kMl]; }\n    },\n    monitoring: {\n        get() { return this[kMonitoring] === null ? (this[kMonitoring] = new monitoring_1.default(this.transport)) : this[kMonitoring]; }\n    },\n    nodes: {\n        get() { return this[kNodes] === null ? (this[kNodes] = new nodes_1.default(this.transport)) : this[kNodes]; }\n    },\n    profiling: {\n        get() { return this[kProfiling] === null ? (this[kProfiling] = new profiling_1.default(this.transport)) : this[kProfiling]; }\n    },\n    queryRules: {\n        get() { return this[kQueryRules] === null ? (this[kQueryRules] = new query_rules_1.default(this.transport)) : this[kQueryRules]; }\n    },\n    rollup: {\n        get() { return this[kRollup] === null ? (this[kRollup] = new rollup_1.default(this.transport)) : this[kRollup]; }\n    },\n    searchApplication: {\n        get() { return this[kSearchApplication] === null ? (this[kSearchApplication] = new search_application_1.default(this.transport)) : this[kSearchApplication]; }\n    },\n    searchableSnapshots: {\n        get() { return this[kSearchableSnapshots] === null ? (this[kSearchableSnapshots] = new searchable_snapshots_1.default(this.transport)) : this[kSearchableSnapshots]; }\n    },\n    security: {\n        get() { return this[kSecurity] === null ? (this[kSecurity] = new security_1.default(this.transport)) : this[kSecurity]; }\n    },\n    shutdown: {\n        get() { return this[kShutdown] === null ? (this[kShutdown] = new shutdown_1.default(this.transport)) : this[kShutdown]; }\n    },\n    simulate: {\n        get() { return this[kSimulate] === null ? (this[kSimulate] = new simulate_1.default(this.transport)) : this[kSimulate]; }\n    },\n    slm: {\n        get() { return this[kSlm] === null ? (this[kSlm] = new slm_1.default(this.transport)) : this[kSlm]; }\n    },\n    snapshot: {\n        get() { return this[kSnapshot] === null ? (this[kSnapshot] = new snapshot_1.default(this.transport)) : this[kSnapshot]; }\n    },\n    sql: {\n        get() { return this[kSql] === null ? (this[kSql] = new sql_1.default(this.transport)) : this[kSql]; }\n    },\n    ssl: {\n        get() { return this[kSsl] === null ? (this[kSsl] = new ssl_1.default(this.transport)) : this[kSsl]; }\n    },\n    synonyms: {\n        get() { return this[kSynonyms] === null ? (this[kSynonyms] = new synonyms_1.default(this.transport)) : this[kSynonyms]; }\n    },\n    tasks: {\n        get() { return this[kTasks] === null ? (this[kTasks] = new tasks_1.default(this.transport)) : this[kTasks]; }\n    },\n    textStructure: {\n        get() { return this[kTextStructure] === null ? (this[kTextStructure] = new text_structure_1.default(this.transport)) : this[kTextStructure]; }\n    },\n    transform: {\n        get() { return this[kTransform] === null ? (this[kTransform] = new transform_1.default(this.transport)) : this[kTransform]; }\n    },\n    watcher: {\n        get() { return this[kWatcher] === null ? (this[kWatcher] = new watcher_1.default(this.transport)) : this[kWatcher]; }\n    },\n    xpack: {\n        get() { return this[kXpack] === null ? (this[kXpack] = new xpack_1.default(this.transport)) : this[kXpack]; }\n    }\n});\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvYXBpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxtQkFBTyxDQUFDLG1HQUFvQjtBQUMzRSw4Q0FBOEMsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDekUsdUNBQXVDLG1CQUFPLENBQUMsbUZBQVk7QUFDM0QsK0NBQStDLG1CQUFPLENBQUMsbUdBQW9CO0FBQzNFLHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFXO0FBQ3pELHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFXO0FBQ3pELCtDQUErQyxtQkFBTyxDQUFDLG1HQUFvQjtBQUMzRSxzREFBc0QsbUJBQU8sQ0FBQyxpSEFBMkI7QUFDekYsMENBQTBDLG1CQUFPLENBQUMseUZBQWU7QUFDakUsNENBQTRDLG1CQUFPLENBQUMsNkZBQWlCO0FBQ3JFLHdDQUF3QyxtQkFBTyxDQUFDLHFGQUFhO0FBQzdELHlDQUF5QyxtQkFBTyxDQUFDLHVGQUFjO0FBQy9ELG1EQUFtRCxtQkFBTyxDQUFDLDJHQUF3QjtBQUNuRix5Q0FBeUMsbUJBQU8sQ0FBQyx1RkFBYztBQUMvRCxrREFBa0QsbUJBQU8sQ0FBQyx5R0FBdUI7QUFDakYsNkRBQTZELG1CQUFPLENBQUMsK0hBQWtDO0FBQ3ZHLGdEQUFnRCxtQkFBTyxDQUFDLHFHQUFxQjtBQUM3RSx5Q0FBeUMsbUJBQU8sQ0FBQyx1RkFBYztBQUMvRCxzQ0FBc0MsbUJBQU8sQ0FBQyxpRkFBVztBQUN6RCx1Q0FBdUMsbUJBQU8sQ0FBQyxtRkFBWTtBQUMzRCx5Q0FBeUMsbUJBQU8sQ0FBQyx1RkFBYztBQUMvRCxnREFBZ0QsbUJBQU8sQ0FBQyxxR0FBcUI7QUFDN0UsMENBQTBDLG1CQUFPLENBQUMseUZBQWU7QUFDakUsMkNBQTJDLG1CQUFPLENBQUMsMkZBQWdCO0FBQ25FLDZDQUE2QyxtQkFBTyxDQUFDLCtGQUFrQjtBQUN2RSx3Q0FBd0MsbUJBQU8sQ0FBQyxxRkFBYTtBQUM3RCxzQ0FBc0MsbUJBQU8sQ0FBQyxpRkFBVztBQUN6RCw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUscURBQXFELG1CQUFPLENBQUMsK0dBQTBCO0FBQ3ZGLHVEQUF1RCxtQkFBTyxDQUFDLG1IQUE0QjtBQUMzRiw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUsd0NBQXdDLG1CQUFPLENBQUMscUZBQWE7QUFDN0QsZ0RBQWdELG1CQUFPLENBQUMscUdBQXFCO0FBQzdFLHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFXO0FBQ3pELHdDQUF3QyxtQkFBTyxDQUFDLHFGQUFhO0FBQzdELDBDQUEwQyxtQkFBTyxDQUFDLHlGQUFlO0FBQ2pFLDRDQUE0QyxtQkFBTyxDQUFDLDZGQUFpQjtBQUNyRSx1Q0FBdUMsbUJBQU8sQ0FBQyxtRkFBWTtBQUMzRCx5Q0FBeUMsbUJBQU8sQ0FBQyx1RkFBYztBQUMvRCw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUsMENBQTBDLG1CQUFPLENBQUMseUZBQWU7QUFDakUsMkNBQTJDLG1CQUFPLENBQUMsMkZBQWdCO0FBQ25FLHVDQUF1QyxtQkFBTyxDQUFDLG1GQUFZO0FBQzNELDRDQUE0QyxtQkFBTyxDQUFDLDZGQUFpQjtBQUNyRSxxQ0FBcUMsbUJBQU8sQ0FBQywrRUFBVTtBQUN2RCw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUsMENBQTBDLG1CQUFPLENBQUMseUZBQWU7QUFDakUsbURBQW1ELG1CQUFPLENBQUMsMkdBQXdCO0FBQ25GLCtDQUErQyxtQkFBTyxDQUFDLG1HQUFvQjtBQUMzRSx3Q0FBd0MsbUJBQU8sQ0FBQyxxRkFBYTtBQUM3RCxxREFBcUQsbUJBQU8sQ0FBQywrR0FBMEI7QUFDdkYsdUNBQXVDLG1CQUFPLENBQUMsbUZBQVk7QUFDM0QsNENBQTRDLG1CQUFPLENBQUMsNkZBQWlCO0FBQ3JFLDZDQUE2QyxtQkFBTyxDQUFDLCtGQUFrQjtBQUN2RSw4Q0FBOEMsbUJBQU8sQ0FBQyxpR0FBbUI7QUFDekUsNENBQTRDLG1CQUFPLENBQUMsNkZBQWlCO0FBQ3JFLDBDQUEwQyxtQkFBTyxDQUFDLHlGQUFlO0FBQ2pFLHFEQUFxRCxtQkFBTyxDQUFDLCtHQUEwQjtBQUN2Rix5REFBeUQsbUJBQU8sQ0FBQyx1SEFBOEI7QUFDL0YseUNBQXlDLG1CQUFPLENBQUMsdUZBQWM7QUFDL0QsMkRBQTJELG1CQUFPLENBQUMsMkhBQWdDO0FBQ25HLHlDQUF5QyxtQkFBTyxDQUFDLHVGQUFjO0FBQy9ELHlDQUF5QyxtQkFBTyxDQUFDLHVGQUFjO0FBQy9ELHFEQUFxRCxtQkFBTyxDQUFDLCtHQUEwQjtBQUN2Riw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUsZ0RBQWdELG1CQUFPLENBQUMscUdBQXFCO0FBQzdFLGtEQUFrRCxtQkFBTyxDQUFDLHlHQUF1QjtBQUNqRix1REFBdUQsbUJBQU8sQ0FBQyxtSEFBNEI7QUFDM0YsMkNBQTJDLG1CQUFPLENBQUMsMkZBQWdCO0FBQ25FLDJDQUEyQyxtQkFBTyxDQUFDLDJGQUFnQjtBQUNuRSwyQ0FBMkMsbUJBQU8sQ0FBQywyRkFBZ0I7QUFDbkUsc0NBQXNDLG1CQUFPLENBQUMsaUZBQVc7QUFDekQsMkNBQTJDLG1CQUFPLENBQUMsMkZBQWdCO0FBQ25FLHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFXO0FBQ3pELHNDQUFzQyxtQkFBTyxDQUFDLGlGQUFXO0FBQ3pELDJDQUEyQyxtQkFBTyxDQUFDLDJGQUFnQjtBQUNuRSx3Q0FBd0MsbUJBQU8sQ0FBQyxxRkFBYTtBQUM3RCw2Q0FBNkMsbUJBQU8sQ0FBQywrRkFBa0I7QUFDdkUsOENBQThDLG1CQUFPLENBQUMsaUdBQW1CO0FBQ3pFLGlEQUFpRCxtQkFBTyxDQUFDLHVHQUFzQjtBQUMvRSw0Q0FBNEMsbUJBQU8sQ0FBQyw2RkFBaUI7QUFDckUseUNBQXlDLG1CQUFPLENBQUMsdUZBQWM7QUFDL0Qsa0RBQWtELG1CQUFPLENBQUMseUdBQXVCO0FBQ2pGLDZEQUE2RCxtQkFBTyxDQUFDLCtIQUFrQztBQUN2RywwQ0FBMEMsbUJBQU8sQ0FBQyx5RkFBZTtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyxxRkFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2FwaS9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wLCBfMSwgXzIsIF8zLCBfNCwgXzUsIF82LCBfNywgXzgsIF85LCBfMTAsIF8xMSwgXzEyLCBfMTMsIF8xNCwgXzE1LCBfMTY7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L2V4cG9ydCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtbmV3ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzcyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4vLyBUaGlzIGZpbGUgd2FzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IGVsYXN0aWMvZWxhc3RpYy1jbGllbnQtZ2VuZXJhdG9yLWpzXG4vLyBETyBOT1QgTU9ESUZZIElUIEJZIEhBTkQuIEluc3RlYWQsIG1vZGlmeSB0aGUgc291cmNlIG9wZW4gYXBpIGZpbGUsXG4vLyBhbmQgZWxhc3RpYy9lbGFzdGljLWNsaWVudC1nZW5lcmF0b3ItanMgdG8gcmVnZW5lcmF0ZSB0aGlzIGZpbGUgYWdhaW4uXG5jb25zdCBhc3luY19zZWFyY2hfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9hc3luY19zZWFyY2hcIikpO1xuY29uc3QgYXV0b3NjYWxpbmdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9hdXRvc2NhbGluZ1wiKSk7XG5jb25zdCBidWxrXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvYnVsa1wiKSk7XG5jb25zdCBjYXBhYmlsaXRpZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9jYXBhYmlsaXRpZXNcIikpO1xuY29uc3QgY2F0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvY2F0XCIpKTtcbmNvbnN0IGNjcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2NjclwiKSk7XG5jb25zdCBjbGVhcl9zY3JvbGxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9jbGVhcl9zY3JvbGxcIikpO1xuY29uc3QgY2xvc2VfcG9pbnRfaW5fdGltZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2Nsb3NlX3BvaW50X2luX3RpbWVcIikpO1xuY29uc3QgY2x1c3Rlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2NsdXN0ZXJcIikpO1xuY29uc3QgY29ubmVjdG9yXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvY29ubmVjdG9yXCIpKTtcbmNvbnN0IGNvdW50XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvY291bnRcIikpO1xuY29uc3QgY3JlYXRlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvY3JlYXRlXCIpKTtcbmNvbnN0IGRhbmdsaW5nX2luZGljZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9kYW5nbGluZ19pbmRpY2VzXCIpKTtcbmNvbnN0IGRlbGV0ZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2RlbGV0ZVwiKSk7XG5jb25zdCBkZWxldGVfYnlfcXVlcnlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9kZWxldGVfYnlfcXVlcnlcIikpO1xuY29uc3QgZGVsZXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9kZWxldGVfYnlfcXVlcnlfcmV0aHJvdHRsZVwiKSk7XG5jb25zdCBkZWxldGVfc2NyaXB0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZGVsZXRlX3NjcmlwdFwiKSk7XG5jb25zdCBlbnJpY2hfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9lbnJpY2hcIikpO1xuY29uc3QgZXFsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZXFsXCIpKTtcbmNvbnN0IGVzcWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9lc3FsXCIpKTtcbmNvbnN0IGV4aXN0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2V4aXN0c1wiKSk7XG5jb25zdCBleGlzdHNfc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZXhpc3RzX3NvdXJjZVwiKSk7XG5jb25zdCBleHBsYWluXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZXhwbGFpblwiKSk7XG5jb25zdCBmZWF0dXJlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2ZlYXR1cmVzXCIpKTtcbmNvbnN0IGZpZWxkX2NhcHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9maWVsZF9jYXBzXCIpKTtcbmNvbnN0IGZsZWV0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZmxlZXRcIikpO1xuY29uc3QgZ2V0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZ2V0XCIpKTtcbmNvbnN0IGdldF9zY3JpcHRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9nZXRfc2NyaXB0XCIpKTtcbmNvbnN0IGdldF9zY3JpcHRfY29udGV4dF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2dldF9zY3JpcHRfY29udGV4dFwiKSk7XG5jb25zdCBnZXRfc2NyaXB0X2xhbmd1YWdlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2dldF9zY3JpcHRfbGFuZ3VhZ2VzXCIpKTtcbmNvbnN0IGdldF9zb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9nZXRfc291cmNlXCIpKTtcbmNvbnN0IGdyYXBoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvZ3JhcGhcIikpO1xuY29uc3QgaGVhbHRoX3JlcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2hlYWx0aF9yZXBvcnRcIikpO1xuY29uc3QgaWxtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvaWxtXCIpKTtcbmNvbnN0IGluZGV4XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvaW5kZXhcIikpO1xuY29uc3QgaW5kaWNlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2luZGljZXNcIikpO1xuY29uc3QgaW5mZXJlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvaW5mZXJlbmNlXCIpKTtcbmNvbnN0IGluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9pbmZvXCIpKTtcbmNvbnN0IGluZ2VzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2luZ2VzdFwiKSk7XG5jb25zdCBrbm5fc2VhcmNoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkva25uX3NlYXJjaFwiKSk7XG5jb25zdCBsaWNlbnNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvbGljZW5zZVwiKSk7XG5jb25zdCBsb2dzdGFzaF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL2xvZ3N0YXNoXCIpKTtcbmNvbnN0IG1nZXRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9tZ2V0XCIpKTtcbmNvbnN0IG1pZ3JhdGlvbl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL21pZ3JhdGlvblwiKSk7XG5jb25zdCBtbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL21sXCIpKTtcbmNvbnN0IG1vbml0b3JpbmdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9tb25pdG9yaW5nXCIpKTtcbmNvbnN0IG1zZWFyY2hfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9tc2VhcmNoXCIpKTtcbmNvbnN0IG1zZWFyY2hfdGVtcGxhdGVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9tc2VhcmNoX3RlbXBsYXRlXCIpKTtcbmNvbnN0IG10ZXJtdmVjdG9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL210ZXJtdmVjdG9yc1wiKSk7XG5jb25zdCBub2Rlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL25vZGVzXCIpKTtcbmNvbnN0IG9wZW5fcG9pbnRfaW5fdGltZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL29wZW5fcG9pbnRfaW5fdGltZVwiKSk7XG5jb25zdCBwaW5nXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvcGluZ1wiKSk7XG5jb25zdCBwcm9maWxpbmdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9wcm9maWxpbmdcIikpO1xuY29uc3QgcHV0X3NjcmlwdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3B1dF9zY3JpcHRcIikpO1xuY29uc3QgcXVlcnlfcnVsZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9xdWVyeV9ydWxlc1wiKSk7XG5jb25zdCByYW5rX2V2YWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9yYW5rX2V2YWxcIikpO1xuY29uc3QgcmVpbmRleF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3JlaW5kZXhcIikpO1xuY29uc3QgcmVpbmRleF9yZXRocm90dGxlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvcmVpbmRleF9yZXRocm90dGxlXCIpKTtcbmNvbnN0IHJlbmRlcl9zZWFyY2hfdGVtcGxhdGVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9yZW5kZXJfc2VhcmNoX3RlbXBsYXRlXCIpKTtcbmNvbnN0IHJvbGx1cF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3JvbGx1cFwiKSk7XG5jb25zdCBzY3JpcHRzX3BhaW5sZXNzX2V4ZWN1dGVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9zY3JpcHRzX3BhaW5sZXNzX2V4ZWN1dGVcIikpO1xuY29uc3Qgc2Nyb2xsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc2Nyb2xsXCIpKTtcbmNvbnN0IHNlYXJjaF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3NlYXJjaFwiKSk7XG5jb25zdCBzZWFyY2hfYXBwbGljYXRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9zZWFyY2hfYXBwbGljYXRpb25cIikpO1xuY29uc3Qgc2VhcmNoX212dF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3NlYXJjaF9tdnRcIikpO1xuY29uc3Qgc2VhcmNoX3NoYXJkc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3NlYXJjaF9zaGFyZHNcIikpO1xuY29uc3Qgc2VhcmNoX3RlbXBsYXRlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc2VhcmNoX3RlbXBsYXRlXCIpKTtcbmNvbnN0IHNlYXJjaGFibGVfc25hcHNob3RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc2VhcmNoYWJsZV9zbmFwc2hvdHNcIikpO1xuY29uc3Qgc2VjdXJpdHlfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS9zZWN1cml0eVwiKSk7XG5jb25zdCBzaHV0ZG93bl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3NodXRkb3duXCIpKTtcbmNvbnN0IHNpbXVsYXRlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc2ltdWxhdGVcIikpO1xuY29uc3Qgc2xtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc2xtXCIpKTtcbmNvbnN0IHNuYXBzaG90XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc25hcHNob3RcIikpO1xuY29uc3Qgc3FsXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvc3FsXCIpKTtcbmNvbnN0IHNzbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3NzbFwiKSk7XG5jb25zdCBzeW5vbnltc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3N5bm9ueW1zXCIpKTtcbmNvbnN0IHRhc2tzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvdGFza3NcIikpO1xuY29uc3QgdGVybXNfZW51bV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3Rlcm1zX2VudW1cIikpO1xuY29uc3QgdGVybXZlY3RvcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS90ZXJtdmVjdG9yc1wiKSk7XG5jb25zdCB0ZXh0X3N0cnVjdHVyZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3RleHRfc3RydWN0dXJlXCIpKTtcbmNvbnN0IHRyYW5zZm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3RyYW5zZm9ybVwiKSk7XG5jb25zdCB1cGRhdGVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS91cGRhdGVcIikpO1xuY29uc3QgdXBkYXRlX2J5X3F1ZXJ5XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvdXBkYXRlX2J5X3F1ZXJ5XCIpKTtcbmNvbnN0IHVwZGF0ZV9ieV9xdWVyeV9yZXRocm90dGxlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGkvdXBkYXRlX2J5X3F1ZXJ5X3JldGhyb3R0bGVcIikpO1xuY29uc3Qgd2F0Y2hlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYXBpL3dhdGNoZXJcIikpO1xuY29uc3QgeHBhY2tfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FwaS94cGFja1wiKSk7XG5jb25zdCBrQXN5bmNTZWFyY2ggPSBTeW1ib2woJ0FzeW5jU2VhcmNoJyk7XG5jb25zdCBrQXV0b3NjYWxpbmcgPSBTeW1ib2woJ0F1dG9zY2FsaW5nJyk7XG5jb25zdCBrQ2F0ID0gU3ltYm9sKCdDYXQnKTtcbmNvbnN0IGtDY3IgPSBTeW1ib2woJ0NjcicpO1xuY29uc3Qga0NsdXN0ZXIgPSBTeW1ib2woJ0NsdXN0ZXInKTtcbmNvbnN0IGtDb25uZWN0b3IgPSBTeW1ib2woJ0Nvbm5lY3RvcicpO1xuY29uc3Qga0RhbmdsaW5nSW5kaWNlcyA9IFN5bWJvbCgnRGFuZ2xpbmdJbmRpY2VzJyk7XG5jb25zdCBrRW5yaWNoID0gU3ltYm9sKCdFbnJpY2gnKTtcbmNvbnN0IGtFcWwgPSBTeW1ib2woJ0VxbCcpO1xuY29uc3Qga0VzcWwgPSBTeW1ib2woJ0VzcWwnKTtcbmNvbnN0IGtGZWF0dXJlcyA9IFN5bWJvbCgnRmVhdHVyZXMnKTtcbmNvbnN0IGtGbGVldCA9IFN5bWJvbCgnRmxlZXQnKTtcbmNvbnN0IGtHcmFwaCA9IFN5bWJvbCgnR3JhcGgnKTtcbmNvbnN0IGtJbG0gPSBTeW1ib2woJ0lsbScpO1xuY29uc3Qga0luZGljZXMgPSBTeW1ib2woJ0luZGljZXMnKTtcbmNvbnN0IGtJbmZlcmVuY2UgPSBTeW1ib2woJ0luZmVyZW5jZScpO1xuY29uc3Qga0luZ2VzdCA9IFN5bWJvbCgnSW5nZXN0Jyk7XG5jb25zdCBrTGljZW5zZSA9IFN5bWJvbCgnTGljZW5zZScpO1xuY29uc3Qga0xvZ3N0YXNoID0gU3ltYm9sKCdMb2dzdGFzaCcpO1xuY29uc3Qga01pZ3JhdGlvbiA9IFN5bWJvbCgnTWlncmF0aW9uJyk7XG5jb25zdCBrTWwgPSBTeW1ib2woJ01sJyk7XG5jb25zdCBrTW9uaXRvcmluZyA9IFN5bWJvbCgnTW9uaXRvcmluZycpO1xuY29uc3Qga05vZGVzID0gU3ltYm9sKCdOb2RlcycpO1xuY29uc3Qga1Byb2ZpbGluZyA9IFN5bWJvbCgnUHJvZmlsaW5nJyk7XG5jb25zdCBrUXVlcnlSdWxlcyA9IFN5bWJvbCgnUXVlcnlSdWxlcycpO1xuY29uc3Qga1JvbGx1cCA9IFN5bWJvbCgnUm9sbHVwJyk7XG5jb25zdCBrU2VhcmNoQXBwbGljYXRpb24gPSBTeW1ib2woJ1NlYXJjaEFwcGxpY2F0aW9uJyk7XG5jb25zdCBrU2VhcmNoYWJsZVNuYXBzaG90cyA9IFN5bWJvbCgnU2VhcmNoYWJsZVNuYXBzaG90cycpO1xuY29uc3Qga1NlY3VyaXR5ID0gU3ltYm9sKCdTZWN1cml0eScpO1xuY29uc3Qga1NodXRkb3duID0gU3ltYm9sKCdTaHV0ZG93bicpO1xuY29uc3Qga1NpbXVsYXRlID0gU3ltYm9sKCdTaW11bGF0ZScpO1xuY29uc3Qga1NsbSA9IFN5bWJvbCgnU2xtJyk7XG5jb25zdCBrU25hcHNob3QgPSBTeW1ib2woJ1NuYXBzaG90Jyk7XG5jb25zdCBrU3FsID0gU3ltYm9sKCdTcWwnKTtcbmNvbnN0IGtTc2wgPSBTeW1ib2woJ1NzbCcpO1xuY29uc3Qga1N5bm9ueW1zID0gU3ltYm9sKCdTeW5vbnltcycpO1xuY29uc3Qga1Rhc2tzID0gU3ltYm9sKCdUYXNrcycpO1xuY29uc3Qga1RleHRTdHJ1Y3R1cmUgPSBTeW1ib2woJ1RleHRTdHJ1Y3R1cmUnKTtcbmNvbnN0IGtUcmFuc2Zvcm0gPSBTeW1ib2woJ1RyYW5zZm9ybScpO1xuY29uc3Qga1dhdGNoZXIgPSBTeW1ib2woJ1dhdGNoZXInKTtcbmNvbnN0IGtYcGFjayA9IFN5bWJvbCgnWHBhY2snKTtcbmNsYXNzIEFQSSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfYSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9iLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2MsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfZCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9lLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2YsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfZywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9oLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2osIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfaywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX20sIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfbywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9wLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3EsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfciwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9zLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3QsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfdSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF92LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3csIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfeCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF95LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3osIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfMCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXzIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfMywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF80LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXzUsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfNiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF83LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXzgsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfOSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xMCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xMSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xMiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xMywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xNCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xNSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8xNiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc1trQXN5bmNTZWFyY2hdID0gbnVsbDtcbiAgICAgICAgdGhpc1trQXV0b3NjYWxpbmddID0gbnVsbDtcbiAgICAgICAgdGhpc1trQ2F0XSA9IG51bGw7XG4gICAgICAgIHRoaXNba0Njcl0gPSBudWxsO1xuICAgICAgICB0aGlzW2tDbHVzdGVyXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0Nvbm5lY3Rvcl0gPSBudWxsO1xuICAgICAgICB0aGlzW2tEYW5nbGluZ0luZGljZXNdID0gbnVsbDtcbiAgICAgICAgdGhpc1trRW5yaWNoXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0VxbF0gPSBudWxsO1xuICAgICAgICB0aGlzW2tFc3FsXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0ZlYXR1cmVzXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0ZsZWV0XSA9IG51bGw7XG4gICAgICAgIHRoaXNba0dyYXBoXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0lsbV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tJbmRpY2VzXSA9IG51bGw7XG4gICAgICAgIHRoaXNba0luZmVyZW5jZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tJbmdlc3RdID0gbnVsbDtcbiAgICAgICAgdGhpc1trTGljZW5zZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tMb2dzdGFzaF0gPSBudWxsO1xuICAgICAgICB0aGlzW2tNaWdyYXRpb25dID0gbnVsbDtcbiAgICAgICAgdGhpc1trTWxdID0gbnVsbDtcbiAgICAgICAgdGhpc1trTW9uaXRvcmluZ10gPSBudWxsO1xuICAgICAgICB0aGlzW2tOb2Rlc10gPSBudWxsO1xuICAgICAgICB0aGlzW2tQcm9maWxpbmddID0gbnVsbDtcbiAgICAgICAgdGhpc1trUXVlcnlSdWxlc10gPSBudWxsO1xuICAgICAgICB0aGlzW2tSb2xsdXBdID0gbnVsbDtcbiAgICAgICAgdGhpc1trU2VhcmNoQXBwbGljYXRpb25dID0gbnVsbDtcbiAgICAgICAgdGhpc1trU2VhcmNoYWJsZVNuYXBzaG90c10gPSBudWxsO1xuICAgICAgICB0aGlzW2tTZWN1cml0eV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tTaHV0ZG93bl0gPSBudWxsO1xuICAgICAgICB0aGlzW2tTaW11bGF0ZV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tTbG1dID0gbnVsbDtcbiAgICAgICAgdGhpc1trU25hcHNob3RdID0gbnVsbDtcbiAgICAgICAgdGhpc1trU3FsXSA9IG51bGw7XG4gICAgICAgIHRoaXNba1NzbF0gPSBudWxsO1xuICAgICAgICB0aGlzW2tTeW5vbnltc10gPSBudWxsO1xuICAgICAgICB0aGlzW2tUYXNrc10gPSBudWxsO1xuICAgICAgICB0aGlzW2tUZXh0U3RydWN0dXJlXSA9IG51bGw7XG4gICAgICAgIHRoaXNba1RyYW5zZm9ybV0gPSBudWxsO1xuICAgICAgICB0aGlzW2tXYXRjaGVyXSA9IG51bGw7XG4gICAgICAgIHRoaXNba1hwYWNrXSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQVBJO1xuX2EgPSBrQXN5bmNTZWFyY2gsIF9iID0ga0F1dG9zY2FsaW5nLCBfYyA9IGtDYXQsIF9kID0ga0NjciwgX2UgPSBrQ2x1c3RlciwgX2YgPSBrQ29ubmVjdG9yLCBfZyA9IGtEYW5nbGluZ0luZGljZXMsIF9oID0ga0VucmljaCwgX2ogPSBrRXFsLCBfayA9IGtFc3FsLCBfbCA9IGtGZWF0dXJlcywgX20gPSBrRmxlZXQsIF9vID0ga0dyYXBoLCBfcCA9IGtJbG0sIF9xID0ga0luZGljZXMsIF9yID0ga0luZmVyZW5jZSwgX3MgPSBrSW5nZXN0LCBfdCA9IGtMaWNlbnNlLCBfdSA9IGtMb2dzdGFzaCwgX3YgPSBrTWlncmF0aW9uLCBfdyA9IGtNbCwgX3ggPSBrTW9uaXRvcmluZywgX3kgPSBrTm9kZXMsIF96ID0ga1Byb2ZpbGluZywgXzAgPSBrUXVlcnlSdWxlcywgXzEgPSBrUm9sbHVwLCBfMiA9IGtTZWFyY2hBcHBsaWNhdGlvbiwgXzMgPSBrU2VhcmNoYWJsZVNuYXBzaG90cywgXzQgPSBrU2VjdXJpdHksIF81ID0ga1NodXRkb3duLCBfNiA9IGtTaW11bGF0ZSwgXzcgPSBrU2xtLCBfOCA9IGtTbmFwc2hvdCwgXzkgPSBrU3FsLCBfMTAgPSBrU3NsLCBfMTEgPSBrU3lub255bXMsIF8xMiA9IGtUYXNrcywgXzEzID0ga1RleHRTdHJ1Y3R1cmUsIF8xNCA9IGtUcmFuc2Zvcm0sIF8xNSA9IGtXYXRjaGVyLCBfMTYgPSBrWHBhY2s7XG5BUEkucHJvdG90eXBlLmJ1bGsgPSBidWxrXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuY2xlYXJTY3JvbGwgPSBjbGVhcl9zY3JvbGxfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5jbG9zZVBvaW50SW5UaW1lID0gY2xvc2VfcG9pbnRfaW5fdGltZV8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLmNvdW50ID0gY291bnRfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5jcmVhdGUgPSBjcmVhdGVfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5kZWxldGUgPSBkZWxldGVfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5kZWxldGVCeVF1ZXJ5ID0gZGVsZXRlX2J5X3F1ZXJ5XzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuZGVsZXRlQnlRdWVyeVJldGhyb3R0bGUgPSBkZWxldGVfYnlfcXVlcnlfcmV0aHJvdHRsZV8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLmRlbGV0ZVNjcmlwdCA9IGRlbGV0ZV9zY3JpcHRfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5leGlzdHMgPSBleGlzdHNfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5leGlzdHNTb3VyY2UgPSBleGlzdHNfc291cmNlXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuZXhwbGFpbiA9IGV4cGxhaW5fMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5maWVsZENhcHMgPSBmaWVsZF9jYXBzXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuZ2V0ID0gZ2V0XzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuZ2V0U2NyaXB0ID0gZ2V0X3NjcmlwdF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLmdldFNjcmlwdENvbnRleHQgPSBnZXRfc2NyaXB0X2NvbnRleHRfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5nZXRTY3JpcHRMYW5ndWFnZXMgPSBnZXRfc2NyaXB0X2xhbmd1YWdlc18xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLmdldFNvdXJjZSA9IGdldF9zb3VyY2VfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5oZWFsdGhSZXBvcnQgPSBoZWFsdGhfcmVwb3J0XzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuaW5kZXggPSBpbmRleF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLmluZm8gPSBpbmZvXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUua25uU2VhcmNoID0ga25uX3NlYXJjaF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLm1nZXQgPSBtZ2V0XzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUubXNlYXJjaCA9IG1zZWFyY2hfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5tc2VhcmNoVGVtcGxhdGUgPSBtc2VhcmNoX3RlbXBsYXRlXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUubXRlcm12ZWN0b3JzID0gbXRlcm12ZWN0b3JzXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUub3BlblBvaW50SW5UaW1lID0gb3Blbl9wb2ludF9pbl90aW1lXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUucGluZyA9IHBpbmdfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5wdXRTY3JpcHQgPSBwdXRfc2NyaXB0XzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUucmFua0V2YWwgPSByYW5rX2V2YWxfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5yZWluZGV4ID0gcmVpbmRleF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnJlaW5kZXhSZXRocm90dGxlID0gcmVpbmRleF9yZXRocm90dGxlXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUucmVuZGVyU2VhcmNoVGVtcGxhdGUgPSByZW5kZXJfc2VhcmNoX3RlbXBsYXRlXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuc2NyaXB0c1BhaW5sZXNzRXhlY3V0ZSA9IHNjcmlwdHNfcGFpbmxlc3NfZXhlY3V0ZV8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnNjcm9sbCA9IHNjcm9sbF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnNlYXJjaCA9IHNlYXJjaF8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnNlYXJjaE12dCA9IHNlYXJjaF9tdnRfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS5zZWFyY2hTaGFyZHMgPSBzZWFyY2hfc2hhcmRzXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUuc2VhcmNoVGVtcGxhdGUgPSBzZWFyY2hfdGVtcGxhdGVfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS50ZXJtc0VudW0gPSB0ZXJtc19lbnVtXzEuZGVmYXVsdDtcbkFQSS5wcm90b3R5cGUudGVybXZlY3RvcnMgPSB0ZXJtdmVjdG9yc18xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnVwZGF0ZSA9IHVwZGF0ZV8xLmRlZmF1bHQ7XG5BUEkucHJvdG90eXBlLnVwZGF0ZUJ5UXVlcnkgPSB1cGRhdGVfYnlfcXVlcnlfMS5kZWZhdWx0O1xuQVBJLnByb3RvdHlwZS51cGRhdGVCeVF1ZXJ5UmV0aHJvdHRsZSA9IHVwZGF0ZV9ieV9xdWVyeV9yZXRocm90dGxlXzEuZGVmYXVsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFQSS5wcm90b3R5cGUsIHtcbiAgICBhc3luY1NlYXJjaDoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tBc3luY1NlYXJjaF0gPT09IG51bGwgPyAodGhpc1trQXN5bmNTZWFyY2hdID0gbmV3IGFzeW5jX3NlYXJjaF8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0FzeW5jU2VhcmNoXTsgfVxuICAgIH0sXG4gICAgYXV0b3NjYWxpbmc6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trQXV0b3NjYWxpbmddID09PSBudWxsID8gKHRoaXNba0F1dG9zY2FsaW5nXSA9IG5ldyBhdXRvc2NhbGluZ18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0F1dG9zY2FsaW5nXTsgfVxuICAgIH0sXG4gICAgY2F0OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0NhdF0gPT09IG51bGwgPyAodGhpc1trQ2F0XSA9IG5ldyBjYXRfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tDYXRdOyB9XG4gICAgfSxcbiAgICBjY3I6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trQ2NyXSA9PT0gbnVsbCA/ICh0aGlzW2tDY3JdID0gbmV3IGNjcl8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0Njcl07IH1cbiAgICB9LFxuICAgIGNsdXN0ZXI6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trQ2x1c3Rlcl0gPT09IG51bGwgPyAodGhpc1trQ2x1c3Rlcl0gPSBuZXcgY2x1c3Rlcl8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0NsdXN0ZXJdOyB9XG4gICAgfSxcbiAgICBjb25uZWN0b3I6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trQ29ubmVjdG9yXSA9PT0gbnVsbCA/ICh0aGlzW2tDb25uZWN0b3JdID0gbmV3IGNvbm5lY3Rvcl8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0Nvbm5lY3Rvcl07IH1cbiAgICB9LFxuICAgIGRhbmdsaW5nSW5kaWNlczoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tEYW5nbGluZ0luZGljZXNdID09PSBudWxsID8gKHRoaXNba0RhbmdsaW5nSW5kaWNlc10gPSBuZXcgZGFuZ2xpbmdfaW5kaWNlc18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0RhbmdsaW5nSW5kaWNlc107IH1cbiAgICB9LFxuICAgIGVucmljaDoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tFbnJpY2hdID09PSBudWxsID8gKHRoaXNba0VucmljaF0gPSBuZXcgZW5yaWNoXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trRW5yaWNoXTsgfVxuICAgIH0sXG4gICAgZXFsOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0VxbF0gPT09IG51bGwgPyAodGhpc1trRXFsXSA9IG5ldyBlcWxfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tFcWxdOyB9XG4gICAgfSxcbiAgICBlc3FsOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0VzcWxdID09PSBudWxsID8gKHRoaXNba0VzcWxdID0gbmV3IGVzcWxfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tFc3FsXTsgfVxuICAgIH0sXG4gICAgZmVhdHVyZXM6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trRmVhdHVyZXNdID09PSBudWxsID8gKHRoaXNba0ZlYXR1cmVzXSA9IG5ldyBmZWF0dXJlc18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0ZlYXR1cmVzXTsgfVxuICAgIH0sXG4gICAgZmxlZXQ6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trRmxlZXRdID09PSBudWxsID8gKHRoaXNba0ZsZWV0XSA9IG5ldyBmbGVldF8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0ZsZWV0XTsgfVxuICAgIH0sXG4gICAgZ3JhcGg6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trR3JhcGhdID09PSBudWxsID8gKHRoaXNba0dyYXBoXSA9IG5ldyBncmFwaF8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0dyYXBoXTsgfVxuICAgIH0sXG4gICAgaWxtOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0lsbV0gPT09IG51bGwgPyAodGhpc1trSWxtXSA9IG5ldyBpbG1fMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tJbG1dOyB9XG4gICAgfSxcbiAgICBpbmRpY2VzOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0luZGljZXNdID09PSBudWxsID8gKHRoaXNba0luZGljZXNdID0gbmV3IGluZGljZXNfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tJbmRpY2VzXTsgfVxuICAgIH0sXG4gICAgaW5mZXJlbmNlOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba0luZmVyZW5jZV0gPT09IG51bGwgPyAodGhpc1trSW5mZXJlbmNlXSA9IG5ldyBpbmZlcmVuY2VfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tJbmZlcmVuY2VdOyB9XG4gICAgfSxcbiAgICBpbmdlc3Q6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trSW5nZXN0XSA9PT0gbnVsbCA/ICh0aGlzW2tJbmdlc3RdID0gbmV3IGluZ2VzdF8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0luZ2VzdF07IH1cbiAgICB9LFxuICAgIGxpY2Vuc2U6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trTGljZW5zZV0gPT09IG51bGwgPyAodGhpc1trTGljZW5zZV0gPSBuZXcgbGljZW5zZV8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba0xpY2Vuc2VdOyB9XG4gICAgfSxcbiAgICBsb2dzdGFzaDoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tMb2dzdGFzaF0gPT09IG51bGwgPyAodGhpc1trTG9nc3Rhc2hdID0gbmV3IGxvZ3N0YXNoXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trTG9nc3Rhc2hdOyB9XG4gICAgfSxcbiAgICBtaWdyYXRpb246IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trTWlncmF0aW9uXSA9PT0gbnVsbCA/ICh0aGlzW2tNaWdyYXRpb25dID0gbmV3IG1pZ3JhdGlvbl8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba01pZ3JhdGlvbl07IH1cbiAgICB9LFxuICAgIG1sOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba01sXSA9PT0gbnVsbCA/ICh0aGlzW2tNbF0gPSBuZXcgbWxfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tNbF07IH1cbiAgICB9LFxuICAgIG1vbml0b3Jpbmc6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trTW9uaXRvcmluZ10gPT09IG51bGwgPyAodGhpc1trTW9uaXRvcmluZ10gPSBuZXcgbW9uaXRvcmluZ18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba01vbml0b3JpbmddOyB9XG4gICAgfSxcbiAgICBub2Rlczoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tOb2Rlc10gPT09IG51bGwgPyAodGhpc1trTm9kZXNdID0gbmV3IG5vZGVzXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trTm9kZXNdOyB9XG4gICAgfSxcbiAgICBwcm9maWxpbmc6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trUHJvZmlsaW5nXSA9PT0gbnVsbCA/ICh0aGlzW2tQcm9maWxpbmddID0gbmV3IHByb2ZpbGluZ18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba1Byb2ZpbGluZ107IH1cbiAgICB9LFxuICAgIHF1ZXJ5UnVsZXM6IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trUXVlcnlSdWxlc10gPT09IG51bGwgPyAodGhpc1trUXVlcnlSdWxlc10gPSBuZXcgcXVlcnlfcnVsZXNfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tRdWVyeVJ1bGVzXTsgfVxuICAgIH0sXG4gICAgcm9sbHVwOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba1JvbGx1cF0gPT09IG51bGwgPyAodGhpc1trUm9sbHVwXSA9IG5ldyByb2xsdXBfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tSb2xsdXBdOyB9XG4gICAgfSxcbiAgICBzZWFyY2hBcHBsaWNhdGlvbjoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTZWFyY2hBcHBsaWNhdGlvbl0gPT09IG51bGwgPyAodGhpc1trU2VhcmNoQXBwbGljYXRpb25dID0gbmV3IHNlYXJjaF9hcHBsaWNhdGlvbl8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba1NlYXJjaEFwcGxpY2F0aW9uXTsgfVxuICAgIH0sXG4gICAgc2VhcmNoYWJsZVNuYXBzaG90czoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTZWFyY2hhYmxlU25hcHNob3RzXSA9PT0gbnVsbCA/ICh0aGlzW2tTZWFyY2hhYmxlU25hcHNob3RzXSA9IG5ldyBzZWFyY2hhYmxlX3NuYXBzaG90c18xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba1NlYXJjaGFibGVTbmFwc2hvdHNdOyB9XG4gICAgfSxcbiAgICBzZWN1cml0eToge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTZWN1cml0eV0gPT09IG51bGwgPyAodGhpc1trU2VjdXJpdHldID0gbmV3IHNlY3VyaXR5XzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trU2VjdXJpdHldOyB9XG4gICAgfSxcbiAgICBzaHV0ZG93bjoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTaHV0ZG93bl0gPT09IG51bGwgPyAodGhpc1trU2h1dGRvd25dID0gbmV3IHNodXRkb3duXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trU2h1dGRvd25dOyB9XG4gICAgfSxcbiAgICBzaW11bGF0ZToge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTaW11bGF0ZV0gPT09IG51bGwgPyAodGhpc1trU2ltdWxhdGVdID0gbmV3IHNpbXVsYXRlXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trU2ltdWxhdGVdOyB9XG4gICAgfSxcbiAgICBzbG06IHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpc1trU2xtXSA9PT0gbnVsbCA/ICh0aGlzW2tTbG1dID0gbmV3IHNsbV8xLmRlZmF1bHQodGhpcy50cmFuc3BvcnQpKSA6IHRoaXNba1NsbV07IH1cbiAgICB9LFxuICAgIHNuYXBzaG90OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba1NuYXBzaG90XSA9PT0gbnVsbCA/ICh0aGlzW2tTbmFwc2hvdF0gPSBuZXcgc25hcHNob3RfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tTbmFwc2hvdF07IH1cbiAgICB9LFxuICAgIHNxbDoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTcWxdID09PSBudWxsID8gKHRoaXNba1NxbF0gPSBuZXcgc3FsXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trU3FsXTsgfVxuICAgIH0sXG4gICAgc3NsOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba1NzbF0gPT09IG51bGwgPyAodGhpc1trU3NsXSA9IG5ldyBzc2xfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tTc2xdOyB9XG4gICAgfSxcbiAgICBzeW5vbnltczoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tTeW5vbnltc10gPT09IG51bGwgPyAodGhpc1trU3lub255bXNdID0gbmV3IHN5bm9ueW1zXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trU3lub255bXNdOyB9XG4gICAgfSxcbiAgICB0YXNrczoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tUYXNrc10gPT09IG51bGwgPyAodGhpc1trVGFza3NdID0gbmV3IHRhc2tzXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trVGFza3NdOyB9XG4gICAgfSxcbiAgICB0ZXh0U3RydWN0dXJlOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba1RleHRTdHJ1Y3R1cmVdID09PSBudWxsID8gKHRoaXNba1RleHRTdHJ1Y3R1cmVdID0gbmV3IHRleHRfc3RydWN0dXJlXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trVGV4dFN0cnVjdHVyZV07IH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybToge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tUcmFuc2Zvcm1dID09PSBudWxsID8gKHRoaXNba1RyYW5zZm9ybV0gPSBuZXcgdHJhbnNmb3JtXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trVHJhbnNmb3JtXTsgfVxuICAgIH0sXG4gICAgd2F0Y2hlcjoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzW2tXYXRjaGVyXSA9PT0gbnVsbCA/ICh0aGlzW2tXYXRjaGVyXSA9IG5ldyB3YXRjaGVyXzEuZGVmYXVsdCh0aGlzLnRyYW5zcG9ydCkpIDogdGhpc1trV2F0Y2hlcl07IH1cbiAgICB9LFxuICAgIHhwYWNrOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXNba1hwYWNrXSA9PT0gbnVsbCA/ICh0aGlzW2tYcGFja10gPSBuZXcgeHBhY2tfMS5kZWZhdWx0KHRoaXMudHJhbnNwb3J0KSkgOiB0aGlzW2tYcGFja107IH1cbiAgICB9XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/client.js":
/*!***********************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/client.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst node_process_1 = tslib_1.__importDefault(__webpack_require__(/*! node:process */ \"node:process\"));\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst node_buffer_1 = tslib_1.__importDefault(__webpack_require__(/*! node:buffer */ \"node:buffer\"));\nconst node_os_1 = tslib_1.__importDefault(__webpack_require__(/*! node:os */ \"node:os\"));\nconst transport_1 = __webpack_require__(/*! @elastic/transport */ \"(rsc)/./node_modules/@elastic/transport/index.js\");\nconst BaseConnection_1 = __webpack_require__(/*! @elastic/transport/lib/connection/BaseConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\");\nconst sniffingTransport_1 = tslib_1.__importDefault(__webpack_require__(/*! ./sniffingTransport */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js\"));\nconst helpers_1 = tslib_1.__importDefault(__webpack_require__(/*! ./helpers */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/helpers.js\"));\nconst api_1 = tslib_1.__importDefault(__webpack_require__(/*! ./api */ \"(rsc)/./node_modules/@elastic/elasticsearch/lib/api/index.js\"));\nconst package_json_1 = tslib_1.__importDefault(__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@elastic/elasticsearch/package.json\"));\nconst package_json_2 = tslib_1.__importDefault(__webpack_require__(/*! @elastic/transport/package.json */ \"(rsc)/./node_modules/@elastic/transport/package.json\"));\nconst kChild = Symbol('elasticsearchjs-child');\nconst kInitialOptions = Symbol('elasticsearchjs-initial-options');\nlet clientVersion = package_json_1.default.version;\n/* istanbul ignore next */\nif (clientVersion.includes('-')) {\n    // clean prerelease\n    clientVersion = clientVersion.slice(0, clientVersion.indexOf('-')) + 'p';\n}\nlet transportVersion = package_json_2.default.version; // eslint-disable-line\n/* istanbul ignore next */\nif (transportVersion.includes('-')) {\n    // clean prerelease\n    transportVersion = transportVersion.slice(0, transportVersion.indexOf('-')) + 'p';\n}\nconst nodeVersion = node_process_1.default.versions.node;\nclass Client extends api_1.default {\n    constructor(opts) {\n        var _a, _b, _c, _d;\n        super();\n        Object.defineProperty(this, \"diagnostic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connectionPool\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serializer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"helpers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error kChild symbol is for internal use only\n        if ((opts.cloud != null) && opts[kChild] === undefined) {\n            const { id } = opts.cloud;\n            // the cloud id is `cluster-name:base64encodedurl`\n            // the url is a string divided by two '$', the first is the cloud url\n            // the second the elasticsearch instance, the third the kibana instance\n            const cloudUrls = Buffer.from(id.split(':')[1], 'base64').toString().split('$');\n            opts.node = `https://${cloudUrls[1]}.${cloudUrls[0]}`;\n            // Cloud has better performances with compression enabled\n            // see https://github.com/elastic/elasticsearch-py/pull/704.\n            // So unless the user specifies otherwise, we enable compression.\n            if (opts.compression == null)\n                opts.compression = true;\n            if (opts.tls == null ||\n                (opts.tls != null && opts.tls.secureProtocol == null)) {\n                opts.tls = (_a = opts.tls) !== null && _a !== void 0 ? _a : {};\n                opts.tls.secureProtocol = 'TLSv1_2_method';\n            }\n        }\n        if (opts.node == null && opts.nodes == null) {\n            throw new transport_1.errors.ConfigurationError('Missing node(s) option');\n        }\n        // @ts-expect-error kChild symbol is for internal use only\n        if (opts[kChild] === undefined) {\n            const checkAuth = getAuth((_b = opts.node) !== null && _b !== void 0 ? _b : opts.nodes);\n            if ((checkAuth != null) && checkAuth.username !== '' && checkAuth.password !== '') {\n                opts.auth = Object.assign({}, opts.auth, { username: checkAuth.username, password: checkAuth.password });\n            }\n        }\n        const options = Object.assign({}, {\n            Connection: transport_1.UndiciConnection,\n            Transport: sniffingTransport_1.default,\n            Serializer: transport_1.Serializer,\n            ConnectionPool: (opts.cloud != null) ? transport_1.CloudConnectionPool : transport_1.WeightedConnectionPool,\n            maxRetries: 3,\n            requestTimeout: 30000,\n            pingTimeout: 3000,\n            sniffInterval: false,\n            sniffOnStart: false,\n            sniffEndpoint: '_nodes/_all/http',\n            sniffOnConnectionFault: false,\n            resurrectStrategy: 'ping',\n            compression: false,\n            tls: null,\n            caFingerprint: null,\n            agent: null,\n            headers: {\n                'user-agent': `elasticsearch-js/${clientVersion} (${node_os_1.default.platform()} ${node_os_1.default.release()}-${node_os_1.default.arch()}; Node.js ${nodeVersion}; Transport ${transportVersion})`\n            },\n            nodeFilter: null,\n            generateRequestId: null,\n            name: 'elasticsearch-js',\n            auth: null,\n            opaqueIdPrefix: null,\n            context: null,\n            proxy: null,\n            enableMetaHeader: true,\n            maxResponseSize: null,\n            maxCompressedResponseSize: null,\n            redaction: {\n                type: 'replace',\n                additionalKeys: []\n            }\n        }, opts);\n        if (options.caFingerprint != null && isHttpConnection((_c = opts.node) !== null && _c !== void 0 ? _c : opts.nodes)) {\n            throw new transport_1.errors.ConfigurationError('You can\\'t configure the caFingerprint with a http connection');\n        }\n        if (options.maxResponseSize != null && options.maxResponseSize > node_buffer_1.default.constants.MAX_STRING_LENGTH) {\n            throw new transport_1.errors.ConfigurationError(`The maxResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_STRING_LENGTH}`);\n        }\n        if (options.maxCompressedResponseSize != null && options.maxCompressedResponseSize > node_buffer_1.default.constants.MAX_LENGTH) {\n            throw new transport_1.errors.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_LENGTH}`);\n        }\n        if (options.enableMetaHeader) {\n            options.headers['x-elastic-client-meta'] = `es=${clientVersion},js=${nodeVersion},t=${transportVersion},hc=${nodeVersion}`;\n        }\n        this.name = options.name;\n        // @ts-expect-error kInitialOptions symbol is for internal use only\n        this[kInitialOptions] = options;\n        // @ts-expect-error kChild symbol is for internal use only\n        if (opts[kChild] !== undefined) {\n            // @ts-expect-error kChild symbol is for internal use only\n            this.serializer = opts[kChild].serializer;\n            // @ts-expect-error kChild symbol is for internal use only\n            this.connectionPool = opts[kChild].connectionPool;\n            // @ts-expect-error kChild symbol is for internal use only\n            this.diagnostic = opts[kChild].diagnostic;\n        }\n        else {\n            this.diagnostic = new transport_1.Diagnostic();\n            let serializerOptions;\n            if (opts.disablePrototypePoisoningProtection != null) {\n                if (typeof opts.disablePrototypePoisoningProtection === 'boolean') {\n                    serializerOptions = {\n                        enablePrototypePoisoningProtection: !opts.disablePrototypePoisoningProtection\n                    };\n                }\n                else {\n                    serializerOptions = {\n                        enablePrototypePoisoningProtection: opts.disablePrototypePoisoningProtection\n                    };\n                }\n            }\n            this.serializer = new options.Serializer(serializerOptions);\n            this.connectionPool = new options.ConnectionPool({\n                pingTimeout: options.pingTimeout,\n                resurrectStrategy: options.resurrectStrategy,\n                tls: options.tls,\n                agent: options.agent,\n                proxy: options.proxy,\n                Connection: options.Connection,\n                auth: options.auth,\n                diagnostic: this.diagnostic,\n                caFingerprint: options.caFingerprint\n            });\n            // ensure default connection values are inherited when creating new connections\n            // see https://github.com/elastic/elasticsearch-js/issues/1791\n            const nodes = (_d = options.node) !== null && _d !== void 0 ? _d : options.nodes;\n            let nodeOptions = Array.isArray(nodes) ? nodes : [nodes];\n            nodeOptions = nodeOptions.map(opt => {\n                const { tls, headers, auth, requestTimeout: timeout, agent, proxy, caFingerprint } = options;\n                let defaults = { tls, headers, auth, timeout, agent, proxy, caFingerprint };\n                // strip undefined values from defaults\n                defaults = Object.keys(defaults).reduce((acc, key) => {\n                    const val = defaults[key];\n                    if (val !== undefined)\n                        acc[key] = val;\n                    return acc;\n                }, {});\n                let newOpts;\n                if (typeof opt === 'string') {\n                    newOpts = {\n                        url: new node_url_1.URL(opt)\n                    };\n                }\n                else {\n                    newOpts = opt;\n                }\n                return { ...defaults, ...newOpts };\n            });\n            this.connectionPool.addConnection(nodeOptions);\n        }\n        this.transport = new options.Transport({\n            diagnostic: this.diagnostic,\n            connectionPool: this.connectionPool,\n            serializer: this.serializer,\n            maxRetries: options.maxRetries,\n            requestTimeout: options.requestTimeout,\n            sniffInterval: options.sniffInterval,\n            sniffOnStart: options.sniffOnStart,\n            sniffOnConnectionFault: options.sniffOnConnectionFault,\n            sniffEndpoint: options.sniffEndpoint,\n            compression: options.compression,\n            headers: options.headers,\n            nodeFilter: options.nodeFilter,\n            nodeSelector: options.nodeSelector,\n            generateRequestId: options.generateRequestId,\n            name: options.name,\n            opaqueIdPrefix: options.opaqueIdPrefix,\n            context: options.context,\n            productCheck: 'Elasticsearch',\n            maxResponseSize: options.maxResponseSize,\n            maxCompressedResponseSize: options.maxCompressedResponseSize,\n            vendoredHeaders: {\n                jsonContentType: 'application/vnd.elasticsearch+json; compatible-with=8',\n                ndjsonContentType: 'application/vnd.elasticsearch+x-ndjson; compatible-with=8',\n                accept: 'application/vnd.elasticsearch+json; compatible-with=8,text/plain'\n            },\n            redaction: options.redaction\n        });\n        this.helpers = new helpers_1.default({\n            client: this,\n            metaHeader: options.enableMetaHeader\n                ? `es=${clientVersion},js=${nodeVersion},t=${transportVersion},hc=${nodeVersion}`\n                : null,\n            maxRetries: options.maxRetries\n        });\n    }\n    child(opts) {\n        // Merge the new options with the initial ones\n        // @ts-expect-error kChild symbol is for internal use only\n        const options = Object.assign({}, this[kInitialOptions], opts);\n        // Pass to the child client the parent instances that cannot be overridden\n        // @ts-expect-error kInitialOptions symbol is for internal use only\n        options[kChild] = {\n            connectionPool: this.connectionPool,\n            serializer: this.serializer,\n            diagnostic: this.diagnostic,\n            initialOptions: options\n        };\n        /* istanbul ignore else */\n        if (options.auth !== undefined) {\n            options.headers = (0, BaseConnection_1.prepareHeaders)(options.headers, options.auth);\n        }\n        return new Client(options);\n    }\n    async close() {\n        return await this.connectionPool.empty();\n    }\n}\nexports[\"default\"] = Client;\nfunction isHttpConnection(node) {\n    if (Array.isArray(node)) {\n        return node.some((n) => (typeof n === 'string' ? new node_url_1.URL(n).protocol : n.url.protocol) === 'http:');\n    }\n    else {\n        if (node == null)\n            return false;\n        return (typeof node === 'string' ? new node_url_1.URL(node).protocol : node.url.protocol) === 'http:';\n    }\n}\nfunction getAuth(node) {\n    if (Array.isArray(node)) {\n        for (const url of node) {\n            const auth = getUsernameAndPassword(url);\n            if (auth != null && auth.username !== '' && auth.password !== '') {\n                return auth;\n            }\n        }\n        return null;\n    }\n    else {\n        const auth = getUsernameAndPassword(node);\n        if (auth != null && auth.username !== '' && auth.password !== '') {\n            return auth;\n        }\n        return null;\n    }\n    function getUsernameAndPassword(node) {\n        /* istanbul ignore else */\n        if (typeof node === 'string') {\n            const { username, password } = new node_url_1.URL(node);\n            return {\n                username: decodeURIComponent(username),\n                password: decodeURIComponent(password)\n            };\n        }\n        else if (node != null && node.url instanceof node_url_1.URL) {\n            return {\n                username: decodeURIComponent(node.url.username),\n                password: decodeURIComponent(node.url.password)\n            };\n        }\n        else {\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHVEQUFPO0FBQy9CLCtDQUErQyxtQkFBTyxDQUFDLGtDQUFjO0FBQ3JFLG1CQUFtQixtQkFBTyxDQUFDLDBCQUFVO0FBQ3JDLDhDQUE4QyxtQkFBTyxDQUFDLGdDQUFhO0FBQ25FLDBDQUEwQyxtQkFBTyxDQUFDLHdCQUFTO0FBQzNELG9CQUFvQixtQkFBTyxDQUFDLDRFQUFvQjtBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQyxrSUFBa0Q7QUFDbkYsb0RBQW9ELG1CQUFPLENBQUMsaUdBQXFCO0FBQ2pGLDBDQUEwQyxtQkFBTyxDQUFDLDZFQUFXO0FBQzdELHNDQUFzQyxtQkFBTyxDQUFDLDJFQUFPO0FBQ3JELCtDQUErQyxtQkFBTyxDQUFDLGlGQUFpQjtBQUN4RSwrQ0FBK0MsbUJBQU8sQ0FBQyw2RkFBaUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhLEdBQUcsYUFBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZUFBZSw0REFBNEQ7QUFDdkg7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGVBQWUsR0FBRyw4QkFBOEIsRUFBRSw0QkFBNEIsR0FBRywyQkFBMkIsVUFBVSxjQUFjLFlBQVksaUJBQWlCO0FBQ25OLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLGtEQUFrRDtBQUMzSjtBQUNBO0FBQ0EsbUhBQW1ILDJDQUEyQztBQUM5SjtBQUNBO0FBQ0EsNkRBQTZELGNBQWMsTUFBTSxZQUFZLEtBQUssaUJBQWlCLE1BQU0sWUFBWTtBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyRUFBMkU7QUFDbkcsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSw2REFBNkQ7QUFDN0QsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjLE1BQU0sWUFBWSxLQUFLLGlCQUFpQixNQUFNLFlBQVk7QUFDaEc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKSB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3Qgbm9kZV9wcm9jZXNzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpwcm9jZXNzXCIpKTtcbmNvbnN0IG5vZGVfdXJsXzEgPSByZXF1aXJlKFwibm9kZTp1cmxcIik7XG5jb25zdCBub2RlX2J1ZmZlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6YnVmZmVyXCIpKTtcbmNvbnN0IG5vZGVfb3NfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOm9zXCIpKTtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIkBlbGFzdGljL3RyYW5zcG9ydFwiKTtcbmNvbnN0IEJhc2VDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL0Jhc2VDb25uZWN0aW9uXCIpO1xuY29uc3Qgc25pZmZpbmdUcmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NuaWZmaW5nVHJhbnNwb3J0XCIpKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2hlbHBlcnNcIikpO1xuY29uc3QgYXBpXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hcGlcIikpO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpKTtcbmNvbnN0IHBhY2thZ2VfanNvbl8yID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBlbGFzdGljL3RyYW5zcG9ydC9wYWNrYWdlLmpzb25cIikpO1xuY29uc3Qga0NoaWxkID0gU3ltYm9sKCdlbGFzdGljc2VhcmNoanMtY2hpbGQnKTtcbmNvbnN0IGtJbml0aWFsT3B0aW9ucyA9IFN5bWJvbCgnZWxhc3RpY3NlYXJjaGpzLWluaXRpYWwtb3B0aW9ucycpO1xubGV0IGNsaWVudFZlcnNpb24gPSBwYWNrYWdlX2pzb25fMS5kZWZhdWx0LnZlcnNpb247XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGNsaWVudFZlcnNpb24uaW5jbHVkZXMoJy0nKSkge1xuICAgIC8vIGNsZWFuIHByZXJlbGVhc2VcbiAgICBjbGllbnRWZXJzaW9uID0gY2xpZW50VmVyc2lvbi5zbGljZSgwLCBjbGllbnRWZXJzaW9uLmluZGV4T2YoJy0nKSkgKyAncCc7XG59XG5sZXQgdHJhbnNwb3J0VmVyc2lvbiA9IHBhY2thZ2VfanNvbl8yLmRlZmF1bHQudmVyc2lvbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICh0cmFuc3BvcnRWZXJzaW9uLmluY2x1ZGVzKCctJykpIHtcbiAgICAvLyBjbGVhbiBwcmVyZWxlYXNlXG4gICAgdHJhbnNwb3J0VmVyc2lvbiA9IHRyYW5zcG9ydFZlcnNpb24uc2xpY2UoMCwgdHJhbnNwb3J0VmVyc2lvbi5pbmRleE9mKCctJykpICsgJ3AnO1xufVxuY29uc3Qgbm9kZVZlcnNpb24gPSBub2RlX3Byb2Nlc3NfMS5kZWZhdWx0LnZlcnNpb25zLm5vZGU7XG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBhcGlfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlhZ25vc3RpY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbm5lY3Rpb25Qb29sXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRyYW5zcG9ydFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXJpYWxpemVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlbHBlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBrQ2hpbGQgc3ltYm9sIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBpZiAoKG9wdHMuY2xvdWQgIT0gbnVsbCkgJiYgb3B0c1trQ2hpbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IG9wdHMuY2xvdWQ7XG4gICAgICAgICAgICAvLyB0aGUgY2xvdWQgaWQgaXMgYGNsdXN0ZXItbmFtZTpiYXNlNjRlbmNvZGVkdXJsYFxuICAgICAgICAgICAgLy8gdGhlIHVybCBpcyBhIHN0cmluZyBkaXZpZGVkIGJ5IHR3byAnJCcsIHRoZSBmaXJzdCBpcyB0aGUgY2xvdWQgdXJsXG4gICAgICAgICAgICAvLyB0aGUgc2Vjb25kIHRoZSBlbGFzdGljc2VhcmNoIGluc3RhbmNlLCB0aGUgdGhpcmQgdGhlIGtpYmFuYSBpbnN0YW5jZVxuICAgICAgICAgICAgY29uc3QgY2xvdWRVcmxzID0gQnVmZmVyLmZyb20oaWQuc3BsaXQoJzonKVsxXSwgJ2Jhc2U2NCcpLnRvU3RyaW5nKCkuc3BsaXQoJyQnKTtcbiAgICAgICAgICAgIG9wdHMubm9kZSA9IGBodHRwczovLyR7Y2xvdWRVcmxzWzFdfS4ke2Nsb3VkVXJsc1swXX1gO1xuICAgICAgICAgICAgLy8gQ2xvdWQgaGFzIGJldHRlciBwZXJmb3JtYW5jZXMgd2l0aCBjb21wcmVzc2lvbiBlbmFibGVkXG4gICAgICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvZWxhc3RpY3NlYXJjaC1weS9wdWxsLzcwNC5cbiAgICAgICAgICAgIC8vIFNvIHVubGVzcyB0aGUgdXNlciBzcGVjaWZpZXMgb3RoZXJ3aXNlLCB3ZSBlbmFibGUgY29tcHJlc3Npb24uXG4gICAgICAgICAgICBpZiAob3B0cy5jb21wcmVzc2lvbiA9PSBudWxsKVxuICAgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3Npb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9wdHMudGxzID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAob3B0cy50bHMgIT0gbnVsbCAmJiBvcHRzLnRscy5zZWN1cmVQcm90b2NvbCA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIG9wdHMudGxzID0gKF9hID0gb3B0cy50bHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9O1xuICAgICAgICAgICAgICAgIG9wdHMudGxzLnNlY3VyZVByb3RvY29sID0gJ1RMU3YxXzJfbWV0aG9kJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5ub2RlID09IG51bGwgJiYgb3B0cy5ub2RlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0XzEuZXJyb3JzLkNvbmZpZ3VyYXRpb25FcnJvcignTWlzc2luZyBub2RlKHMpIG9wdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Iga0NoaWxkIHN5bWJvbCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgaWYgKG9wdHNba0NoaWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja0F1dGggPSBnZXRBdXRoKChfYiA9IG9wdHMubm9kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogb3B0cy5ub2Rlcyk7XG4gICAgICAgICAgICBpZiAoKGNoZWNrQXV0aCAhPSBudWxsKSAmJiBjaGVja0F1dGgudXNlcm5hbWUgIT09ICcnICYmIGNoZWNrQXV0aC5wYXNzd29yZCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBvcHRzLmF1dGggPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLmF1dGgsIHsgdXNlcm5hbWU6IGNoZWNrQXV0aC51c2VybmFtZSwgcGFzc3dvcmQ6IGNoZWNrQXV0aC5wYXNzd29yZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgQ29ubmVjdGlvbjogdHJhbnNwb3J0XzEuVW5kaWNpQ29ubmVjdGlvbixcbiAgICAgICAgICAgIFRyYW5zcG9ydDogc25pZmZpbmdUcmFuc3BvcnRfMS5kZWZhdWx0LFxuICAgICAgICAgICAgU2VyaWFsaXplcjogdHJhbnNwb3J0XzEuU2VyaWFsaXplcixcbiAgICAgICAgICAgIENvbm5lY3Rpb25Qb29sOiAob3B0cy5jbG91ZCAhPSBudWxsKSA/IHRyYW5zcG9ydF8xLkNsb3VkQ29ubmVjdGlvblBvb2wgOiB0cmFuc3BvcnRfMS5XZWlnaHRlZENvbm5lY3Rpb25Qb29sLFxuICAgICAgICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgICAgICAgIHJlcXVlc3RUaW1lb3V0OiAzMDAwMCxcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiAzMDAwLFxuICAgICAgICAgICAgc25pZmZJbnRlcnZhbDogZmFsc2UsXG4gICAgICAgICAgICBzbmlmZk9uU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgc25pZmZFbmRwb2ludDogJ19ub2Rlcy9fYWxsL2h0dHAnLFxuICAgICAgICAgICAgc25pZmZPbkNvbm5lY3Rpb25GYXVsdDogZmFsc2UsXG4gICAgICAgICAgICByZXN1cnJlY3RTdHJhdGVneTogJ3BpbmcnLFxuICAgICAgICAgICAgY29tcHJlc3Npb246IGZhbHNlLFxuICAgICAgICAgICAgdGxzOiBudWxsLFxuICAgICAgICAgICAgY2FGaW5nZXJwcmludDogbnVsbCxcbiAgICAgICAgICAgIGFnZW50OiBudWxsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICd1c2VyLWFnZW50JzogYGVsYXN0aWNzZWFyY2gtanMvJHtjbGllbnRWZXJzaW9ufSAoJHtub2RlX29zXzEuZGVmYXVsdC5wbGF0Zm9ybSgpfSAke25vZGVfb3NfMS5kZWZhdWx0LnJlbGVhc2UoKX0tJHtub2RlX29zXzEuZGVmYXVsdC5hcmNoKCl9OyBOb2RlLmpzICR7bm9kZVZlcnNpb259OyBUcmFuc3BvcnQgJHt0cmFuc3BvcnRWZXJzaW9ufSlgXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm9kZUZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgIGdlbmVyYXRlUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgbmFtZTogJ2VsYXN0aWNzZWFyY2gtanMnLFxuICAgICAgICAgICAgYXV0aDogbnVsbCxcbiAgICAgICAgICAgIG9wYXF1ZUlkUHJlZml4OiBudWxsLFxuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIHByb3h5OiBudWxsLFxuICAgICAgICAgICAgZW5hYmxlTWV0YUhlYWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG1heFJlc3BvbnNlU2l6ZTogbnVsbCxcbiAgICAgICAgICAgIG1heENvbXByZXNzZWRSZXNwb25zZVNpemU6IG51bGwsXG4gICAgICAgICAgICByZWRhY3Rpb246IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICAgICAgICAgICAgYWRkaXRpb25hbEtleXM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICBpZiAob3B0aW9ucy5jYUZpbmdlcnByaW50ICE9IG51bGwgJiYgaXNIdHRwQ29ubmVjdGlvbigoX2MgPSBvcHRzLm5vZGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wdHMubm9kZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgdHJhbnNwb3J0XzEuZXJyb3JzLkNvbmZpZ3VyYXRpb25FcnJvcignWW91IGNhblxcJ3QgY29uZmlndXJlIHRoZSBjYUZpbmdlcnByaW50IHdpdGggYSBodHRwIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5tYXhSZXNwb25zZVNpemUgIT0gbnVsbCAmJiBvcHRpb25zLm1heFJlc3BvbnNlU2l6ZSA+IG5vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX1NUUklOR19MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0cmFuc3BvcnRfMS5lcnJvcnMuQ29uZmlndXJhdGlvbkVycm9yKGBUaGUgbWF4UmVzcG9uc2VTaXplIGNhbm5vdCBiZSBiaWdnZXIgdGhhbiAke25vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX1NUUklOR19MRU5HVEh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMubWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSAhPSBudWxsICYmIG9wdGlvbnMubWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSA+IG5vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHRyYW5zcG9ydF8xLmVycm9ycy5Db25maWd1cmF0aW9uRXJyb3IoYFRoZSBtYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplIGNhbm5vdCBiZSBiaWdnZXIgdGhhbiAke25vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX0xFTkdUSH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmFibGVNZXRhSGVhZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnNbJ3gtZWxhc3RpYy1jbGllbnQtbWV0YSddID0gYGVzPSR7Y2xpZW50VmVyc2lvbn0sanM9JHtub2RlVmVyc2lvbn0sdD0ke3RyYW5zcG9ydFZlcnNpb259LGhjPSR7bm9kZVZlcnNpb259YDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Iga0luaXRpYWxPcHRpb25zIHN5bWJvbCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgdGhpc1trSW5pdGlhbE9wdGlvbnNdID0gb3B0aW9ucztcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBrQ2hpbGQgc3ltYm9sIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBpZiAob3B0c1trQ2hpbGRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Iga0NoaWxkIHN5bWJvbCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG9wdHNba0NoaWxkXS5zZXJpYWxpemVyO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBrQ2hpbGQgc3ltYm9sIGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbCA9IG9wdHNba0NoaWxkXS5jb25uZWN0aW9uUG9vbDtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3Iga0NoaWxkIHN5bWJvbCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgICAgICAgIHRoaXMuZGlhZ25vc3RpYyA9IG9wdHNba0NoaWxkXS5kaWFnbm9zdGljO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gbmV3IHRyYW5zcG9ydF8xLkRpYWdub3N0aWMoKTtcbiAgICAgICAgICAgIGxldCBzZXJpYWxpemVyT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChvcHRzLmRpc2FibGVQcm90b3R5cGVQb2lzb25pbmdQcm90ZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdHMuZGlzYWJsZVByb3RvdHlwZVBvaXNvbmluZ1Byb3RlY3Rpb24gPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVByb3RvdHlwZVBvaXNvbmluZ1Byb3RlY3Rpb246ICFvcHRzLmRpc2FibGVQcm90b3R5cGVQb2lzb25pbmdQcm90ZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZVByb3RvdHlwZVBvaXNvbmluZ1Byb3RlY3Rpb246IG9wdHMuZGlzYWJsZVByb3RvdHlwZVBvaXNvbmluZ1Byb3RlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZXIgPSBuZXcgb3B0aW9ucy5TZXJpYWxpemVyKHNlcmlhbGl6ZXJPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wgPSBuZXcgb3B0aW9ucy5Db25uZWN0aW9uUG9vbCh7XG4gICAgICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IG9wdGlvbnMucGluZ1RpbWVvdXQsXG4gICAgICAgICAgICAgICAgcmVzdXJyZWN0U3RyYXRlZ3k6IG9wdGlvbnMucmVzdXJyZWN0U3RyYXRlZ3ksXG4gICAgICAgICAgICAgICAgdGxzOiBvcHRpb25zLnRscyxcbiAgICAgICAgICAgICAgICBhZ2VudDogb3B0aW9ucy5hZ2VudCxcbiAgICAgICAgICAgICAgICBwcm94eTogb3B0aW9ucy5wcm94eSxcbiAgICAgICAgICAgICAgICBDb25uZWN0aW9uOiBvcHRpb25zLkNvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgYXV0aDogb3B0aW9ucy5hdXRoLFxuICAgICAgICAgICAgICAgIGRpYWdub3N0aWM6IHRoaXMuZGlhZ25vc3RpYyxcbiAgICAgICAgICAgICAgICBjYUZpbmdlcnByaW50OiBvcHRpb25zLmNhRmluZ2VycHJpbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZW5zdXJlIGRlZmF1bHQgY29ubmVjdGlvbiB2YWx1ZXMgYXJlIGluaGVyaXRlZCB3aGVuIGNyZWF0aW5nIG5ldyBjb25uZWN0aW9uc1xuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2VsYXN0aWNzZWFyY2gtanMvaXNzdWVzLzE3OTFcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gKF9kID0gb3B0aW9ucy5ub2RlKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBvcHRpb25zLm5vZGVzO1xuICAgICAgICAgICAgbGV0IG5vZGVPcHRpb25zID0gQXJyYXkuaXNBcnJheShub2RlcykgPyBub2RlcyA6IFtub2Rlc107XG4gICAgICAgICAgICBub2RlT3B0aW9ucyA9IG5vZGVPcHRpb25zLm1hcChvcHQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGxzLCBoZWFkZXJzLCBhdXRoLCByZXF1ZXN0VGltZW91dDogdGltZW91dCwgYWdlbnQsIHByb3h5LCBjYUZpbmdlcnByaW50IH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0cyA9IHsgdGxzLCBoZWFkZXJzLCBhdXRoLCB0aW1lb3V0LCBhZ2VudCwgcHJveHksIGNhRmluZ2VycHJpbnQgfTtcbiAgICAgICAgICAgICAgICAvLyBzdHJpcCB1bmRlZmluZWQgdmFsdWVzIGZyb20gZGVmYXVsdHNcbiAgICAgICAgICAgICAgICBkZWZhdWx0cyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRlZmF1bHRzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY1trZXldID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3T3B0cztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3T3B0cyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogbmV3IG5vZGVfdXJsXzEuVVJMKG9wdClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09wdHMgPSBvcHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRzLCAuLi5uZXdPcHRzIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wuYWRkQ29ubmVjdGlvbihub2RlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBuZXcgb3B0aW9ucy5UcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlhZ25vc3RpYzogdGhpcy5kaWFnbm9zdGljLFxuICAgICAgICAgICAgY29ubmVjdGlvblBvb2w6IHRoaXMuY29ubmVjdGlvblBvb2wsXG4gICAgICAgICAgICBzZXJpYWxpemVyOiB0aGlzLnNlcmlhbGl6ZXIsXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgICAgICByZXF1ZXN0VGltZW91dDogb3B0aW9ucy5yZXF1ZXN0VGltZW91dCxcbiAgICAgICAgICAgIHNuaWZmSW50ZXJ2YWw6IG9wdGlvbnMuc25pZmZJbnRlcnZhbCxcbiAgICAgICAgICAgIHNuaWZmT25TdGFydDogb3B0aW9ucy5zbmlmZk9uU3RhcnQsXG4gICAgICAgICAgICBzbmlmZk9uQ29ubmVjdGlvbkZhdWx0OiBvcHRpb25zLnNuaWZmT25Db25uZWN0aW9uRmF1bHQsXG4gICAgICAgICAgICBzbmlmZkVuZHBvaW50OiBvcHRpb25zLnNuaWZmRW5kcG9pbnQsXG4gICAgICAgICAgICBjb21wcmVzc2lvbjogb3B0aW9ucy5jb21wcmVzc2lvbixcbiAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIG5vZGVGaWx0ZXI6IG9wdGlvbnMubm9kZUZpbHRlcixcbiAgICAgICAgICAgIG5vZGVTZWxlY3Rvcjogb3B0aW9ucy5ub2RlU2VsZWN0b3IsXG4gICAgICAgICAgICBnZW5lcmF0ZVJlcXVlc3RJZDogb3B0aW9ucy5nZW5lcmF0ZVJlcXVlc3RJZCxcbiAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgIG9wYXF1ZUlkUHJlZml4OiBvcHRpb25zLm9wYXF1ZUlkUHJlZml4LFxuICAgICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgICAgcHJvZHVjdENoZWNrOiAnRWxhc3RpY3NlYXJjaCcsXG4gICAgICAgICAgICBtYXhSZXNwb25zZVNpemU6IG9wdGlvbnMubWF4UmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgbWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZTogb3B0aW9ucy5tYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgdmVuZG9yZWRIZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAganNvbkNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vdm5kLmVsYXN0aWNzZWFyY2granNvbjsgY29tcGF0aWJsZS13aXRoPTgnLFxuICAgICAgICAgICAgICAgIG5kanNvbkNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vdm5kLmVsYXN0aWNzZWFyY2greC1uZGpzb247IGNvbXBhdGlibGUtd2l0aD04JyxcbiAgICAgICAgICAgICAgICBhY2NlcHQ6ICdhcHBsaWNhdGlvbi92bmQuZWxhc3RpY3NlYXJjaCtqc29uOyBjb21wYXRpYmxlLXdpdGg9OCx0ZXh0L3BsYWluJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZGFjdGlvbjogb3B0aW9ucy5yZWRhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGVscGVycyA9IG5ldyBoZWxwZXJzXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBjbGllbnQ6IHRoaXMsXG4gICAgICAgICAgICBtZXRhSGVhZGVyOiBvcHRpb25zLmVuYWJsZU1ldGFIZWFkZXJcbiAgICAgICAgICAgICAgICA/IGBlcz0ke2NsaWVudFZlcnNpb259LGpzPSR7bm9kZVZlcnNpb259LHQ9JHt0cmFuc3BvcnRWZXJzaW9ufSxoYz0ke25vZGVWZXJzaW9ufWBcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNoaWxkKG9wdHMpIHtcbiAgICAgICAgLy8gTWVyZ2UgdGhlIG5ldyBvcHRpb25zIHdpdGggdGhlIGluaXRpYWwgb25lc1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGtDaGlsZCBzeW1ib2wgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzW2tJbml0aWFsT3B0aW9uc10sIG9wdHMpO1xuICAgICAgICAvLyBQYXNzIHRvIHRoZSBjaGlsZCBjbGllbnQgdGhlIHBhcmVudCBpbnN0YW5jZXMgdGhhdCBjYW5ub3QgYmUgb3ZlcnJpZGRlblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGtJbml0aWFsT3B0aW9ucyBzeW1ib2wgaXMgZm9yIGludGVybmFsIHVzZSBvbmx5XG4gICAgICAgIG9wdGlvbnNba0NoaWxkXSA9IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Qb29sOiB0aGlzLmNvbm5lY3Rpb25Qb29sLFxuICAgICAgICAgICAgc2VyaWFsaXplcjogdGhpcy5zZXJpYWxpemVyLFxuICAgICAgICAgICAgZGlhZ25vc3RpYzogdGhpcy5kaWFnbm9zdGljLFxuICAgICAgICAgICAgaW5pdGlhbE9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMgPSAoMCwgQmFzZUNvbm5lY3Rpb25fMS5wcmVwYXJlSGVhZGVycykob3B0aW9ucy5oZWFkZXJzLCBvcHRpb25zLmF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQ2xpZW50KG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdGlvblBvb2wuZW1wdHkoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDbGllbnQ7XG5mdW5jdGlvbiBpc0h0dHBDb25uZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZS5zb21lKChuKSA9PiAodHlwZW9mIG4gPT09ICdzdHJpbmcnID8gbmV3IG5vZGVfdXJsXzEuVVJMKG4pLnByb3RvY29sIDogbi51cmwucHJvdG9jb2wpID09PSAnaHR0cDonKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChub2RlID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnID8gbmV3IG5vZGVfdXJsXzEuVVJMKG5vZGUpLnByb3RvY29sIDogbm9kZS51cmwucHJvdG9jb2wpID09PSAnaHR0cDonO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEF1dGgobm9kZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdXJsIG9mIG5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGF1dGggPSBnZXRVc2VybmFtZUFuZFBhc3N3b3JkKHVybCk7XG4gICAgICAgICAgICBpZiAoYXV0aCAhPSBudWxsICYmIGF1dGgudXNlcm5hbWUgIT09ICcnICYmIGF1dGgucGFzc3dvcmQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBhdXRoID0gZ2V0VXNlcm5hbWVBbmRQYXNzd29yZChub2RlKTtcbiAgICAgICAgaWYgKGF1dGggIT0gbnVsbCAmJiBhdXRoLnVzZXJuYW1lICE9PSAnJyAmJiBhdXRoLnBhc3N3b3JkICE9PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFVzZXJuYW1lQW5kUGFzc3dvcmQobm9kZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVzZXJuYW1lLCBwYXNzd29yZCB9ID0gbmV3IG5vZGVfdXJsXzEuVVJMKG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogZGVjb2RlVVJJQ29tcG9uZW50KHBhc3N3b3JkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlICE9IG51bGwgJiYgbm9kZS51cmwgaW5zdGFuY2VvZiBub2RlX3VybF8xLlVSTCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KG5vZGUudXJsLnVzZXJuYW1lKSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogZGVjb2RlVVJJQ29tcG9uZW50KG5vZGUudXJsLnBhc3N3b3JkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/helpers.js":
/*!************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/helpers.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable @typescript-eslint/promise-function-async */\n/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */\nconst node_assert_1 = tslib_1.__importDefault(__webpack_require__(/*! node:assert */ \"node:assert\"));\nconst timersPromises = tslib_1.__importStar(__webpack_require__(/*! node:timers/promises */ \"node:timers/promises\"));\nconst node_stream_1 = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst transport_1 = __webpack_require__(/*! @elastic/transport */ \"(rsc)/./node_modules/@elastic/transport/index.js\");\nconst Arrow_node_1 = __webpack_require__(/*! apache-arrow/Arrow.node */ \"(rsc)/./node_modules/apache-arrow/Arrow.node.js\");\nconst { ResponseError, ConfigurationError } = transport_1.errors;\nconst sleep = timersPromises.setTimeout;\nconst pImmediate = timersPromises.setImmediate;\n/* istanbul ignore next */\nconst noop = () => { };\nconst kClient = Symbol('elasticsearch-client');\nconst kMetaHeader = Symbol('meta header');\nconst kMaxRetries = Symbol('max retries');\nclass Helpers {\n    constructor(opts) {\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[kClient] = opts.client;\n        this[kMetaHeader] = opts.metaHeader;\n        this[kMaxRetries] = opts.maxRetries;\n    }\n    /**\n     * Runs a search operation. The only difference between client.search and this utility,\n     * is that we are only returning the hits to the user and not the full ES response.\n     * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n     * as it will only need the documents source.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {array} The documents that matched the request.\n     */\n    async search(params, options = {}) {\n        var _d;\n        appendFilterPath('hits.hits._id,hits.hits._source', params, true);\n        options.meta = true;\n        const { body: result } = await this[kClient].search(params, options);\n        if (((_d = result.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {\n            return result.hits.hits.map(d => ({\n                // Starting with version 8.14.0, _id is optional, but in our case it's always present.\n                // See @es_quirk documentation in elasticsearch-specification/specification/_global/search/_types/hits.ts\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                _id: d._id,\n                ...d._source\n            }));\n        }\n        return [];\n    }\n    /**\n     * Runs a scroll search operation. This function returns an async iterator, allowing\n     * the user to use a for await loop to get all the results of a given search.\n     * ```js\n     * for await (const result of client.helpers.scrollSearch({ params })) {\n     *   console.log(result)\n     * }\n     * ```\n     * Each result represents the entire body of a single scroll search request,\n     * if you just need to scroll the results, use scrollDocuments.\n     * This function handles automatically retries on 429 status code.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {iterator} the async iterator\n     */\n    async *scrollSearch(params, options = {}) {\n        var _d, _e, _f, _g;\n        options.meta = true;\n        if (this[kMetaHeader] !== null) {\n            options.headers = (_d = options.headers) !== null && _d !== void 0 ? _d : {};\n            options.headers['x-elastic-client-meta'] = `${this[kMetaHeader]},h=s`;\n        }\n        const wait = (_e = options.wait) !== null && _e !== void 0 ? _e : 5000;\n        const maxRetries = (_f = options.maxRetries) !== null && _f !== void 0 ? _f : this[kMaxRetries];\n        if (Array.isArray(options.ignore)) {\n            options.ignore.push(429);\n        }\n        else {\n            options.ignore = [429];\n        }\n        params.scroll = (_g = params.scroll) !== null && _g !== void 0 ? _g : '1m';\n        appendFilterPath('_scroll_id', params, false);\n        let response;\n        for (let i = 0; i <= maxRetries; i++) {\n            response = await this[kClient].search(params, options);\n            if (response.statusCode !== 429)\n                break;\n            await sleep(wait);\n        }\n        (0, node_assert_1.default)(response !== undefined, 'The response is undefined, please file a bug report');\n        const { redaction = { type: 'replace' } } = options;\n        const errorOptions = { redaction };\n        if (response.statusCode === 429) {\n            throw new ResponseError(response, errorOptions);\n        }\n        let scroll_id = response.body._scroll_id;\n        let stop = false;\n        const clear = async () => {\n            stop = true;\n            await this[kClient].clearScroll({ scroll_id }, { ignore: [400], ...options });\n        };\n        while (response.body.hits != null && response.body.hits.hits.length > 0) {\n            // scroll id is always present in the response, but it might\n            // change over time based on the number of shards\n            scroll_id = response.body._scroll_id;\n            // @ts-expect-error\n            response.clear = clear;\n            addDocumentsGetter(response);\n            // @ts-expect-error\n            yield response;\n            if (stop) {\n                break;\n            }\n            for (let i = 0; i <= maxRetries; i++) {\n                const r = await this[kClient].scroll({\n                    scroll: params.scroll,\n                    rest_total_hits_as_int: params.rest_total_hits_as_int,\n                    scroll_id\n                }, options);\n                response = r;\n                (0, node_assert_1.default)(response !== undefined, 'The response is undefined, please file a bug report');\n                if (response.statusCode !== 429)\n                    break;\n                await sleep(wait);\n            }\n            if (response.statusCode === 429) {\n                throw new ResponseError(response, errorOptions);\n            }\n        }\n        if (!stop) {\n            await clear();\n        }\n    }\n    /**\n     * Runs a scroll search operation. This function returns an async iterator, allowing\n     * the user to use a for await loop to get all the documents of a given search.\n     * ```js\n     * for await (const document of client.helpers.scrollSearch({ params })) {\n     *   console.log(document)\n     * }\n     * ```\n     * Each document is what you will find by running a scrollSearch and iterating on the hits array.\n     * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n     * as it will only need the documents source.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {iterator} the async iterator\n     */\n    async *scrollDocuments(params, options = {}) {\n        appendFilterPath('hits.hits._source', params, true);\n        for await (const { documents } of this.scrollSearch(params, options)) {\n            for (const document of documents) {\n                yield document;\n            }\n        }\n    }\n    /**\n     * Creates a msearch helper instance. Once you configure it, you can use the provided\n     * `search` method to add new searches in the queue.\n     * @param {object} options - The configuration of the msearch operations.\n     * @param {object} reqOptions - The client optional configuration for this request.\n     * @return {object} The possible operations to run.\n     */\n    msearch(options = {}, reqOptions = {}) {\n        const client = this[kClient];\n        const { operations = 5, concurrency = 5, flushInterval = 500, retries = this[kMaxRetries], wait = 5000, ...msearchOptions } = options;\n        reqOptions.meta = true;\n        const { redaction = { type: 'replace' } } = reqOptions;\n        const errorOptions = { redaction };\n        let stopReading = false;\n        let stopError = null;\n        let timeoutRef = null;\n        const operationsStream = new node_stream_1.Readable({\n            objectMode: true,\n            read(size) { }\n        });\n        const p = iterate();\n        const helper = {\n            [Symbol.toStringTag]: 'Promise',\n            then(onFulfilled, onRejected) {\n                return p.then(onFulfilled, onRejected);\n            },\n            catch(onRejected) {\n                return p.catch(onRejected);\n            },\n            finally(onFinally) {\n                return p.finally(onFinally);\n            },\n            stop(error = null) {\n                if (stopReading)\n                    return;\n                stopReading = true;\n                stopError = error;\n                operationsStream.push(null);\n            },\n            // TODO: support abort a single search?\n            // NOTE: the validation checks are synchronous and the callback/promise will\n            //       be resolved in the same tick. We might want to fix this in the future.\n            search(header, body) {\n                if (stopReading) {\n                    const error = stopError === null\n                        ? new ConfigurationError('The msearch processor has been stopped')\n                        : stopError;\n                    return Promise.reject(error);\n                }\n                if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\n                    return Promise.reject(new ConfigurationError('The header should be an object'));\n                }\n                if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\n                    return Promise.reject(new ConfigurationError('The body should be an object'));\n                }\n                let onFulfilled = null;\n                let onRejected = null;\n                const promise = new Promise((resolve, reject) => {\n                    onFulfilled = resolve;\n                    onRejected = reject;\n                });\n                const callback = function callback(err, result) {\n                    err !== null ? onRejected(err) : onFulfilled(result);\n                };\n                operationsStream.push([header, body, callback]);\n                return promise;\n            }\n        };\n        return helper;\n        async function iterate() {\n            const { semaphore, finish } = buildSemaphore();\n            const msearchBody = [];\n            const callbacks = [];\n            let loadedOperations = 0;\n            timeoutRef = setTimeout(onFlushTimeout, flushInterval); // eslint-disable-line\n            try {\n                for await (const operation of operationsStream) {\n                    timeoutRef.refresh();\n                    loadedOperations += 1;\n                    msearchBody.push(operation[0], operation[1]);\n                    callbacks.push(operation[2]);\n                    if (loadedOperations >= operations) {\n                        const send = await semaphore();\n                        send(msearchBody.slice(), callbacks.slice());\n                        msearchBody.length = 0;\n                        callbacks.length = 0;\n                        loadedOperations = 0;\n                    }\n                }\n            }\n            finally {\n                clearTimeout(timeoutRef);\n            }\n            // In some cases the previos http call does not have finished,\n            // or we didn't reach the flush bytes threshold, so we force one last operation.\n            if (loadedOperations > 0) {\n                const send = await semaphore();\n                send(msearchBody, callbacks);\n            }\n            await finish();\n            if (stopError !== null) {\n                throw stopError;\n            }\n            async function onFlushTimeout() {\n                if (loadedOperations === 0)\n                    return;\n                const msearchBodyCopy = msearchBody.slice();\n                const callbacksCopy = callbacks.slice();\n                msearchBody.length = 0;\n                callbacks.length = 0;\n                loadedOperations = 0;\n                try {\n                    const send = await semaphore();\n                    send(msearchBodyCopy, callbacksCopy);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    // @ts-expect-error\n                    helper.stop(err);\n                }\n            }\n        }\n        // This function builds a semaphore using the concurrency\n        // options of the msearch helper. It is used inside the iterator\n        // to guarantee that no more than the number of operations\n        // allowed to run at the same time are executed.\n        // It returns a semaphore function which resolves in the next tick\n        // if we didn't reach the maximim concurrency yet, otherwise it returns\n        // a promise that resolves as soon as one of the running request has finshed.\n        // The semaphore function resolves a send function, which will be used\n        // to send the actual msearch request.\n        // It also returns a finish function, which returns a promise that is resolved\n        // when there are no longer request running.\n        function buildSemaphore() {\n            let resolveSemaphore = null;\n            let resolveFinish = null;\n            let running = 0;\n            return { semaphore, finish };\n            function finish() {\n                return new Promise((resolve, reject) => {\n                    if (running === 0) {\n                        resolve();\n                    }\n                    else {\n                        resolveFinish = resolve;\n                    }\n                });\n            }\n            function semaphore() {\n                if (running < concurrency) {\n                    running += 1;\n                    return pImmediate(send);\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        resolveSemaphore = resolve;\n                    });\n                }\n            }\n            function send(msearchBody, callbacks) {\n                /* istanbul ignore if */\n                if (running > concurrency) {\n                    throw new Error('Max concurrency reached');\n                }\n                msearchOperation(msearchBody, callbacks, () => {\n                    running -= 1;\n                    if (resolveSemaphore !== null) {\n                        running += 1;\n                        resolveSemaphore(send);\n                        resolveSemaphore = null;\n                    }\n                    else if (resolveFinish != null && running === 0) {\n                        resolveFinish();\n                    }\n                });\n            }\n        }\n        function msearchOperation(msearchBody, callbacks, done) {\n            let retryCount = retries;\n            // Instead of going full on async-await, which would make the code easier to read,\n            // we have decided to use callback style instead.\n            // This because every time we use async await, V8 will create multiple promises\n            // behind the scenes, making the code slightly slower.\n            tryMsearch(msearchBody, callbacks, retrySearch);\n            function retrySearch(msearchBody, callbacks) {\n                if (msearchBody.length > 0 && retryCount > 0) {\n                    retryCount -= 1;\n                    setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch);\n                    return;\n                }\n                done();\n            }\n            // This function never returns an error, if the msearch operation fails,\n            // the error is dispatched to all search executors.\n            function tryMsearch(msearchBody, callbacks, done) {\n                client.msearch(Object.assign({}, msearchOptions, { body: msearchBody }), reqOptions)\n                    .then(results => {\n                    const retryBody = [];\n                    const retryCallbacks = [];\n                    const { responses } = results.body;\n                    for (let i = 0, len = responses.length; i < len; i++) {\n                        const response = responses[i];\n                        if (response.status === 429 && retryCount > 0) {\n                            retryBody.push(msearchBody[i * 2]);\n                            retryBody.push(msearchBody[(i * 2) + 1]);\n                            retryCallbacks.push(callbacks[i]);\n                            continue;\n                        }\n                        const result = { ...results, body: response };\n                        // @ts-expect-error\n                        addDocumentsGetter(result);\n                        if (response.status != null && response.status >= 400) {\n                            callbacks[i](new ResponseError(result, errorOptions), result);\n                        }\n                        else {\n                            callbacks[i](null, result);\n                        }\n                    }\n                    done(retryBody, retryCallbacks);\n                })\n                    .catch(err => {\n                    for (const callback of callbacks) {\n                        callback(err, null);\n                    }\n                    return done([], []);\n                });\n            }\n        }\n    }\n    /**\n     * Creates a bulk helper instance. Once you configure it, you can pick which operation\n     * to execute with the given dataset, index, create, update, and delete.\n     * @param {object} options - The configuration of the bulk operation.\n     * @param {object} reqOptions - The client optional configuration for this request.\n     * @return {object} The possible operations to run with the datasource.\n     */\n    bulk(options, reqOptions = {}) {\n        var _d, _e;\n        (0, node_assert_1.default)(!((_d = reqOptions.asStream) !== null && _d !== void 0 ? _d : false), 'bulk helper: the asStream request option is not supported');\n        const client = this[kClient];\n        const { serializer } = client;\n        if (this[kMetaHeader] !== null) {\n            reqOptions.headers = (_e = reqOptions.headers) !== null && _e !== void 0 ? _e : {};\n            reqOptions.headers['x-elastic-client-meta'] = `${this[kMetaHeader]},h=bp`;\n        }\n        reqOptions.meta = true;\n        const { datasource, onDocument, flushBytes = 5000000, flushInterval = 30000, concurrency = 5, retries = this[kMaxRetries], wait = 5000, onDrop = noop, \n        // onSuccess does not default to noop, to avoid the performance hit\n        // of deserializing every document in the bulk request\n        onSuccess, refreshOnCompletion = false, ...bulkOptions } = options;\n        if (datasource === undefined) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'));\n        }\n        if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || isReadableStream(datasource) || isAsyncIterator(datasource))) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'));\n        }\n        if (onDocument === undefined) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the onDocument callback is required'));\n        }\n        let shouldAbort = false;\n        let timeoutRef = null;\n        const stats = {\n            total: 0,\n            failed: 0,\n            retry: 0,\n            successful: 0,\n            noop: 0,\n            time: 0,\n            bytes: 0,\n            aborted: false\n        };\n        const p = iterate();\n        const helper = {\n            [Symbol.toStringTag]: 'Promise',\n            then(onFulfilled, onRejected) {\n                return p.then(onFulfilled, onRejected);\n            },\n            catch(onRejected) {\n                return p.catch(onRejected);\n            },\n            finally(onFinally) {\n                return p.finally(onFinally);\n            },\n            get stats() {\n                return stats;\n            },\n            abort() {\n                clearTimeout(timeoutRef);\n                shouldAbort = true;\n                stats.aborted = true;\n                return this;\n            }\n        };\n        return helper;\n        /**\n         * Function that iterates over the given datasource and start a bulk operation as soon\n         * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\n         * model at this maximum capacity, as it will collect the next body to send while there is\n         * a running http call. In this way, the CPU time will be used carefully.\n         * The objects will be serialized right away, to approximate the byte length of the body.\n         * It creates an array of strings instead of a ndjson string because the bulkOperation\n         * will navigate the body for matching failed operations with the original document.\n         */\n        async function iterate() {\n            const { semaphore, finish } = buildSemaphore();\n            const startTime = Date.now();\n            const bulkBody = [];\n            let actionBody = '';\n            let payloadBody = '';\n            let chunkBytes = 0;\n            timeoutRef = setTimeout(onFlushTimeout, flushInterval); // eslint-disable-line\n            // @ts-expect-error datasource is an iterable\n            for await (const chunk of datasource) {\n                if (shouldAbort)\n                    break;\n                timeoutRef.refresh();\n                const result = onDocument(chunk);\n                const [action, payload] = Array.isArray(result) ? result : [result, chunk];\n                const operation = Object.keys(action)[0];\n                if (operation === 'index' || operation === 'create') {\n                    actionBody = serializer.serialize(action);\n                    payloadBody = typeof payload === 'string'\n                        ? payload\n                        : serializer.serialize(payload);\n                    chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n                    bulkBody.push(actionBody, payloadBody);\n                }\n                else if (operation === 'update') {\n                    actionBody = serializer.serialize(action);\n                    payloadBody = typeof chunk === 'string'\n                        ? `{\"doc\":${chunk}}`\n                        : serializer.serialize({ doc: chunk, ...payload });\n                    chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n                    bulkBody.push(actionBody, payloadBody);\n                }\n                else if (operation === 'delete') {\n                    actionBody = serializer.serialize(action);\n                    chunkBytes += Buffer.byteLength(actionBody);\n                    bulkBody.push(actionBody);\n                }\n                else {\n                    clearTimeout(timeoutRef);\n                    throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);\n                }\n                if (chunkBytes >= flushBytes) {\n                    stats.bytes += chunkBytes;\n                    const bulkBodyCopy = bulkBody.slice();\n                    bulkBody.length = 0;\n                    chunkBytes = 0;\n                    const send = await semaphore();\n                    send(bulkBodyCopy);\n                }\n            }\n            clearTimeout(timeoutRef);\n            // In some cases the previous http call has not finished,\n            // or we didn't reach the flush bytes threshold, so we force one last operation.\n            if (!shouldAbort && chunkBytes > 0) {\n                const send = await semaphore();\n                stats.bytes += chunkBytes;\n                send(bulkBody);\n            }\n            await finish();\n            if (refreshOnCompletion !== false) {\n                await client.indices.refresh({\n                    index: typeof refreshOnCompletion === 'string'\n                        ? refreshOnCompletion\n                        : '_all'\n                }, reqOptions);\n            }\n            stats.time = Date.now() - startTime;\n            stats.total = stats.successful + stats.failed;\n            return stats;\n            async function onFlushTimeout() {\n                if (chunkBytes === 0)\n                    return;\n                stats.bytes += chunkBytes;\n                const bulkBodyCopy = bulkBody.slice();\n                bulkBody.length = 0;\n                chunkBytes = 0;\n                try {\n                    const send = await semaphore();\n                    send(bulkBodyCopy);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    helper.abort(); // eslint-disable-line\n                }\n            }\n        }\n        // This function builds a semaphore using the concurrency\n        // options of the bulk helper. It is used inside the iterator\n        // to guarantee that no more than the number of operations\n        // allowed to run at the same time are executed.\n        // It returns a semaphore function which resolves in the next tick\n        // if we didn't reach the maximum concurrency yet, otherwise it returns\n        // a promise that resolves as soon as one of the running requests has finished.\n        // The semaphore function resolves a send function, which will be used\n        // to send the actual bulk request.\n        // It also returns a finish function, which returns a promise that is resolved\n        // when there are no longer request running. It rejects an error if one\n        // of the request has failed for some reason.\n        function buildSemaphore() {\n            let resolveSemaphore = null;\n            let resolveFinish = null;\n            let rejectFinish = null;\n            let error = null;\n            let running = 0;\n            return { semaphore, finish };\n            function finish() {\n                return new Promise((resolve, reject) => {\n                    if (running === 0) {\n                        if (error !== null) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    }\n                    else {\n                        resolveFinish = resolve;\n                        rejectFinish = reject;\n                    }\n                });\n            }\n            function semaphore() {\n                if (running < concurrency) {\n                    running += 1;\n                    return pImmediate(send);\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        resolveSemaphore = resolve;\n                    });\n                }\n            }\n            function send(bulkBody) {\n                /* istanbul ignore if */\n                if (running > concurrency) {\n                    throw new Error('Max concurrency reached');\n                }\n                bulkOperation(bulkBody, err => {\n                    running -= 1;\n                    if (err != null) {\n                        shouldAbort = true;\n                        error = err;\n                    }\n                    if (resolveSemaphore !== null) {\n                        running += 1;\n                        resolveSemaphore(send);\n                        resolveSemaphore = null;\n                    }\n                    else if (resolveFinish != null && rejectFinish != null && running === 0) {\n                        if (error != null) {\n                            rejectFinish(error);\n                        }\n                        else {\n                            resolveFinish();\n                        }\n                    }\n                });\n            }\n        }\n        function bulkOperation(bulkBody, callback) {\n            let retryCount = retries;\n            let isRetrying = false;\n            // Instead of going full on async-await, which would make the code easier to read,\n            // we have decided to use callback style instead.\n            // This because every time we use async await, V8 will create multiple promises\n            // behind the scenes, making the code slightly slower.\n            tryBulk(bulkBody, retryDocuments);\n            function retryDocuments(err, bulkBody) {\n                if (err != null)\n                    return callback(err);\n                if (shouldAbort)\n                    return callback();\n                if (bulkBody.length > 0) {\n                    if (retryCount > 0) {\n                        isRetrying = true;\n                        retryCount -= 1;\n                        stats.retry += bulkBody.length;\n                        setTimeout(tryBulk, wait, bulkBody, retryDocuments);\n                        return;\n                    }\n                    for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\n                        const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0];\n                        onDrop({\n                            status: 429,\n                            error: null,\n                            operation: serializer.deserialize(bulkBody[i]),\n                            // @ts-expect-error\n                            document: operation !== 'delete'\n                                ? serializer.deserialize(bulkBody[i + 1])\n                                /* istanbul ignore next */\n                                : null,\n                            retried: isRetrying\n                        });\n                        stats.failed += 1;\n                    }\n                }\n                callback();\n            }\n            /**\n             * Zips bulk response items (the action's result) with the original document body.\n             * The raw string version of action and document lines are also included.\n             */\n            function zipBulkResults(responseItems, bulkBody) {\n                const zipped = [];\n                let indexSlice = 0;\n                for (let i = 0, len = responseItems.length; i < len; i++) {\n                    const result = responseItems[i];\n                    const operation = Object.keys(result)[0];\n                    let zipResult;\n                    if (operation === 'delete') {\n                        zipResult = {\n                            result,\n                            raw: { action: bulkBody[indexSlice] }\n                        };\n                        indexSlice += 1;\n                    }\n                    else {\n                        const document = bulkBody[indexSlice + 1];\n                        zipResult = {\n                            result,\n                            raw: { action: bulkBody[indexSlice], document },\n                            // this is a function so that deserialization is only done when needed\n                            // to avoid a performance hit\n                            document: () => serializer.deserialize(document)\n                        };\n                        indexSlice += 2;\n                    }\n                    zipped.push(zipResult);\n                }\n                return zipped;\n            }\n            function tryBulk(bulkBody, callback) {\n                if (shouldAbort)\n                    return callback(null, []);\n                client.bulk(Object.assign({}, bulkOptions, { body: bulkBody }), reqOptions)\n                    .then(response => {\n                    var _d, _e, _f;\n                    const result = response.body;\n                    const results = zipBulkResults(result.items, bulkBody);\n                    if (!result.errors) {\n                        stats.successful += result.items.length;\n                        for (const item of results) {\n                            const { result, document = noop } = item;\n                            if (((_d = result.update) === null || _d === void 0 ? void 0 : _d.result) === 'noop') {\n                                stats.noop++;\n                            }\n                            if (onSuccess != null)\n                                onSuccess({ result, document: document() });\n                        }\n                        return callback(null, []);\n                    }\n                    const retry = [];\n                    for (const item of results) {\n                        const { result, raw, document = noop } = item;\n                        const operation = Object.keys(result)[0];\n                        // @ts-expect-error\n                        const responseItem = result[operation];\n                        (0, node_assert_1.default)(responseItem !== undefined, 'The responseItem is undefined, please file a bug report');\n                        if (responseItem.status >= 400) {\n                            // 429 is the only status code where we might want to retry\n                            // a document, because it was not an error in the document itself,\n                            // but the ES node was handling too many operations.\n                            if (responseItem.status === 429) {\n                                retry.push(raw.action);\n                                /* istanbul ignore next */\n                                if (operation !== 'delete') {\n                                    retry.push((_e = raw.document) !== null && _e !== void 0 ? _e : '');\n                                }\n                            }\n                            else {\n                                onDrop({\n                                    status: responseItem.status,\n                                    error: (_f = responseItem.error) !== null && _f !== void 0 ? _f : null,\n                                    operation: serializer.deserialize(raw.action),\n                                    // @ts-expect-error\n                                    document: document(),\n                                    retried: isRetrying\n                                });\n                                stats.failed += 1;\n                            }\n                        }\n                        else {\n                            stats.successful += 1;\n                            if (onSuccess != null)\n                                onSuccess({ result, document: document() });\n                        }\n                    }\n                    callback(null, retry);\n                })\n                    .catch(err => {\n                    callback(err, []);\n                });\n            }\n        }\n    }\n    /**\n     * Creates an ES|QL helper instance, to help transform the data returned by an ES|QL query into easy-to-use formats.\n     * @param {object} params - Request parameters sent to esql.query()\n     * @returns {object} EsqlHelper instance\n     */\n    esql(params, reqOptions = {}) {\n        var _d;\n        if (this[kMetaHeader] !== null) {\n            reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};\n            reqOptions.headers['x-elastic-client-meta'] = `${this[kMetaHeader]},h=qo`;\n        }\n        const client = this[kClient];\n        function toRecords(response) {\n            const { columns, values } = response;\n            return values.map(row => {\n                const doc = {};\n                row.forEach((cell, index) => {\n                    const { name } = columns[index];\n                    // @ts-expect-error\n                    doc[name] = cell;\n                });\n                return doc;\n            });\n        }\n        const metaHeader = this[kMetaHeader];\n        const helper = {\n            /**\n             * Pivots ES|QL query results into an array of row objects, rather than the default format where each row is an array of values.\n             */\n            async toRecords() {\n                params.format = 'json';\n                // @ts-expect-error it's typed as ArrayBuffer but we know it will be JSON\n                const response = await client.esql.query(params, reqOptions);\n                const records = toRecords(response);\n                const { columns } = response;\n                return { records, columns };\n            },\n            async toArrowTable() {\n                var _d;\n                if (metaHeader !== null) {\n                    reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};\n                    reqOptions.headers['x-elastic-client-meta'] = `${metaHeader},h=qa`;\n                }\n                params.format = 'arrow';\n                const response = await client.esql.query(params, reqOptions);\n                return (0, Arrow_node_1.tableFromIPC)(response);\n            },\n            async toArrowReader() {\n                var _d;\n                if (metaHeader !== null) {\n                    reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};\n                    reqOptions.headers['x-elastic-client-meta'] = `${metaHeader},h=qa`;\n                    reqOptions.asStream = true;\n                }\n                params.format = 'arrow';\n                const response = await client.esql.query(params, reqOptions);\n                return Arrow_node_1.RecordBatchStreamReader.from(response);\n            }\n        };\n        return helper;\n    }\n}\nexports[\"default\"] = Helpers;\n_a = kClient, _b = kMetaHeader, _c = kMaxRetries;\n// Using a getter will improve the overall performances of the code,\n// as we will reed the documents only if needed.\nfunction addDocumentsGetter(result) {\n    Object.defineProperty(result, 'documents', {\n        get() {\n            var _d;\n            if (((_d = this.body.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {\n                // @ts-expect-error\n                return this.body.hits.hits.map(d => d._source);\n            }\n            return [];\n        }\n    });\n}\nfunction appendFilterPath(filter, params, force) {\n    if (params.filter_path !== undefined) {\n        params.filter_path += ',' + filter; // eslint-disable-line\n    }\n    else if (force) {\n        params.filter_path = filter;\n    }\n}\nfunction isReadableStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction isAsyncIterator(obj) {\n    return (obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]) != null;\n}\n//# sourceMappingURL=helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHVEQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxtQkFBTyxDQUFDLGdDQUFhO0FBQ25FLDRDQUE0QyxtQkFBTyxDQUFDLGtEQUFzQjtBQUMxRSxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDaEQscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQXlCO0FBQ3RELFFBQVEsb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsUUFBUTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGtCQUFrQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjLG9CQUFvQjtBQUNsRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVyxJQUFJLDJCQUEyQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFFBQVE7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBLCtDQUErQztBQUMvQztBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBLGdCQUFnQixvSEFBb0g7QUFDcEk7QUFDQSxnQkFBZ0IsY0FBYyxvQkFBb0I7QUFDbEQsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG9CQUFvQixtQkFBbUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEMsNERBQTRELFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw2REFBNkQsa0JBQWtCO0FBQy9FO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRLE9BQU87QUFDM0MsaURBQWlELHdCQUF3QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixVQUFVO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxTQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBd0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQkFBMEI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsOEJBQThCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0JBQStCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDhCQUE4QjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxrQkFBa0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyx5QkFBeUI7QUFDekIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFdBQVc7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsV0FBVztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL2VsYXN0aWNzZWFyY2gvbGliL2hlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luYyAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uICovXG5jb25zdCBub2RlX2Fzc2VydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6YXNzZXJ0XCIpKTtcbmNvbnN0IHRpbWVyc1Byb21pc2VzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIocmVxdWlyZShcIm5vZGU6dGltZXJzL3Byb21pc2VzXCIpKTtcbmNvbnN0IG5vZGVfc3RyZWFtXzEgPSByZXF1aXJlKFwibm9kZTpzdHJlYW1cIik7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCJAZWxhc3RpYy90cmFuc3BvcnRcIik7XG5jb25zdCBBcnJvd19ub2RlXzEgPSByZXF1aXJlKFwiYXBhY2hlLWFycm93L0Fycm93Lm5vZGVcIik7XG5jb25zdCB7IFJlc3BvbnNlRXJyb3IsIENvbmZpZ3VyYXRpb25FcnJvciB9ID0gdHJhbnNwb3J0XzEuZXJyb3JzO1xuY29uc3Qgc2xlZXAgPSB0aW1lcnNQcm9taXNlcy5zZXRUaW1lb3V0O1xuY29uc3QgcEltbWVkaWF0ZSA9IHRpbWVyc1Byb21pc2VzLnNldEltbWVkaWF0ZTtcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBub29wID0gKCkgPT4geyB9O1xuY29uc3Qga0NsaWVudCA9IFN5bWJvbCgnZWxhc3RpY3NlYXJjaC1jbGllbnQnKTtcbmNvbnN0IGtNZXRhSGVhZGVyID0gU3ltYm9sKCdtZXRhIGhlYWRlcicpO1xuY29uc3Qga01heFJldHJpZXMgPSBTeW1ib2woJ21heCByZXRyaWVzJyk7XG5jbGFzcyBIZWxwZXJzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfYSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9iLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2MsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXNba0NsaWVudF0gPSBvcHRzLmNsaWVudDtcbiAgICAgICAgdGhpc1trTWV0YUhlYWRlcl0gPSBvcHRzLm1ldGFIZWFkZXI7XG4gICAgICAgIHRoaXNba01heFJldHJpZXNdID0gb3B0cy5tYXhSZXRyaWVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2VhcmNoIG9wZXJhdGlvbi4gVGhlIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGNsaWVudC5zZWFyY2ggYW5kIHRoaXMgdXRpbGl0eSxcbiAgICAgKiBpcyB0aGF0IHdlIGFyZSBvbmx5IHJldHVybmluZyB0aGUgaGl0cyB0byB0aGUgdXNlciBhbmQgbm90IHRoZSBmdWxsIEVTIHJlc3BvbnNlLlxuICAgICAqIFRoaXMgaGVscGVyIGF1dG9tYXRpY2FsbHkgYWRkcyBgZmlsdGVyX3BhdGg9aGl0cy5oaXRzLl9zb3VyY2VgIHRvIHRoZSBxdWVyeXN0cmluZyxcbiAgICAgKiBhcyBpdCB3aWxsIG9ubHkgbmVlZCB0aGUgZG9jdW1lbnRzIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIEVsYXN0aWNzZWFyY2gncyBzZWFyY2ggcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFRoZSBjbGllbnQgb3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhpcyByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4ge2FycmF5fSBUaGUgZG9jdW1lbnRzIHRoYXQgbWF0Y2hlZCB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhc3luYyBzZWFyY2gocGFyYW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9kO1xuICAgICAgICBhcHBlbmRGaWx0ZXJQYXRoKCdoaXRzLmhpdHMuX2lkLGhpdHMuaGl0cy5fc291cmNlJywgcGFyYW1zLCB0cnVlKTtcbiAgICAgICAgb3B0aW9ucy5tZXRhID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBib2R5OiByZXN1bHQgfSA9IGF3YWl0IHRoaXNba0NsaWVudF0uc2VhcmNoKHBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICgoKF9kID0gcmVzdWx0LmhpdHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaXRzKSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmhpdHMuaGl0cy5tYXAoZCA9PiAoe1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggdmVyc2lvbiA4LjE0LjAsIF9pZCBpcyBvcHRpb25hbCwgYnV0IGluIG91ciBjYXNlIGl0J3MgYWx3YXlzIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgLy8gU2VlIEBlc19xdWlyayBkb2N1bWVudGF0aW9uIGluIGVsYXN0aWNzZWFyY2gtc3BlY2lmaWNhdGlvbi9zcGVjaWZpY2F0aW9uL19nbG9iYWwvc2VhcmNoL190eXBlcy9oaXRzLnRzXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBfaWQ6IGQuX2lkLFxuICAgICAgICAgICAgICAgIC4uLmQuX3NvdXJjZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBhIHNjcm9sbCBzZWFyY2ggb3BlcmF0aW9uLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IsIGFsbG93aW5nXG4gICAgICogdGhlIHVzZXIgdG8gdXNlIGEgZm9yIGF3YWl0IGxvb3AgdG8gZ2V0IGFsbCB0aGUgcmVzdWx0cyBvZiBhIGdpdmVuIHNlYXJjaC5cbiAgICAgKiBgYGBqc1xuICAgICAqIGZvciBhd2FpdCAoY29uc3QgcmVzdWx0IG9mIGNsaWVudC5oZWxwZXJzLnNjcm9sbFNlYXJjaCh7IHBhcmFtcyB9KSkge1xuICAgICAqICAgY29uc29sZS5sb2cocmVzdWx0KVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBFYWNoIHJlc3VsdCByZXByZXNlbnRzIHRoZSBlbnRpcmUgYm9keSBvZiBhIHNpbmdsZSBzY3JvbGwgc2VhcmNoIHJlcXVlc3QsXG4gICAgICogaWYgeW91IGp1c3QgbmVlZCB0byBzY3JvbGwgdGhlIHJlc3VsdHMsIHVzZSBzY3JvbGxEb2N1bWVudHMuXG4gICAgICogVGhpcyBmdW5jdGlvbiBoYW5kbGVzIGF1dG9tYXRpY2FsbHkgcmV0cmllcyBvbiA0Mjkgc3RhdHVzIGNvZGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBFbGFzdGljc2VhcmNoJ3Mgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY2xpZW50IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtpdGVyYXRvcn0gdGhlIGFzeW5jIGl0ZXJhdG9yXG4gICAgICovXG4gICAgYXN5bmMgKnNjcm9sbFNlYXJjaChwYXJhbXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIG9wdGlvbnMubWV0YSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzW2tNZXRhSGVhZGVyXSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzID0gKF9kID0gb3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB7fTtcbiAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVyc1sneC1lbGFzdGljLWNsaWVudC1tZXRhJ10gPSBgJHt0aGlzW2tNZXRhSGVhZGVyXX0saD1zYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWl0ID0gKF9lID0gb3B0aW9ucy53YWl0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiA1MDAwO1xuICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gKF9mID0gb3B0aW9ucy5tYXhSZXRyaWVzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzW2tNYXhSZXRyaWVzXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pZ25vcmUpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmlnbm9yZS5wdXNoKDQyOSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zLmlnbm9yZSA9IFs0MjldO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5zY3JvbGwgPSAoX2cgPSBwYXJhbXMuc2Nyb2xsKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiAnMW0nO1xuICAgICAgICBhcHBlbmRGaWx0ZXJQYXRoKCdfc2Nyb2xsX2lkJywgcGFyYW1zLCBmYWxzZSk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4UmV0cmllczsgaSsrKSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXNba0NsaWVudF0uc2VhcmNoKHBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSAhPT0gNDI5KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAod2FpdCk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIG5vZGVfYXNzZXJ0XzEuZGVmYXVsdCkocmVzcG9uc2UgIT09IHVuZGVmaW5lZCwgJ1RoZSByZXNwb25zZSBpcyB1bmRlZmluZWQsIHBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydCcpO1xuICAgICAgICBjb25zdCB7IHJlZGFjdGlvbiA9IHsgdHlwZTogJ3JlcGxhY2UnIH0gfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVycm9yT3B0aW9ucyA9IHsgcmVkYWN0aW9uIH07XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MjkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKHJlc3BvbnNlLCBlcnJvck9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JvbGxfaWQgPSByZXNwb25zZS5ib2R5Ll9zY3JvbGxfaWQ7XG4gICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsZWFyID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzW2tDbGllbnRdLmNsZWFyU2Nyb2xsKHsgc2Nyb2xsX2lkIH0sIHsgaWdub3JlOiBbNDAwXSwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHJlc3BvbnNlLmJvZHkuaGl0cyAhPSBudWxsICYmIHJlc3BvbnNlLmJvZHkuaGl0cy5oaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbCBpZCBpcyBhbHdheXMgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2UsIGJ1dCBpdCBtaWdodFxuICAgICAgICAgICAgLy8gY2hhbmdlIG92ZXIgdGltZSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIHNoYXJkc1xuICAgICAgICAgICAgc2Nyb2xsX2lkID0gcmVzcG9uc2UuYm9keS5fc2Nyb2xsX2lkO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmVzcG9uc2UuY2xlYXIgPSBjbGVhcjtcbiAgICAgICAgICAgIGFkZERvY3VtZW50c0dldHRlcihyZXNwb25zZSk7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICB5aWVsZCByZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhSZXRyaWVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gYXdhaXQgdGhpc1trQ2xpZW50XS5zY3JvbGwoe1xuICAgICAgICAgICAgICAgICAgICBzY3JvbGw6IHBhcmFtcy5zY3JvbGwsXG4gICAgICAgICAgICAgICAgICAgIHJlc3RfdG90YWxfaGl0c19hc19pbnQ6IHBhcmFtcy5yZXN0X3RvdGFsX2hpdHNfYXNfaW50LFxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxfaWRcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHI7XG4gICAgICAgICAgICAgICAgKDAsIG5vZGVfYXNzZXJ0XzEuZGVmYXVsdCkocmVzcG9uc2UgIT09IHVuZGVmaW5lZCwgJ1RoZSByZXNwb25zZSBpcyB1bmRlZmluZWQsIHBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydCcpO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSA0MjkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZXNwb25zZUVycm9yKHJlc3BvbnNlLCBlcnJvck9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgYXdhaXQgY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgc2Nyb2xsIHNlYXJjaCBvcGVyYXRpb24uIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBhc3luYyBpdGVyYXRvciwgYWxsb3dpbmdcbiAgICAgKiB0aGUgdXNlciB0byB1c2UgYSBmb3IgYXdhaXQgbG9vcCB0byBnZXQgYWxsIHRoZSBkb2N1bWVudHMgb2YgYSBnaXZlbiBzZWFyY2guXG4gICAgICogYGBganNcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGRvY3VtZW50IG9mIGNsaWVudC5oZWxwZXJzLnNjcm9sbFNlYXJjaCh7IHBhcmFtcyB9KSkge1xuICAgICAqICAgY29uc29sZS5sb2coZG9jdW1lbnQpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEVhY2ggZG9jdW1lbnQgaXMgd2hhdCB5b3Ugd2lsbCBmaW5kIGJ5IHJ1bm5pbmcgYSBzY3JvbGxTZWFyY2ggYW5kIGl0ZXJhdGluZyBvbiB0aGUgaGl0cyBhcnJheS5cbiAgICAgKiBUaGlzIGhlbHBlciBhdXRvbWF0aWNhbGx5IGFkZHMgYGZpbHRlcl9wYXRoPWhpdHMuaGl0cy5fc291cmNlYCB0byB0aGUgcXVlcnlzdHJpbmcsXG4gICAgICogYXMgaXQgd2lsbCBvbmx5IG5lZWQgdGhlIGRvY3VtZW50cyBzb3VyY2UuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBFbGFzdGljc2VhcmNoJ3Mgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY2xpZW50IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtpdGVyYXRvcn0gdGhlIGFzeW5jIGl0ZXJhdG9yXG4gICAgICovXG4gICAgYXN5bmMgKnNjcm9sbERvY3VtZW50cyhwYXJhbXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhcHBlbmRGaWx0ZXJQYXRoKCdoaXRzLmhpdHMuX3NvdXJjZScsIHBhcmFtcywgdHJ1ZSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgeyBkb2N1bWVudHMgfSBvZiB0aGlzLnNjcm9sbFNlYXJjaChwYXJhbXMsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgICAgIHlpZWxkIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtc2VhcmNoIGhlbHBlciBpbnN0YW5jZS4gT25jZSB5b3UgY29uZmlndXJlIGl0LCB5b3UgY2FuIHVzZSB0aGUgcHJvdmlkZWRcbiAgICAgKiBgc2VhcmNoYCBtZXRob2QgdG8gYWRkIG5ldyBzZWFyY2hlcyBpbiB0aGUgcXVldWUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbXNlYXJjaCBvcGVyYXRpb25zLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZXFPcHRpb25zIC0gVGhlIGNsaWVudCBvcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGlzIHJlcXVlc3QuXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgcG9zc2libGUgb3BlcmF0aW9ucyB0byBydW4uXG4gICAgICovXG4gICAgbXNlYXJjaChvcHRpb25zID0ge30sIHJlcU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzW2tDbGllbnRdO1xuICAgICAgICBjb25zdCB7IG9wZXJhdGlvbnMgPSA1LCBjb25jdXJyZW5jeSA9IDUsIGZsdXNoSW50ZXJ2YWwgPSA1MDAsIHJldHJpZXMgPSB0aGlzW2tNYXhSZXRyaWVzXSwgd2FpdCA9IDUwMDAsIC4uLm1zZWFyY2hPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICByZXFPcHRpb25zLm1ldGEgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHJlZGFjdGlvbiA9IHsgdHlwZTogJ3JlcGxhY2UnIH0gfSA9IHJlcU9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVycm9yT3B0aW9ucyA9IHsgcmVkYWN0aW9uIH07XG4gICAgICAgIGxldCBzdG9wUmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcEVycm9yID0gbnVsbDtcbiAgICAgICAgbGV0IHRpbWVvdXRSZWYgPSBudWxsO1xuICAgICAgICBjb25zdCBvcGVyYXRpb25zU3RyZWFtID0gbmV3IG5vZGVfc3RyZWFtXzEuUmVhZGFibGUoe1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWQoc2l6ZSkgeyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwID0gaXRlcmF0ZSgpO1xuICAgICAgICBjb25zdCBoZWxwZXIgPSB7XG4gICAgICAgICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1Byb21pc2UnLFxuICAgICAgICAgICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5jYXRjaChvblJlamVjdGVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdG9wKGVycm9yID0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wUmVhZGluZylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0b3BSZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdG9wRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zU3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBhYm9ydCBhIHNpbmdsZSBzZWFyY2g/XG4gICAgICAgICAgICAvLyBOT1RFOiB0aGUgdmFsaWRhdGlvbiBjaGVja3MgYXJlIHN5bmNocm9ub3VzIGFuZCB0aGUgY2FsbGJhY2svcHJvbWlzZSB3aWxsXG4gICAgICAgICAgICAvLyAgICAgICBiZSByZXNvbHZlZCBpbiB0aGUgc2FtZSB0aWNrLiBXZSBtaWdodCB3YW50IHRvIGZpeCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICBzZWFyY2goaGVhZGVyLCBib2R5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BSZWFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gc3RvcEVycm9yID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ1RoZSBtc2VhcmNoIHByb2Nlc3NvciBoYXMgYmVlbiBzdG9wcGVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc3RvcEVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoISh0eXBlb2YgaGVhZGVyID09PSAnb2JqZWN0JyAmJiBoZWFkZXIgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoaGVhZGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ1RoZSBoZWFkZXIgc2hvdWxkIGJlIGFuIG9iamVjdCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGJvZHkgPT09ICdvYmplY3QnICYmIGJvZHkgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYm9keSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQ29uZmlndXJhdGlvbkVycm9yKCdUaGUgYm9keSBzaG91bGQgYmUgYW4gb2JqZWN0JykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgb25GdWxmaWxsZWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBvblJlamVjdGVkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBvbkZ1bGZpbGxlZCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVqZWN0ZWQgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgIT09IG51bGwgPyBvblJlamVjdGVkKGVycikgOiBvbkZ1bGZpbGxlZChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uc1N0cmVhbS5wdXNoKFtoZWFkZXIsIGJvZHksIGNhbGxiYWNrXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBoZWxwZXI7XG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbWFwaG9yZSwgZmluaXNoIH0gPSBidWlsZFNlbWFwaG9yZSgpO1xuICAgICAgICAgICAgY29uc3QgbXNlYXJjaEJvZHkgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgbGV0IGxvYWRlZE9wZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgdGltZW91dFJlZiA9IHNldFRpbWVvdXQob25GbHVzaFRpbWVvdXQsIGZsdXNoSW50ZXJ2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3Qgb3BlcmF0aW9uIG9mIG9wZXJhdGlvbnNTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dFJlZi5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZE9wZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgbXNlYXJjaEJvZHkucHVzaChvcGVyYXRpb25bMF0sIG9wZXJhdGlvblsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKG9wZXJhdGlvblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2FkZWRPcGVyYXRpb25zID49IG9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmQgPSBhd2FpdCBzZW1hcGhvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQobXNlYXJjaEJvZHkuc2xpY2UoKSwgY2FsbGJhY2tzLnNsaWNlKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbXNlYXJjaEJvZHkubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkT3BlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIHRoZSBwcmV2aW9zIGh0dHAgY2FsbCBkb2VzIG5vdCBoYXZlIGZpbmlzaGVkLFxuICAgICAgICAgICAgLy8gb3Igd2UgZGlkbid0IHJlYWNoIHRoZSBmbHVzaCBieXRlcyB0aHJlc2hvbGQsIHNvIHdlIGZvcmNlIG9uZSBsYXN0IG9wZXJhdGlvbi5cbiAgICAgICAgICAgIGlmIChsb2FkZWRPcGVyYXRpb25zID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmQgPSBhd2FpdCBzZW1hcGhvcmUoKTtcbiAgICAgICAgICAgICAgICBzZW5kKG1zZWFyY2hCb2R5LCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZmluaXNoKCk7XG4gICAgICAgICAgICBpZiAoc3RvcEVycm9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RvcEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gb25GbHVzaFRpbWVvdXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRlZE9wZXJhdGlvbnMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2VhcmNoQm9keUNvcHkgPSBtc2VhcmNoQm9keS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrc0NvcHkgPSBjYWxsYmFja3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBtc2VhcmNoQm9keS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGxvYWRlZE9wZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmQgPSBhd2FpdCBzZW1hcGhvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZChtc2VhcmNoQm9keUNvcHksIGNhbGxiYWNrc0NvcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiBidWlsZHMgYSBzZW1hcGhvcmUgdXNpbmcgdGhlIGNvbmN1cnJlbmN5XG4gICAgICAgIC8vIG9wdGlvbnMgb2YgdGhlIG1zZWFyY2ggaGVscGVyLiBJdCBpcyB1c2VkIGluc2lkZSB0aGUgaXRlcmF0b3JcbiAgICAgICAgLy8gdG8gZ3VhcmFudGVlIHRoYXQgbm8gbW9yZSB0aGFuIHRoZSBudW1iZXIgb2Ygb3BlcmF0aW9uc1xuICAgICAgICAvLyBhbGxvd2VkIHRvIHJ1biBhdCB0aGUgc2FtZSB0aW1lIGFyZSBleGVjdXRlZC5cbiAgICAgICAgLy8gSXQgcmV0dXJucyBhIHNlbWFwaG9yZSBmdW5jdGlvbiB3aGljaCByZXNvbHZlcyBpbiB0aGUgbmV4dCB0aWNrXG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCByZWFjaCB0aGUgbWF4aW1pbSBjb25jdXJyZW5jeSB5ZXQsIG90aGVyd2lzZSBpdCByZXR1cm5zXG4gICAgICAgIC8vIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFzIHNvb24gYXMgb25lIG9mIHRoZSBydW5uaW5nIHJlcXVlc3QgaGFzIGZpbnNoZWQuXG4gICAgICAgIC8vIFRoZSBzZW1hcGhvcmUgZnVuY3Rpb24gcmVzb2x2ZXMgYSBzZW5kIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gdG8gc2VuZCB0aGUgYWN0dWFsIG1zZWFyY2ggcmVxdWVzdC5cbiAgICAgICAgLy8gSXQgYWxzbyByZXR1cm5zIGEgZmluaXNoIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkXG4gICAgICAgIC8vIHdoZW4gdGhlcmUgYXJlIG5vIGxvbmdlciByZXF1ZXN0IHJ1bm5pbmcuXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkU2VtYXBob3JlKCkge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVTZW1hcGhvcmUgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVGaW5pc2ggPSBudWxsO1xuICAgICAgICAgICAgbGV0IHJ1bm5pbmcgPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgc2VtYXBob3JlLCBmaW5pc2ggfTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZpbmlzaCA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlbWFwaG9yZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8IGNvbmN1cnJlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBJbW1lZGlhdGUoc2VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVNlbWFwaG9yZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNlbmQobXNlYXJjaEJvZHksIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nID4gY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXggY29uY3VycmVuY3kgcmVhY2hlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtc2VhcmNoT3BlcmF0aW9uKG1zZWFyY2hCb2R5LCBjYWxsYmFja3MsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZVNlbWFwaG9yZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVNlbWFwaG9yZShzZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVTZW1hcGhvcmUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc29sdmVGaW5pc2ggIT0gbnVsbCAmJiBydW5uaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtc2VhcmNoT3BlcmF0aW9uKG1zZWFyY2hCb2R5LCBjYWxsYmFja3MsIGRvbmUpIHtcbiAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gcmV0cmllcztcbiAgICAgICAgICAgIC8vIEluc3RlYWQgb2YgZ29pbmcgZnVsbCBvbiBhc3luYy1hd2FpdCwgd2hpY2ggd291bGQgbWFrZSB0aGUgY29kZSBlYXNpZXIgdG8gcmVhZCxcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgZGVjaWRlZCB0byB1c2UgY2FsbGJhY2sgc3R5bGUgaW5zdGVhZC5cbiAgICAgICAgICAgIC8vIFRoaXMgYmVjYXVzZSBldmVyeSB0aW1lIHdlIHVzZSBhc3luYyBhd2FpdCwgVjggd2lsbCBjcmVhdGUgbXVsdGlwbGUgcHJvbWlzZXNcbiAgICAgICAgICAgIC8vIGJlaGluZCB0aGUgc2NlbmVzLCBtYWtpbmcgdGhlIGNvZGUgc2xpZ2h0bHkgc2xvd2VyLlxuICAgICAgICAgICAgdHJ5TXNlYXJjaChtc2VhcmNoQm9keSwgY2FsbGJhY2tzLCByZXRyeVNlYXJjaCk7XG4gICAgICAgICAgICBmdW5jdGlvbiByZXRyeVNlYXJjaChtc2VhcmNoQm9keSwgY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZWFyY2hCb2R5Lmxlbmd0aCA+IDAgJiYgcmV0cnlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHRyeU1zZWFyY2gsIHdhaXQsIG1zZWFyY2hCb2R5LCBjYWxsYmFja3MsIHJldHJ5U2VhcmNoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIGZ1bmN0aW9uIG5ldmVyIHJldHVybnMgYW4gZXJyb3IsIGlmIHRoZSBtc2VhcmNoIG9wZXJhdGlvbiBmYWlscyxcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvciBpcyBkaXNwYXRjaGVkIHRvIGFsbCBzZWFyY2ggZXhlY3V0b3JzLlxuICAgICAgICAgICAgZnVuY3Rpb24gdHJ5TXNlYXJjaChtc2VhcmNoQm9keSwgY2FsbGJhY2tzLCBkb25lKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm1zZWFyY2goT2JqZWN0LmFzc2lnbih7fSwgbXNlYXJjaE9wdGlvbnMsIHsgYm9keTogbXNlYXJjaEJvZHkgfSksIHJlcU9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeUJvZHkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXNwb25zZXMgfSA9IHJlc3VsdHMuYm9keTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlc3BvbnNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MjkgJiYgcmV0cnlDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUJvZHkucHVzaChtc2VhcmNoQm9keVtpICogMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Qm9keS5wdXNoKG1zZWFyY2hCb2R5WyhpICogMikgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDYWxsYmFja3MucHVzaChjYWxsYmFja3NbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyAuLi5yZXN1bHRzLCBib2R5OiByZXNwb25zZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRG9jdW1lbnRzR2V0dGVyKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9IG51bGwgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXShuZXcgUmVzcG9uc2VFcnJvcihyZXN1bHQsIGVycm9yT3B0aW9ucyksIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lKHJldHJ5Qm9keSwgcmV0cnlDYWxsYmFja3MpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShbXSwgW10pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBidWxrIGhlbHBlciBpbnN0YW5jZS4gT25jZSB5b3UgY29uZmlndXJlIGl0LCB5b3UgY2FuIHBpY2sgd2hpY2ggb3BlcmF0aW9uXG4gICAgICogdG8gZXhlY3V0ZSB3aXRoIHRoZSBnaXZlbiBkYXRhc2V0LCBpbmRleCwgY3JlYXRlLCB1cGRhdGUsIGFuZCBkZWxldGUuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgYnVsayBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlcU9wdGlvbnMgLSBUaGUgY2xpZW50IG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBwb3NzaWJsZSBvcGVyYXRpb25zIHRvIHJ1biB3aXRoIHRoZSBkYXRhc291cmNlLlxuICAgICAqL1xuICAgIGJ1bGsob3B0aW9ucywgcmVxT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgICgwLCBub2RlX2Fzc2VydF8xLmRlZmF1bHQpKCEoKF9kID0gcmVxT3B0aW9ucy5hc1N0cmVhbSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2UpLCAnYnVsayBoZWxwZXI6IHRoZSBhc1N0cmVhbSByZXF1ZXN0IG9wdGlvbiBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudF07XG4gICAgICAgIGNvbnN0IHsgc2VyaWFsaXplciB9ID0gY2xpZW50O1xuICAgICAgICBpZiAodGhpc1trTWV0YUhlYWRlcl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlcU9wdGlvbnMuaGVhZGVycyA9IChfZSA9IHJlcU9wdGlvbnMuaGVhZGVycykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDoge307XG4gICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnNbJ3gtZWxhc3RpYy1jbGllbnQtbWV0YSddID0gYCR7dGhpc1trTWV0YUhlYWRlcl19LGg9YnBgO1xuICAgICAgICB9XG4gICAgICAgIHJlcU9wdGlvbnMubWV0YSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgZGF0YXNvdXJjZSwgb25Eb2N1bWVudCwgZmx1c2hCeXRlcyA9IDUwMDAwMDAsIGZsdXNoSW50ZXJ2YWwgPSAzMDAwMCwgY29uY3VycmVuY3kgPSA1LCByZXRyaWVzID0gdGhpc1trTWF4UmV0cmllc10sIHdhaXQgPSA1MDAwLCBvbkRyb3AgPSBub29wLCBcbiAgICAgICAgLy8gb25TdWNjZXNzIGRvZXMgbm90IGRlZmF1bHQgdG8gbm9vcCwgdG8gYXZvaWQgdGhlIHBlcmZvcm1hbmNlIGhpdFxuICAgICAgICAvLyBvZiBkZXNlcmlhbGl6aW5nIGV2ZXJ5IGRvY3VtZW50IGluIHRoZSBidWxrIHJlcXVlc3RcbiAgICAgICAgb25TdWNjZXNzLCByZWZyZXNoT25Db21wbGV0aW9uID0gZmFsc2UsIC4uLmJ1bGtPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoZGF0YXNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IENvbmZpZ3VyYXRpb25FcnJvcignYnVsayBoZWxwZXI6IHRoZSBkYXRhc291cmNlIGlzIHJlcXVpcmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoZGF0YXNvdXJjZSkgfHwgQnVmZmVyLmlzQnVmZmVyKGRhdGFzb3VyY2UpIHx8IGlzUmVhZGFibGVTdHJlYW0oZGF0YXNvdXJjZSkgfHwgaXNBc3luY0l0ZXJhdG9yKGRhdGFzb3VyY2UpKSkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ2J1bGsgaGVscGVyOiB0aGUgZGF0YXNvdXJjZSBtdXN0IGJlIGFuIGFycmF5IG9yIGEgYnVmZmVyIG9yIGEgcmVhZGFibGUgc3RyZWFtIG9yIGFuIGFzeW5jIGdlbmVyYXRvcicpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Eb2N1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IENvbmZpZ3VyYXRpb25FcnJvcignYnVsayBoZWxwZXI6IHRoZSBvbkRvY3VtZW50IGNhbGxiYWNrIGlzIHJlcXVpcmVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRBYm9ydCA9IGZhbHNlO1xuICAgICAgICBsZXQgdGltZW91dFJlZiA9IG51bGw7XG4gICAgICAgIGNvbnN0IHN0YXRzID0ge1xuICAgICAgICAgICAgdG90YWw6IDAsXG4gICAgICAgICAgICBmYWlsZWQ6IDAsXG4gICAgICAgICAgICByZXRyeTogMCxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWw6IDAsXG4gICAgICAgICAgICBub29wOiAwLFxuICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIGJ5dGVzOiAwLFxuICAgICAgICAgICAgYWJvcnRlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcCA9IGl0ZXJhdGUoKTtcbiAgICAgICAgY29uc3QgaGVscGVyID0ge1xuICAgICAgICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106ICdQcm9taXNlJyxcbiAgICAgICAgICAgIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHAuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcC5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHN0YXRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0cztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dFJlZik7XG4gICAgICAgICAgICAgICAgc2hvdWxkQWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRzLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaGVscGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdGhhdCBpdGVyYXRlcyBvdmVyIHRoZSBnaXZlbiBkYXRhc291cmNlIGFuZCBzdGFydCBhIGJ1bGsgb3BlcmF0aW9uIGFzIHNvb25cbiAgICAgICAgICogYXMgaXQgcmVhY2hlcyB0aGUgY29uZmlndXJlZCBidWxrIHNpemUuIEl0J3MgZGVzaWduZWQgdG8gdXNlIHRoZSBOb2RlLmpzIGFzeW5jaHJvbm91c1xuICAgICAgICAgKiBtb2RlbCBhdCB0aGlzIG1heGltdW0gY2FwYWNpdHksIGFzIGl0IHdpbGwgY29sbGVjdCB0aGUgbmV4dCBib2R5IHRvIHNlbmQgd2hpbGUgdGhlcmUgaXNcbiAgICAgICAgICogYSBydW5uaW5nIGh0dHAgY2FsbC4gSW4gdGhpcyB3YXksIHRoZSBDUFUgdGltZSB3aWxsIGJlIHVzZWQgY2FyZWZ1bGx5LlxuICAgICAgICAgKiBUaGUgb2JqZWN0cyB3aWxsIGJlIHNlcmlhbGl6ZWQgcmlnaHQgYXdheSwgdG8gYXBwcm94aW1hdGUgdGhlIGJ5dGUgbGVuZ3RoIG9mIHRoZSBib2R5LlxuICAgICAgICAgKiBJdCBjcmVhdGVzIGFuIGFycmF5IG9mIHN0cmluZ3MgaW5zdGVhZCBvZiBhIG5kanNvbiBzdHJpbmcgYmVjYXVzZSB0aGUgYnVsa09wZXJhdGlvblxuICAgICAgICAgKiB3aWxsIG5hdmlnYXRlIHRoZSBib2R5IGZvciBtYXRjaGluZyBmYWlsZWQgb3BlcmF0aW9ucyB3aXRoIHRoZSBvcmlnaW5hbCBkb2N1bWVudC5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbWFwaG9yZSwgZmluaXNoIH0gPSBidWlsZFNlbWFwaG9yZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1bGtCb2R5ID0gW107XG4gICAgICAgICAgICBsZXQgYWN0aW9uQm9keSA9ICcnO1xuICAgICAgICAgICAgbGV0IHBheWxvYWRCb2R5ID0gJyc7XG4gICAgICAgICAgICBsZXQgY2h1bmtCeXRlcyA9IDA7XG4gICAgICAgICAgICB0aW1lb3V0UmVmID0gc2V0VGltZW91dChvbkZsdXNoVGltZW91dCwgZmx1c2hJbnRlcnZhbCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZGF0YXNvdXJjZSBpcyBhbiBpdGVyYWJsZVxuICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBkYXRhc291cmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEFib3J0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aW1lb3V0UmVmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvbkRvY3VtZW50KGNodW5rKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbYWN0aW9uLCBwYXlsb2FkXSA9IEFycmF5LmlzQXJyYXkocmVzdWx0KSA/IHJlc3VsdCA6IFtyZXN1bHQsIGNodW5rXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBPYmplY3Qua2V5cyhhY3Rpb24pWzBdO1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gPT09ICdpbmRleCcgfHwgb3BlcmF0aW9uID09PSAnY3JlYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Cb2R5ID0gc2VyaWFsaXplci5zZXJpYWxpemUoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZEJvZHkgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVyLnNlcmlhbGl6ZShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtCeXRlcyArPSBCdWZmZXIuYnl0ZUxlbmd0aChhY3Rpb25Cb2R5KSArIEJ1ZmZlci5ieXRlTGVuZ3RoKHBheWxvYWRCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgYnVsa0JvZHkucHVzaChhY3Rpb25Cb2R5LCBwYXlsb2FkQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJ3VwZGF0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQm9keSA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRCb2R5ID0gdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBge1wiZG9jXCI6JHtjaHVua319YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVyLnNlcmlhbGl6ZSh7IGRvYzogY2h1bmssIC4uLnBheWxvYWQgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rQnl0ZXMgKz0gQnVmZmVyLmJ5dGVMZW5ndGgoYWN0aW9uQm9keSkgKyBCdWZmZXIuYnl0ZUxlbmd0aChwYXlsb2FkQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGJ1bGtCb2R5LnB1c2goYWN0aW9uQm9keSwgcGF5bG9hZEJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24gPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkJvZHkgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZShhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjaHVua0J5dGVzICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKGFjdGlvbkJvZHkpO1xuICAgICAgICAgICAgICAgICAgICBidWxrQm9keS5wdXNoKGFjdGlvbkJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKGBCdWxrIGhlbHBlciBpbnZhbGlkIGFjdGlvbjogJyR7b3BlcmF0aW9ufSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rQnl0ZXMgPj0gZmx1c2hCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0cy5ieXRlcyArPSBjaHVua0J5dGVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWxrQm9keUNvcHkgPSBidWxrQm9keS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBidWxrQm9keS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBjaHVua0J5dGVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VuZCA9IGF3YWl0IHNlbWFwaG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICBzZW5kKGJ1bGtCb2R5Q29weSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRSZWYpO1xuICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgcHJldmlvdXMgaHR0cCBjYWxsIGhhcyBub3QgZmluaXNoZWQsXG4gICAgICAgICAgICAvLyBvciB3ZSBkaWRuJ3QgcmVhY2ggdGhlIGZsdXNoIGJ5dGVzIHRocmVzaG9sZCwgc28gd2UgZm9yY2Ugb25lIGxhc3Qgb3BlcmF0aW9uLlxuICAgICAgICAgICAgaWYgKCFzaG91bGRBYm9ydCAmJiBjaHVua0J5dGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbmQgPSBhd2FpdCBzZW1hcGhvcmUoKTtcbiAgICAgICAgICAgICAgICBzdGF0cy5ieXRlcyArPSBjaHVua0J5dGVzO1xuICAgICAgICAgICAgICAgIHNlbmQoYnVsa0JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZmluaXNoKCk7XG4gICAgICAgICAgICBpZiAocmVmcmVzaE9uQ29tcGxldGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuaW5kaWNlcy5yZWZyZXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IHR5cGVvZiByZWZyZXNoT25Db21wbGV0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWZyZXNoT25Db21wbGV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdfYWxsJ1xuICAgICAgICAgICAgICAgIH0sIHJlcU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHMudGltZSA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgICAgICBzdGF0cy50b3RhbCA9IHN0YXRzLnN1Y2Nlc3NmdWwgKyBzdGF0cy5mYWlsZWQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICAgICAgICBhc3luYyBmdW5jdGlvbiBvbkZsdXNoVGltZW91dCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2h1bmtCeXRlcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHN0YXRzLmJ5dGVzICs9IGNodW5rQnl0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVsa0JvZHlDb3B5ID0gYnVsa0JvZHkuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBidWxrQm9keS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGNodW5rQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbmQgPSBhd2FpdCBzZW1hcGhvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZChidWxrQm9keUNvcHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5hYm9ydCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gYnVpbGRzIGEgc2VtYXBob3JlIHVzaW5nIHRoZSBjb25jdXJyZW5jeVxuICAgICAgICAvLyBvcHRpb25zIG9mIHRoZSBidWxrIGhlbHBlci4gSXQgaXMgdXNlZCBpbnNpZGUgdGhlIGl0ZXJhdG9yXG4gICAgICAgIC8vIHRvIGd1YXJhbnRlZSB0aGF0IG5vIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIG9wZXJhdGlvbnNcbiAgICAgICAgLy8gYWxsb3dlZCB0byBydW4gYXQgdGhlIHNhbWUgdGltZSBhcmUgZXhlY3V0ZWQuXG4gICAgICAgIC8vIEl0IHJldHVybnMgYSBzZW1hcGhvcmUgZnVuY3Rpb24gd2hpY2ggcmVzb2x2ZXMgaW4gdGhlIG5leHQgdGlja1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgcmVhY2ggdGhlIG1heGltdW0gY29uY3VycmVuY3kgeWV0LCBvdGhlcndpc2UgaXQgcmV0dXJuc1xuICAgICAgICAvLyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhcyBzb29uIGFzIG9uZSBvZiB0aGUgcnVubmluZyByZXF1ZXN0cyBoYXMgZmluaXNoZWQuXG4gICAgICAgIC8vIFRoZSBzZW1hcGhvcmUgZnVuY3Rpb24gcmVzb2x2ZXMgYSBzZW5kIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGJlIHVzZWRcbiAgICAgICAgLy8gdG8gc2VuZCB0aGUgYWN0dWFsIGJ1bGsgcmVxdWVzdC5cbiAgICAgICAgLy8gSXQgYWxzbyByZXR1cm5zIGEgZmluaXNoIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkXG4gICAgICAgIC8vIHdoZW4gdGhlcmUgYXJlIG5vIGxvbmdlciByZXF1ZXN0IHJ1bm5pbmcuIEl0IHJlamVjdHMgYW4gZXJyb3IgaWYgb25lXG4gICAgICAgIC8vIG9mIHRoZSByZXF1ZXN0IGhhcyBmYWlsZWQgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICBmdW5jdGlvbiBidWlsZFNlbWFwaG9yZSgpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlU2VtYXBob3JlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCByZXNvbHZlRmluaXNoID0gbnVsbDtcbiAgICAgICAgICAgIGxldCByZWplY3RGaW5pc2ggPSBudWxsO1xuICAgICAgICAgICAgbGV0IGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBydW5uaW5nID0gMDtcbiAgICAgICAgICAgIHJldHVybiB7IHNlbWFwaG9yZSwgZmluaXNoIH07XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlRmluaXNoID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEZpbmlzaCA9IHJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2VtYXBob3JlKCkge1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDwgY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZyArPSAxO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcEltbWVkaWF0ZShzZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlU2VtYXBob3JlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2VuZChidWxrQm9keSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nID4gY29uY3VycmVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXggY29uY3VycmVuY3kgcmVhY2hlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWxrT3BlcmF0aW9uKGJ1bGtCb2R5LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nIC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkQWJvcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVTZW1hcGhvcmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVTZW1hcGhvcmUoc2VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlU2VtYXBob3JlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNvbHZlRmluaXNoICE9IG51bGwgJiYgcmVqZWN0RmluaXNoICE9IG51bGwgJiYgcnVubmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RGaW5pc2goZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUZpbmlzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYnVsa09wZXJhdGlvbihidWxrQm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxldCByZXRyeUNvdW50ID0gcmV0cmllcztcbiAgICAgICAgICAgIGxldCBpc1JldHJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBJbnN0ZWFkIG9mIGdvaW5nIGZ1bGwgb24gYXN5bmMtYXdhaXQsIHdoaWNoIHdvdWxkIG1ha2UgdGhlIGNvZGUgZWFzaWVyIHRvIHJlYWQsXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIGRlY2lkZWQgdG8gdXNlIGNhbGxiYWNrIHN0eWxlIGluc3RlYWQuXG4gICAgICAgICAgICAvLyBUaGlzIGJlY2F1c2UgZXZlcnkgdGltZSB3ZSB1c2UgYXN5bmMgYXdhaXQsIFY4IHdpbGwgY3JlYXRlIG11bHRpcGxlIHByb21pc2VzXG4gICAgICAgICAgICAvLyBiZWhpbmQgdGhlIHNjZW5lcywgbWFraW5nIHRoZSBjb2RlIHNsaWdodGx5IHNsb3dlci5cbiAgICAgICAgICAgIHRyeUJ1bGsoYnVsa0JvZHksIHJldHJ5RG9jdW1lbnRzKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJldHJ5RG9jdW1lbnRzKGVyciwgYnVsa0JvZHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRBYm9ydClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1bGtCb2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JldHJ5aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5Q291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnJldHJ5ICs9IGJ1bGtCb2R5Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodHJ5QnVsaywgd2FpdCwgYnVsa0JvZHksIHJldHJ5RG9jdW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnVsa0JvZHkubGVuZ3RoOyBpIDwgbGVuOyBpID0gaSArIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IE9iamVjdC5rZXlzKHNlcmlhbGl6ZXIuZGVzZXJpYWxpemUoYnVsa0JvZHlbaV0pKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRHJvcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MjksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGJ1bGtCb2R5W2ldKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG9wZXJhdGlvbiAhPT0gJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGJ1bGtCb2R5W2kgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpZWQ6IGlzUmV0cnlpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuZmFpbGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogWmlwcyBidWxrIHJlc3BvbnNlIGl0ZW1zICh0aGUgYWN0aW9uJ3MgcmVzdWx0KSB3aXRoIHRoZSBvcmlnaW5hbCBkb2N1bWVudCBib2R5LlxuICAgICAgICAgICAgICogVGhlIHJhdyBzdHJpbmcgdmVyc2lvbiBvZiBhY3Rpb24gYW5kIGRvY3VtZW50IGxpbmVzIGFyZSBhbHNvIGluY2x1ZGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB6aXBCdWxrUmVzdWx0cyhyZXNwb25zZUl0ZW1zLCBidWxrQm9keSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHppcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGxldCBpbmRleFNsaWNlID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcmVzcG9uc2VJdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNwb25zZUl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBPYmplY3Qua2V5cyhyZXN1bHQpWzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgemlwUmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgemlwUmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXc6IHsgYWN0aW9uOiBidWxrQm9keVtpbmRleFNsaWNlXSB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhTbGljZSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBidWxrQm9keVtpbmRleFNsaWNlICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB6aXBSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdzogeyBhY3Rpb246IGJ1bGtCb2R5W2luZGV4U2xpY2VdLCBkb2N1bWVudCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYSBmdW5jdGlvbiBzbyB0aGF0IGRlc2VyaWFsaXphdGlvbiBpcyBvbmx5IGRvbmUgd2hlbiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiAoKSA9PiBzZXJpYWxpemVyLmRlc2VyaWFsaXplKGRvY3VtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4U2xpY2UgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB6aXBwZWQucHVzaCh6aXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gemlwcGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdHJ5QnVsayhidWxrQm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQWJvcnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBbXSk7XG4gICAgICAgICAgICAgICAgY2xpZW50LmJ1bGsoT2JqZWN0LmFzc2lnbih7fSwgYnVsa09wdGlvbnMsIHsgYm9keTogYnVsa0JvZHkgfSksIHJlcU9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB6aXBCdWxrUmVzdWx0cyhyZXN1bHQuaXRlbXMsIGJ1bGtCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0cy5zdWNjZXNzZnVsICs9IHJlc3VsdC5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVzdWx0LCBkb2N1bWVudCA9IG5vb3AgfSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2QgPSByZXN1bHQudXBkYXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVzdWx0KSA9PT0gJ25vb3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLm5vb3ArKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uU3VjY2VzcyAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3MoeyByZXN1bHQsIGRvY3VtZW50OiBkb2N1bWVudCgpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZXN1bHQsIHJhdywgZG9jdW1lbnQgPSBub29wIH0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gT2JqZWN0LmtleXMocmVzdWx0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSXRlbSA9IHJlc3VsdFtvcGVyYXRpb25dO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIG5vZGVfYXNzZXJ0XzEuZGVmYXVsdCkocmVzcG9uc2VJdGVtICE9PSB1bmRlZmluZWQsICdUaGUgcmVzcG9uc2VJdGVtIGlzIHVuZGVmaW5lZCwgcGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VJdGVtLnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA0MjkgaXMgdGhlIG9ubHkgc3RhdHVzIGNvZGUgd2hlcmUgd2UgbWlnaHQgd2FudCB0byByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgZG9jdW1lbnQsIGJlY2F1c2UgaXQgd2FzIG5vdCBhbiBlcnJvciBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB0aGUgRVMgbm9kZSB3YXMgaGFuZGxpbmcgdG9vIG1hbnkgb3BlcmF0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VJdGVtLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5LnB1c2gocmF3LmFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeS5wdXNoKChfZSA9IHJhdy5kb2N1bWVudCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRyb3Aoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZUl0ZW0uc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IChfZiA9IHJlc3BvbnNlSXRlbS5lcnJvcikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyYXcuYWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmllZDogaXNSZXRyeWluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuZmFpbGVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMuc3VjY2Vzc2Z1bCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvblN1Y2Nlc3MgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKHsgcmVzdWx0LCBkb2N1bWVudDogZG9jdW1lbnQoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXRyeSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgW10pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gRVN8UUwgaGVscGVyIGluc3RhbmNlLCB0byBoZWxwIHRyYW5zZm9ybSB0aGUgZGF0YSByZXR1cm5lZCBieSBhbiBFU3xRTCBxdWVyeSBpbnRvIGVhc3ktdG8tdXNlIGZvcm1hdHMuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFJlcXVlc3QgcGFyYW1ldGVycyBzZW50IHRvIGVzcWwucXVlcnkoKVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEVzcWxIZWxwZXIgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBlc3FsKHBhcmFtcywgcmVxT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfZDtcbiAgICAgICAgaWYgKHRoaXNba01ldGFIZWFkZXJdICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnMgPSAoX2QgPSByZXFPcHRpb25zLmhlYWRlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9O1xuICAgICAgICAgICAgcmVxT3B0aW9ucy5oZWFkZXJzWyd4LWVsYXN0aWMtY2xpZW50LW1ldGEnXSA9IGAke3RoaXNba01ldGFIZWFkZXJdfSxoPXFvYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzW2tDbGllbnRdO1xuICAgICAgICBmdW5jdGlvbiB0b1JlY29yZHMocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29sdW1ucywgdmFsdWVzIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0ge307XG4gICAgICAgICAgICAgICAgcm93LmZvckVhY2goKGNlbGwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbmFtZSB9ID0gY29sdW1uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgZG9jW25hbWVdID0gY2VsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YUhlYWRlciA9IHRoaXNba01ldGFIZWFkZXJdO1xuICAgICAgICBjb25zdCBoZWxwZXIgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBpdm90cyBFU3xRTCBxdWVyeSByZXN1bHRzIGludG8gYW4gYXJyYXkgb2Ygcm93IG9iamVjdHMsIHJhdGhlciB0aGFuIHRoZSBkZWZhdWx0IGZvcm1hdCB3aGVyZSBlYWNoIHJvdyBpcyBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFzeW5jIHRvUmVjb3JkcygpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaXQncyB0eXBlZCBhcyBBcnJheUJ1ZmZlciBidXQgd2Uga25vdyBpdCB3aWxsIGJlIEpTT05cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5lc3FsLnF1ZXJ5KHBhcmFtcywgcmVxT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkcyA9IHRvUmVjb3JkcyhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWNvcmRzLCBjb2x1bW5zIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgdG9BcnJvd1RhYmxlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfZDtcbiAgICAgICAgICAgICAgICBpZiAobWV0YUhlYWRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnMgPSAoX2QgPSByZXFPcHRpb25zLmhlYWRlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnNbJ3gtZWxhc3RpYy1jbGllbnQtbWV0YSddID0gYCR7bWV0YUhlYWRlcn0saD1xYWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSAnYXJyb3cnO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50LmVzcWwucXVlcnkocGFyYW1zLCByZXFPcHRpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIEFycm93X25vZGVfMS50YWJsZUZyb21JUEMpKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhc3luYyB0b0Fycm93UmVhZGVyKCkge1xuICAgICAgICAgICAgICAgIHZhciBfZDtcbiAgICAgICAgICAgICAgICBpZiAobWV0YUhlYWRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnMgPSAoX2QgPSByZXFPcHRpb25zLmhlYWRlcnMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXFPcHRpb25zLmhlYWRlcnNbJ3gtZWxhc3RpYy1jbGllbnQtbWV0YSddID0gYCR7bWV0YUhlYWRlcn0saD1xYWA7XG4gICAgICAgICAgICAgICAgICAgIHJlcU9wdGlvbnMuYXNTdHJlYW0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gJ2Fycm93JztcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNsaWVudC5lc3FsLnF1ZXJ5KHBhcmFtcywgcmVxT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycm93X25vZGVfMS5SZWNvcmRCYXRjaFN0cmVhbVJlYWRlci5mcm9tKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGhlbHBlcjtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBIZWxwZXJzO1xuX2EgPSBrQ2xpZW50LCBfYiA9IGtNZXRhSGVhZGVyLCBfYyA9IGtNYXhSZXRyaWVzO1xuLy8gVXNpbmcgYSBnZXR0ZXIgd2lsbCBpbXByb3ZlIHRoZSBvdmVyYWxsIHBlcmZvcm1hbmNlcyBvZiB0aGUgY29kZSxcbi8vIGFzIHdlIHdpbGwgcmVlZCB0aGUgZG9jdW1lbnRzIG9ubHkgaWYgbmVlZGVkLlxuZnVuY3Rpb24gYWRkRG9jdW1lbnRzR2V0dGVyKHJlc3VsdCkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsICdkb2N1bWVudHMnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBfZDtcbiAgICAgICAgICAgIGlmICgoKF9kID0gdGhpcy5ib2R5LmhpdHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaXRzKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZHkuaGl0cy5oaXRzLm1hcChkID0+IGQuX3NvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGFwcGVuZEZpbHRlclBhdGgoZmlsdGVyLCBwYXJhbXMsIGZvcmNlKSB7XG4gICAgaWYgKHBhcmFtcy5maWx0ZXJfcGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5maWx0ZXJfcGF0aCArPSAnLCcgKyBmaWx0ZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gICAgZWxzZSBpZiAoZm9yY2UpIHtcbiAgICAgICAgcGFyYW1zLmZpbHRlcl9wYXRoID0gZmlsdGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW0ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzQXN5bmNJdGVyYXRvcihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pICE9IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/helpers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst node_assert_1 = tslib_1.__importDefault(__webpack_require__(/*! node:assert */ \"node:assert\"));\nconst transport_1 = __webpack_require__(/*! @elastic/transport */ \"(rsc)/./node_modules/@elastic/transport/index.js\");\nclass SniffingTransport extends transport_1.Transport {\n    sniff(opts) {\n        var _a;\n        if (this.isSniffing)\n            return;\n        this.isSniffing = true;\n        const request = {\n            method: 'GET',\n            path: (_a = this.sniffEndpoint) !== null && _a !== void 0 ? _a : '/_nodes/_all/http'\n        };\n        this.request(request, { id: opts.requestId, meta: true })\n            .then(result => {\n            var _a, _b;\n            (0, node_assert_1.default)(isObject(result.body), 'The body should be an object');\n            this.isSniffing = false;\n            const protocol = (_b = (_a = result.meta.connection) === null || _a === void 0 ? void 0 : _a.url.protocol) !== null && _b !== void 0 ? _b : 'http:';\n            const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n            this.connectionPool.update(hosts);\n            result.meta.sniff = { hosts, reason: opts.reason };\n            this.diagnostic.emit('sniff', null, result);\n        })\n            .catch(err => {\n            this.isSniffing = false;\n            err.meta.sniff = { hosts: [], reason: opts.reason };\n            this.diagnostic.emit('sniff', err, null);\n        });\n    }\n}\nexports[\"default\"] = SniffingTransport;\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\n//# sourceMappingURL=sniffingTransport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvc25pZmZpbmdUcmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0IsOENBQThDLG1CQUFPLENBQUMsZ0NBQWE7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsNEVBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvZWxhc3RpY3NlYXJjaC9saWIvc25pZmZpbmdUcmFuc3BvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IG5vZGVfYXNzZXJ0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTphc3NlcnRcIikpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiQGVsYXN0aWMvdHJhbnNwb3J0XCIpO1xuY2xhc3MgU25pZmZpbmdUcmFuc3BvcnQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIHNuaWZmKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5pc1NuaWZmaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmlzU25pZmZpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHBhdGg6IChfYSA9IHRoaXMuc25pZmZFbmRwb2ludCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJy9fbm9kZXMvX2FsbC9odHRwJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlcXVlc3QocmVxdWVzdCwgeyBpZDogb3B0cy5yZXF1ZXN0SWQsIG1ldGE6IHRydWUgfSlcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKDAsIG5vZGVfYXNzZXJ0XzEuZGVmYXVsdCkoaXNPYmplY3QocmVzdWx0LmJvZHkpLCAnVGhlIGJvZHkgc2hvdWxkIGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgdGhpcy5pc1NuaWZmaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IChfYiA9IChfYSA9IHJlc3VsdC5tZXRhLmNvbm5lY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cmwucHJvdG9jb2wpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdodHRwOic7XG4gICAgICAgICAgICBjb25zdCBob3N0cyA9IHRoaXMuY29ubmVjdGlvblBvb2wubm9kZXNUb0hvc3QocmVzdWx0LmJvZHkubm9kZXMsIHByb3RvY29sKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wudXBkYXRlKGhvc3RzKTtcbiAgICAgICAgICAgIHJlc3VsdC5tZXRhLnNuaWZmID0geyBob3N0cywgcmVhc29uOiBvcHRzLnJlYXNvbiB9O1xuICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljLmVtaXQoJ3NuaWZmJywgbnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1NuaWZmaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBlcnIubWV0YS5zbmlmZiA9IHsgaG9zdHM6IFtdLCByZWFzb246IG9wdHMucmVhc29uIH07XG4gICAgICAgICAgICB0aGlzLmRpYWdub3N0aWMuZW1pdCgnc25pZmYnLCBlcnIsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTbmlmZmluZ1RyYW5zcG9ydDtcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNuaWZmaW5nVHJhbnNwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@elastic/transport/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\nconst { default: Diagnostic, events } = __webpack_require__(/*! ./lib/Diagnostic */ \"(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js\")\nconst Transport = (__webpack_require__(/*! ./lib/Transport */ \"(rsc)/./node_modules/@elastic/transport/lib/Transport.js\")[\"default\"])\nconst {\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection\n} = __webpack_require__(/*! ./lib/connection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/index.js\")\nconst {\n  BaseConnectionPool,\n  ClusterConnectionPool,\n  CloudConnectionPool,\n  WeightedConnectionPool\n} = __webpack_require__(/*! ./lib/pool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/index.js\")\nconst Serializer = (__webpack_require__(/*! ./lib/Serializer */ \"(rsc)/./node_modules/@elastic/transport/lib/Serializer.js\")[\"default\"])\nconst errors = __webpack_require__(/*! ./lib/errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\")\n\nmodule.exports = {\n  Diagnostic,\n  Transport,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  BaseConnectionPool,\n  ClusterConnectionPool,\n  CloudConnectionPool,\n  WeightedConnectionPool,\n  Serializer,\n  errors,\n  events\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLFFBQVEsOEJBQThCLEVBQUUsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDbEUsa0JBQWtCLG1IQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlGQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNkVBQVk7QUFDeEIsbUJBQW1CLHFIQUFtQztBQUN0RCxlQUFlLG1CQUFPLENBQUMsMkVBQWM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGRlZmF1bHQ6IERpYWdub3N0aWMsIGV2ZW50cyB9ID0gcmVxdWlyZSgnLi9saWIvRGlhZ25vc3RpYycpXG5jb25zdCBUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9UcmFuc3BvcnQnKS5kZWZhdWx0XG5jb25zdCB7XG4gIEJhc2VDb25uZWN0aW9uLFxuICBIdHRwQ29ubmVjdGlvbixcbiAgVW5kaWNpQ29ubmVjdGlvblxufSA9IHJlcXVpcmUoJy4vbGliL2Nvbm5lY3Rpb24nKVxuY29uc3Qge1xuICBCYXNlQ29ubmVjdGlvblBvb2wsXG4gIENsdXN0ZXJDb25uZWN0aW9uUG9vbCxcbiAgQ2xvdWRDb25uZWN0aW9uUG9vbCxcbiAgV2VpZ2h0ZWRDb25uZWN0aW9uUG9vbFxufSA9IHJlcXVpcmUoJy4vbGliL3Bvb2wnKVxuY29uc3QgU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vbGliL1NlcmlhbGl6ZXInKS5kZWZhdWx0XG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9lcnJvcnMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgRGlhZ25vc3RpYyxcbiAgVHJhbnNwb3J0LFxuICBCYXNlQ29ubmVjdGlvbixcbiAgSHR0cENvbm5lY3Rpb24sXG4gIFVuZGljaUNvbm5lY3Rpb24sXG4gIEJhc2VDb25uZWN0aW9uUG9vbCxcbiAgQ2x1c3RlckNvbm5lY3Rpb25Qb29sLFxuICBDbG91ZENvbm5lY3Rpb25Qb29sLFxuICBXZWlnaHRlZENvbm5lY3Rpb25Qb29sLFxuICBTZXJpYWxpemVyLFxuICBlcnJvcnMsXG4gIGV2ZW50c1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js":
/*!***********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/Diagnostic.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.events = void 0;\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nvar events;\n(function (events) {\n    events[\"RESPONSE\"] = \"response\";\n    events[\"REQUEST\"] = \"request\";\n    events[\"SNIFF\"] = \"sniff\";\n    events[\"RESURRECT\"] = \"resurrect\";\n    events[\"SERIALIZATION\"] = \"serialization\";\n    events[\"DESERIALIZATION\"] = \"deserialization\";\n})(events || (exports.events = events = {}));\nclass Diagnostic extends node_events_1.EventEmitter {\n    on(event, listener) {\n        assertSupportedEvent(event);\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        assertSupportedEvent(event);\n        super.once(event, listener);\n        return this;\n    }\n    off(event, listener) {\n        assertSupportedEvent(event);\n        super.off(event, listener);\n        return this;\n    }\n}\nexports[\"default\"] = Diagnostic;\nfunction assertSupportedEvent(event) {\n    if (!supportedEvents.includes(event)) {\n        throw new errors_1.ConfigurationError(`The event '${event}' is not supported.`);\n    }\n}\n// @ts-expect-error\nconst supportedEvents = Object.keys(events).map(key => events[key]);\n//# sourceMappingURL=Diagnostic.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9EaWFnbm9zdGljLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLHNCQUFzQixtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWEsY0FBYyxjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9EaWFnbm9zdGljLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV2ZW50cyA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfZXZlbnRzXzEgPSByZXF1aXJlKFwibm9kZTpldmVudHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbnZhciBldmVudHM7XG4oZnVuY3Rpb24gKGV2ZW50cykge1xuICAgIGV2ZW50c1tcIlJFU1BPTlNFXCJdID0gXCJyZXNwb25zZVwiO1xuICAgIGV2ZW50c1tcIlJFUVVFU1RcIl0gPSBcInJlcXVlc3RcIjtcbiAgICBldmVudHNbXCJTTklGRlwiXSA9IFwic25pZmZcIjtcbiAgICBldmVudHNbXCJSRVNVUlJFQ1RcIl0gPSBcInJlc3VycmVjdFwiO1xuICAgIGV2ZW50c1tcIlNFUklBTElaQVRJT05cIl0gPSBcInNlcmlhbGl6YXRpb25cIjtcbiAgICBldmVudHNbXCJERVNFUklBTElaQVRJT05cIl0gPSBcImRlc2VyaWFsaXphdGlvblwiO1xufSkoZXZlbnRzIHx8IChleHBvcnRzLmV2ZW50cyA9IGV2ZW50cyA9IHt9KSk7XG5jbGFzcyBEaWFnbm9zdGljIGV4dGVuZHMgbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIG9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBhc3NlcnRTdXBwb3J0ZWRFdmVudChldmVudCk7XG4gICAgICAgIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgICBhc3NlcnRTdXBwb3J0ZWRFdmVudChldmVudCk7XG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgICAgYXNzZXJ0U3VwcG9ydGVkRXZlbnQoZXZlbnQpO1xuICAgICAgICBzdXBlci5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGlhZ25vc3RpYztcbmZ1bmN0aW9uIGFzc2VydFN1cHBvcnRlZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKCFzdXBwb3J0ZWRFdmVudHMuaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoYFRoZSBldmVudCAnJHtldmVudH0nIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxufVxuLy8gQHRzLWV4cGVjdC1lcnJvclxuY29uc3Qgc3VwcG9ydGVkRXZlbnRzID0gT2JqZWN0LmtleXMoZXZlbnRzKS5tYXAoa2V5ID0+IGV2ZW50c1trZXldKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURpYWdub3N0aWMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/Serializer.js":
/*!***********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/Serializer.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst node_querystring_1 = __webpack_require__(/*! node:querystring */ \"node:querystring\");\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst secure_json_parse_1 = tslib_1.__importDefault(__webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\"));\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst symbols_1 = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\nconst debug = (0, debug_1.default)('elasticsearch');\nclass Serializer {\n    constructor(opts = {}) {\n        var _b;\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const enabled = (_b = opts.enablePrototypePoisoningProtection) !== null && _b !== void 0 ? _b : false;\n        this[symbols_1.kJsonOptions] = {\n            protoAction: enabled === true || enabled === 'proto' ? 'error' : 'ignore',\n            constructorAction: enabled === true || enabled === 'constructor' ? 'error' : 'ignore'\n        };\n    }\n    /**\n     * Serializes a record into a JSON string\n     */\n    serialize(object) {\n        debug('Serializing', object);\n        let json;\n        try {\n            json = JSON.stringify(object);\n        }\n        catch (err) {\n            throw new errors_1.SerializationError(err.message, object);\n        }\n        return json;\n    }\n    /**\n     * Given a string, attempts to parse it from raw JSON into an object\n     */\n    deserialize(json) {\n        debug('Deserializing', json);\n        let object;\n        try {\n            // @ts-expect-error\n            object = secure_json_parse_1.default.parse(json, this[symbols_1.kJsonOptions]);\n        }\n        catch (err) {\n            throw new errors_1.DeserializationError(err.message, json);\n        }\n        return object;\n    }\n    /**\n     * Serializes an array of records into an ndjson string\n     */\n    ndserialize(array) {\n        debug('ndserialize', array);\n        if (!Array.isArray(array)) {\n            throw new errors_1.SerializationError('The argument provided is not an array', array);\n        }\n        let ndjson = '';\n        for (let i = 0, len = array.length; i < len; i++) {\n            if (typeof array[i] === 'string') {\n                ndjson += array[i] + '\\n'; // eslint-disable-line\n            }\n            else {\n                // @ts-expect-error\n                ndjson += this.serialize(array[i]) + '\\n'; // eslint-disable-line\n            }\n        }\n        return ndjson;\n    }\n    qserialize(object) {\n        debug('qserialize', object);\n        if (object == null)\n            return '';\n        if (typeof object === 'string')\n            return object;\n        // arrays should be serialized as comma separated list\n        const keys = Object.keys(object);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const key = keys[i];\n            // elasticsearch will complain for keys without a value\n            if (object[key] === undefined) {\n                delete object[key]; // eslint-disable-line\n            }\n            else if (Array.isArray(object[key])) {\n                object[key] = object[key].join(',');\n            }\n        }\n        return (0, node_querystring_1.stringify)(object);\n    }\n}\n_a = symbols_1.kJsonOptions;\nexports[\"default\"] = Serializer;\n//# sourceMappingURL=Serializer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9TZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQiwyQkFBMkIsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDckQsd0NBQXdDLG1CQUFPLENBQUMsc0RBQU87QUFDdkQsb0RBQW9ELG1CQUFPLENBQUMsMEVBQW1CO0FBQy9FLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL1NlcmlhbGl6ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBub2RlX3F1ZXJ5c3RyaW5nXzEgPSByZXF1aXJlKFwibm9kZTpxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IGRlYnVnXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3Qgc2VjdXJlX2pzb25fcGFyc2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJzZWN1cmUtanNvbi1wYXJzZVwiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKCdlbGFzdGljc2VhcmNoJyk7XG5jbGFzcyBTZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2EsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVuYWJsZWQgPSAoX2IgPSBvcHRzLmVuYWJsZVByb3RvdHlwZVBvaXNvbmluZ1Byb3RlY3Rpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rSnNvbk9wdGlvbnNdID0ge1xuICAgICAgICAgICAgcHJvdG9BY3Rpb246IGVuYWJsZWQgPT09IHRydWUgfHwgZW5hYmxlZCA9PT0gJ3Byb3RvJyA/ICdlcnJvcicgOiAnaWdub3JlJyxcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yQWN0aW9uOiBlbmFibGVkID09PSB0cnVlIHx8IGVuYWJsZWQgPT09ICdjb25zdHJ1Y3RvcicgPyAnZXJyb3InIDogJ2lnbm9yZSdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHJlY29yZCBpbnRvIGEgSlNPTiBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXJpYWxpemUob2JqZWN0KSB7XG4gICAgICAgIGRlYnVnKCdTZXJpYWxpemluZycsIG9iamVjdCk7XG4gICAgICAgIGxldCBqc29uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlNlcmlhbGl6YXRpb25FcnJvcihlcnIubWVzc2FnZSwgb2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBzdHJpbmcsIGF0dGVtcHRzIHRvIHBhcnNlIGl0IGZyb20gcmF3IEpTT04gaW50byBhbiBvYmplY3RcbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZShqc29uKSB7XG4gICAgICAgIGRlYnVnKCdEZXNlcmlhbGl6aW5nJywganNvbik7XG4gICAgICAgIGxldCBvYmplY3Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBvYmplY3QgPSBzZWN1cmVfanNvbl9wYXJzZV8xLmRlZmF1bHQucGFyc2UoanNvbiwgdGhpc1tzeW1ib2xzXzEua0pzb25PcHRpb25zXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkRlc2VyaWFsaXphdGlvbkVycm9yKGVyci5tZXNzYWdlLCBqc29uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGFuIGFycmF5IG9mIHJlY29yZHMgaW50byBhbiBuZGpzb24gc3RyaW5nXG4gICAgICovXG4gICAgbmRzZXJpYWxpemUoYXJyYXkpIHtcbiAgICAgICAgZGVidWcoJ25kc2VyaWFsaXplJywgYXJyYXkpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuU2VyaWFsaXphdGlvbkVycm9yKCdUaGUgYXJndW1lbnQgcHJvdmlkZWQgaXMgbm90IGFuIGFycmF5JywgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZGpzb24gPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFycmF5W2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIG5kanNvbiArPSBhcnJheVtpXSArICdcXG4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgbmRqc29uICs9IHRoaXMuc2VyaWFsaXplKGFycmF5W2ldKSArICdcXG4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5kanNvbjtcbiAgICB9XG4gICAgcXNlcmlhbGl6ZShvYmplY3QpIHtcbiAgICAgICAgZGVidWcoJ3FzZXJpYWxpemUnLCBvYmplY3QpO1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIC8vIGFycmF5cyBzaG91bGQgYmUgc2VyaWFsaXplZCBhcyBjb21tYSBzZXBhcmF0ZWQgbGlzdFxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGtleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAvLyBlbGFzdGljc2VhcmNoIHdpbGwgY29tcGxhaW4gZm9yIGtleXMgd2l0aG91dCBhIHZhbHVlXG4gICAgICAgICAgICBpZiAob2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBvYmplY3Rba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmplY3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IG9iamVjdFtrZXldLmpvaW4oJywnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIG5vZGVfcXVlcnlzdHJpbmdfMS5zdHJpbmdpZnkpKG9iamVjdCk7XG4gICAgfVxufVxuX2EgPSBzeW1ib2xzXzEua0pzb25PcHRpb25zO1xuZXhwb3J0cy5kZWZhdWx0ID0gU2VyaWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcmlhbGl6ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/Serializer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/Transport.js":
/*!**********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/Transport.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.generateRequestId = generateRequestId;\nexports.lowerCaseHeaders = lowerCaseHeaders;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst node_os_1 = tslib_1.__importDefault(__webpack_require__(/*! node:os */ \"node:os\"));\nconst node_zlib_1 = tslib_1.__importDefault(__webpack_require__(/*! node:zlib */ \"node:zlib\"));\nconst node_buffer_1 = tslib_1.__importDefault(__webpack_require__(/*! node:buffer */ \"node:buffer\"));\nconst node_util_1 = __webpack_require__(/*! node:util */ \"node:util\");\nconst node_process_1 = tslib_1.__importDefault(__webpack_require__(/*! node:process */ \"node:process\"));\nconst ms_1 = tslib_1.__importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\"));\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst BaseConnection_1 = __webpack_require__(/*! ./connection/BaseConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\");\nconst Diagnostic_1 = tslib_1.__importDefault(__webpack_require__(/*! ./Diagnostic */ \"(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js\"));\nconst Serializer_1 = tslib_1.__importDefault(__webpack_require__(/*! ./Serializer */ \"(rsc)/./node_modules/@elastic/transport/lib/Serializer.js\"));\nconst symbols_1 = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\nconst promises_1 = __webpack_require__(/*! node:timers/promises */ \"node:timers/promises\");\nconst api_1 = tslib_1.__importStar(__webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\"));\nconst { version: clientVersion } = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/@elastic/transport/package.json\"); // eslint-disable-line\nconst debug = (0, debug_1.default)('elasticsearch');\nconst gzip = (0, node_util_1.promisify)(node_zlib_1.default.gzip);\nconst unzip = (0, node_util_1.promisify)(node_zlib_1.default.unzip);\nconst { createGzip } = node_zlib_1.default;\nconst userAgent = `elastic-transport-js/${clientVersion} (${node_os_1.default.platform()} ${node_os_1.default.release()}-${node_os_1.default.arch()}; Node.js ${node_process_1.default.version})`; // eslint-disable-line\nclass Transport {\n    constructor(opts) {\n        var _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26;\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _d, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _e, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _f, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _g, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _h, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _j, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _k, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _l, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _m, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _o, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _p, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _q, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _r, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _s, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _t, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _u, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _v, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _w, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _x, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _y, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _z, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _0, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _1, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _2, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _3, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _4, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (opts.connectionPool == null) {\n            throw new errors_1.ConfigurationError('The Connection Pool option is not defined');\n        }\n        if (typeof opts.maxRetries === 'number' && opts.maxRetries < 0 && Number.isInteger(opts.maxRetries)) {\n            throw new errors_1.ConfigurationError('The maxRetries option must be a positive integer or zero');\n        }\n        if (opts.sniffInterval === true ||\n            (typeof opts.sniffInterval === 'number' && opts.sniffInterval < 0 && Number.isInteger(opts.sniffInterval))) {\n            throw new errors_1.ConfigurationError('The sniffInterval option must be false or a positive integer');\n        }\n        if (opts.maxResponseSize != null && opts.maxResponseSize > node_buffer_1.default.constants.MAX_STRING_LENGTH) {\n            throw new errors_1.ConfigurationError(`The maxResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_STRING_LENGTH}`);\n        }\n        if (opts.maxCompressedResponseSize != null && opts.maxCompressedResponseSize > node_buffer_1.default.constants.MAX_LENGTH) {\n            throw new errors_1.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${node_buffer_1.default.constants.MAX_LENGTH}`);\n        }\n        this[symbols_1.kNodeFilter] = (_5 = opts.nodeFilter) !== null && _5 !== void 0 ? _5 : defaultNodeFilter;\n        this[symbols_1.kNodeSelector] = (_6 = opts.nodeSelector) !== null && _6 !== void 0 ? _6 : roundRobinSelector();\n        this[symbols_1.kHeaders] = Object.assign({}, { 'user-agent': userAgent }, opts.compression === true ? { 'accept-encoding': 'gzip,deflate' } : null, lowerCaseHeaders(opts.headers));\n        this[symbols_1.kDiagnostic] = (_7 = opts.diagnostic) !== null && _7 !== void 0 ? _7 : new Diagnostic_1.default();\n        this[symbols_1.kConnectionPool] = opts.connectionPool;\n        this[symbols_1.kSerializer] = (_8 = opts.serializer) !== null && _8 !== void 0 ? _8 : new Serializer_1.default();\n        this[symbols_1.kContext] = (_9 = opts.context) !== null && _9 !== void 0 ? _9 : null;\n        this[symbols_1.kGenerateRequestId] = (_10 = opts.generateRequestId) !== null && _10 !== void 0 ? _10 : generateRequestId();\n        this[symbols_1.kOpaqueIdPrefix] = (_11 = opts.opaqueIdPrefix) !== null && _11 !== void 0 ? _11 : null;\n        this[symbols_1.kName] = (_12 = opts.name) !== null && _12 !== void 0 ? _12 : 'elastic-transport-js';\n        this[symbols_1.kMaxRetries] = typeof opts.maxRetries === 'number' ? opts.maxRetries : 3;\n        this[symbols_1.kCompression] = opts.compression === true;\n        this[symbols_1.kRequestTimeout] = opts.requestTimeout != null ? toMs(opts.requestTimeout) : 30000;\n        this[symbols_1.kRetryOnTimeout] = opts.retryOnTimeout != null ? opts.retryOnTimeout : false;\n        this[symbols_1.kSniffInterval] = (_13 = opts.sniffInterval) !== null && _13 !== void 0 ? _13 : false;\n        this[symbols_1.kSniffEnabled] = typeof this[symbols_1.kSniffInterval] === 'number';\n        this[symbols_1.kNextSniff] = this[symbols_1.kSniffEnabled] ? (Date.now() + this[symbols_1.kSniffInterval]) : 0;\n        this[symbols_1.kIsSniffing] = false;\n        this[symbols_1.kSniffOnConnectionFault] = (_14 = opts.sniffOnConnectionFault) !== null && _14 !== void 0 ? _14 : false;\n        this[symbols_1.kSniffEndpoint] = (_15 = opts.sniffEndpoint) !== null && _15 !== void 0 ? _15 : null;\n        this[symbols_1.kProductCheck] = (_16 = opts.productCheck) !== null && _16 !== void 0 ? _16 : null;\n        this[symbols_1.kMaxResponseSize] = (_17 = opts.maxResponseSize) !== null && _17 !== void 0 ? _17 : node_buffer_1.default.constants.MAX_STRING_LENGTH;\n        this[symbols_1.kMaxCompressedResponseSize] = (_18 = opts.maxCompressedResponseSize) !== null && _18 !== void 0 ? _18 : node_buffer_1.default.constants.MAX_LENGTH;\n        this[symbols_1.kJsonContentType] = (_20 = (_19 = opts.vendoredHeaders) === null || _19 === void 0 ? void 0 : _19.jsonContentType) !== null && _20 !== void 0 ? _20 : 'application/json';\n        this[symbols_1.kNdjsonContentType] = (_22 = (_21 = opts.vendoredHeaders) === null || _21 === void 0 ? void 0 : _21.ndjsonContentType) !== null && _22 !== void 0 ? _22 : 'application/x-ndjson';\n        this[symbols_1.kAcceptHeader] = (_24 = (_23 = opts.vendoredHeaders) === null || _23 === void 0 ? void 0 : _23.accept) !== null && _24 !== void 0 ? _24 : 'application/json, text/plain';\n        this[symbols_1.kRedaction] = (_25 = opts.redaction) !== null && _25 !== void 0 ? _25 : { type: 'replace', additionalKeys: [] };\n        this[symbols_1.kRetryBackoff] = (_26 = opts.retryBackoff) !== null && _26 !== void 0 ? _26 : retryBackoff;\n        this[symbols_1.kOtelTracer] = api_1.default.trace.getTracer('@elastic/transport', clientVersion);\n        if (opts.sniffOnStart === true) {\n            this.sniff({\n                reason: Transport.sniffReasons.SNIFF_ON_START,\n                requestId: this[symbols_1.kGenerateRequestId]({ method: 'GET', path: this[symbols_1.kSniffEndpoint] }, { context: this[symbols_1.kContext] }),\n                context: this[symbols_1.kContext]\n            });\n        }\n    }\n    get connectionPool() {\n        return this[symbols_1.kConnectionPool];\n    }\n    get sniffEnabled() {\n        return this[symbols_1.kSniffEnabled];\n    }\n    get nextSniff() {\n        return this[symbols_1.kNextSniff];\n    }\n    get sniffEndpoint() {\n        return this[symbols_1.kSniffEndpoint];\n    }\n    get isSniffing() {\n        return this[symbols_1.kIsSniffing];\n    }\n    set isSniffing(val) {\n        if (typeof val !== 'boolean') {\n            throw new errors_1.ConfigurationError(`isSniffing must be a boolean, instead got ${typeof val}`);\n        }\n        this[symbols_1.kIsSniffing] = val;\n    }\n    get diagnostic() {\n        return this[symbols_1.kDiagnostic];\n    }\n    async _request(params, options = {}, otelSpan) {\n        var _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21;\n        const connectionParams = {\n            method: params.method,\n            path: params.path\n        };\n        const meta = {\n            context: null,\n            request: {\n                params: connectionParams,\n                options,\n                id: (_5 = options.id) !== null && _5 !== void 0 ? _5 : this[symbols_1.kGenerateRequestId](params, options)\n            },\n            name: this[symbols_1.kName],\n            connection: null,\n            attempts: 0,\n            aborted: false\n        };\n        const returnMeta = (_6 = options.meta) !== null && _6 !== void 0 ? _6 : false;\n        if (this[symbols_1.kContext] != null && options.context != null) {\n            meta.context = Object.assign({}, this[symbols_1.kContext], options.context);\n        }\n        else if (this[symbols_1.kContext] !== null) {\n            meta.context = this[symbols_1.kContext];\n        }\n        else if (options.context != null) {\n            meta.context = options.context;\n        }\n        const result = {\n            // the default body value can't be `null`\n            // as it's a valid JSON value\n            body: undefined,\n            statusCode: 0,\n            headers: {},\n            meta,\n            get warnings() {\n                var _5;\n                if (((_5 = this.headers) === null || _5 === void 0 ? void 0 : _5.warning) == null) {\n                    return null;\n                }\n                const { warning } = this.headers;\n                // if multiple HTTP headers have the same name, Undici represents them as an array\n                const warnings = Array.isArray(warning) ? warning : [warning];\n                return warnings\n                    .flatMap(w => w.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/))\n                    .filter((warning) => warning.match(/^\\d\\d\\d Elasticsearch-/));\n            }\n        };\n        // We should not retry if we are sending a stream body, because we should store in memory\n        // a copy of the stream to be able to send it again, but since we don't know in advance\n        // the size of the stream, we risk to take too much memory.\n        // Furthermore, copying every time the stream is very a expensive operation.\n        const maxRetries = isStream((_7 = params.body) !== null && _7 !== void 0 ? _7 : params.bulkBody) ? 0 : (typeof options.maxRetries === 'number' ? options.maxRetries : this[symbols_1.kMaxRetries]);\n        const compression = typeof options.compression === 'boolean' ? options.compression : this[symbols_1.kCompression];\n        const signal = options.signal;\n        const maxResponseSize = (_8 = options.maxResponseSize) !== null && _8 !== void 0 ? _8 : this[symbols_1.kMaxResponseSize];\n        const maxCompressedResponseSize = (_9 = options.maxCompressedResponseSize) !== null && _9 !== void 0 ? _9 : this[symbols_1.kMaxCompressedResponseSize];\n        const errorOptions = {\n            redaction: typeof options.redaction === 'object' ? options.redaction : this[symbols_1.kRedaction]\n        };\n        this[symbols_1.kDiagnostic].emit('serialization', null, result);\n        const headers = Object.assign({}, this[symbols_1.kHeaders], lowerCaseHeaders(options.headers));\n        if (options.opaqueId !== undefined) {\n            headers['x-opaque-id'] = typeof this[symbols_1.kOpaqueIdPrefix] === 'string'\n                ? this[symbols_1.kOpaqueIdPrefix] + options.opaqueId // eslint-disable-line\n                : options.opaqueId;\n        }\n        // handle json body\n        if (params.body != null) {\n            if (shouldSerialize(params.body)) {\n                try {\n                    connectionParams.body = this[symbols_1.kSerializer].serialize(params.body);\n                }\n                catch (err) {\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    throw err;\n                }\n                headers['content-type'] = (_10 = headers['content-type']) !== null && _10 !== void 0 ? _10 : this[symbols_1.kJsonContentType];\n                headers.accept = (_11 = headers.accept) !== null && _11 !== void 0 ? _11 : this[symbols_1.kJsonContentType];\n            }\n            else {\n                if (params.body !== '') {\n                    headers['content-type'] = (_12 = headers['content-type']) !== null && _12 !== void 0 ? _12 : 'text/plain';\n                    headers.accept = (_13 = headers.accept) !== null && _13 !== void 0 ? _13 : this[symbols_1.kAcceptHeader];\n                }\n                connectionParams.body = params.body;\n            }\n            // handle ndjson body\n        }\n        else if (params.bulkBody != null) {\n            if (shouldSerialize(params.bulkBody)) {\n                try {\n                    connectionParams.body = this[symbols_1.kSerializer].ndserialize(params.bulkBody);\n                }\n                catch (err) {\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    throw err;\n                }\n            }\n            else {\n                connectionParams.body = params.bulkBody;\n            }\n            if (connectionParams.body !== '') {\n                headers['content-type'] = (_14 = headers['content-type']) !== null && _14 !== void 0 ? _14 : this[symbols_1.kNdjsonContentType];\n                headers.accept = (_15 = headers.accept) !== null && _15 !== void 0 ? _15 : this[symbols_1.kJsonContentType];\n            }\n        }\n        // serializes the querystring\n        if (options.querystring == null) {\n            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(params.querystring);\n        }\n        else {\n            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(Object.assign({}, params.querystring, options.querystring));\n        }\n        // handle compression\n        if (connectionParams.body !== '' && connectionParams.body != null) {\n            if (isStream(connectionParams.body)) {\n                if (compression) {\n                    headers['content-encoding'] = 'gzip';\n                    connectionParams.body = connectionParams.body.pipe(createGzip());\n                }\n            }\n            else if (compression) {\n                try {\n                    connectionParams.body = await gzip(connectionParams.body);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    /* istanbul ignore next */\n                    throw err;\n                }\n                headers['content-encoding'] = 'gzip';\n                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line\n            }\n            else {\n                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line\n            }\n        }\n        headers.accept = (_16 = headers.accept) !== null && _16 !== void 0 ? _16 : this[symbols_1.kAcceptHeader];\n        connectionParams.headers = headers;\n        while (meta.attempts <= maxRetries) {\n            try {\n                if (signal === null || signal === void 0 ? void 0 : signal.aborted) { // eslint-disable-line\n                    throw new errors_1.RequestAbortedError('Request has been aborted by the user', result, errorOptions);\n                }\n                meta.connection = this.getConnection({\n                    requestId: meta.request.id,\n                    context: meta.context\n                });\n                if (meta.connection === null) {\n                    throw new errors_1.NoLivingConnectionsError('There are no living connections', result, errorOptions);\n                }\n                // generate required OpenTelemetry attributes from the request URL\n                const requestUrl = meta.connection.url;\n                otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttributes({\n                    'url.full': requestUrl.toString(),\n                    'server.address': requestUrl.hostname\n                });\n                if (requestUrl.port === '') {\n                    if (requestUrl.protocol === 'https:') {\n                        otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', 443);\n                    }\n                    else if (requestUrl.protocol === 'http:') {\n                        otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', 80);\n                    }\n                }\n                else if (requestUrl.port !== '9200') {\n                    otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('server.port', parseInt(requestUrl.port, 10));\n                }\n                this[symbols_1.kDiagnostic].emit('request', null, result);\n                // perform the actual http request\n                let { statusCode, headers, body } = await meta.connection.request(connectionParams, {\n                    requestId: meta.request.id,\n                    name: this[symbols_1.kName],\n                    context: meta.context,\n                    maxResponseSize,\n                    maxCompressedResponseSize,\n                    signal,\n                    timeout: toMs(options.requestTimeout != null ? options.requestTimeout : this[symbols_1.kRequestTimeout]),\n                    ...(options.asStream === true ? { asStream: true } : null)\n                });\n                result.statusCode = statusCode;\n                result.headers = headers;\n                if (headers['x-found-handling-cluster'] != null) {\n                    otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('db.elasticsearch.cluster.name', headers['x-found-handling-cluster']);\n                }\n                if (headers['x-found-handling-instance'] != null) {\n                    otelSpan === null || otelSpan === void 0 ? void 0 : otelSpan.setAttribute('db.elasticsearch.node.name', headers['x-found-handling-instance']);\n                }\n                if (this[symbols_1.kProductCheck] != null && headers['x-elastic-product'] !== this[symbols_1.kProductCheck] && statusCode >= 200 && statusCode < 300) {\n                    /* eslint-disable @typescript-eslint/prefer-ts-expect-error */\n                    // @ts-ignore\n                    throw new errors_1.ProductNotSupportedError(this[symbols_1.kProductCheck], result, errorOptions);\n                    /* eslint-enable @typescript-eslint/prefer-ts-expect-error */\n                }\n                if (options.asStream === true) {\n                    result.body = body;\n                    this[symbols_1.kDiagnostic].emit('response', null, result);\n                    return returnMeta ? result : body;\n                }\n                const contentEncoding = ((_17 = headers['content-encoding']) !== null && _17 !== void 0 ? _17 : '').toLowerCase();\n                if (contentEncoding.includes('gzip') || contentEncoding.includes('deflate')) {\n                    body = await unzip(body);\n                }\n                if (Buffer.isBuffer(body) && !(0, BaseConnection_1.isBinary)((_18 = headers['content-type']) !== null && _18 !== void 0 ? _18 : '')) {\n                    body = body.toString();\n                }\n                const isHead = params.method === 'HEAD';\n                // we should attempt the payload deserialization only if:\n                //    - a `content-type` is defined and is equal to `application/json`\n                //    - the request is not a HEAD request\n                //    - the payload is not an empty string\n                if (headers['content-type'] !== undefined &&\n                    (((_19 = headers['content-type']) === null || _19 === void 0 ? void 0 : _19.includes('application/json')) ||\n                        ((_20 = headers['content-type']) === null || _20 === void 0 ? void 0 : _20.includes('application/vnd.elasticsearch+json'))) &&\n                    !isHead && body !== '') { // eslint-disable-line\n                    result.body = this[symbols_1.kSerializer].deserialize(body);\n                }\n                else {\n                    // cast to boolean if the request method was HEAD and there was no error\n                    result.body = isHead && statusCode < 400 ? true : body;\n                }\n                // we should ignore the statusCode if the user has configured the `ignore` field with\n                // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n                const ignoreStatusCode = (Array.isArray(options.ignore) && options.ignore.includes(statusCode)) ||\n                    (isHead && statusCode === 404);\n                if (!ignoreStatusCode && (statusCode === 502 || statusCode === 503 || statusCode === 504)) {\n                    // if the statusCode is 502/3/4 we should run our retry strategy\n                    // and mark the connection as dead\n                    this[symbols_1.kConnectionPool].markDead(meta.connection);\n                    // retry logic\n                    if (meta.attempts < maxRetries) {\n                        meta.attempts++;\n                        debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n                        continue;\n                    }\n                }\n                else {\n                    // everything has worked as expected, let's mark\n                    // the connection as alive (or confirm it)\n                    this[symbols_1.kConnectionPool].markAlive(meta.connection);\n                }\n                if (!ignoreStatusCode && statusCode >= 400) {\n                    throw new errors_1.ResponseError(result, errorOptions);\n                }\n                else {\n                    // cast to boolean if the request method was HEAD\n                    if (isHead && statusCode === 404) {\n                        result.body = false;\n                    }\n                    this[symbols_1.kDiagnostic].emit('response', null, result);\n                    return returnMeta ? result : result.body;\n                }\n            }\n            catch (error) {\n                switch (error.name) {\n                    // should not retry\n                    case 'ProductNotSupportedError':\n                    case 'NoLivingConnectionsError':\n                    case 'DeserializationError':\n                    case 'ResponseError':\n                        this[symbols_1.kDiagnostic].emit('response', error, result);\n                        throw error;\n                    case 'RequestAbortedError': {\n                        meta.aborted = true;\n                        // Wrap the error to get a clean stack trace\n                        const wrappedError = new errors_1.RequestAbortedError(error.message, result, errorOptions);\n                        this[symbols_1.kDiagnostic].emit('response', wrappedError, result);\n                        throw wrappedError;\n                    }\n                    // should maybe retry\n                    // @ts-expect-error `case` fallthrough is intentional: should retry if retryOnTimeout is true\n                    case 'TimeoutError':\n                        if (!this[symbols_1.kRetryOnTimeout]) {\n                            const wrappedError = new errors_1.TimeoutError(error.message, result, errorOptions);\n                            this[symbols_1.kDiagnostic].emit('response', wrappedError, result);\n                            throw wrappedError;\n                        }\n                    // should retry\n                    // eslint-disable-next-line no-fallthrough\n                    case 'ConnectionError': {\n                        // if there is an error in the connection\n                        // let's mark the connection as dead\n                        this[symbols_1.kConnectionPool].markDead(meta.connection);\n                        if (this[symbols_1.kSniffOnConnectionFault]) {\n                            this.sniff({\n                                reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n                                requestId: meta.request.id,\n                                context: meta.context\n                            });\n                        }\n                        // retry logic\n                        if (meta.attempts < maxRetries) {\n                            meta.attempts++;\n                            debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n                            // don't use exponential backoff until retrying on each node\n                            if (meta.attempts >= this[symbols_1.kConnectionPool].size) {\n                                // exponential backoff on retries, with jitter\n                                const backoff = (_21 = options.retryBackoff) !== null && _21 !== void 0 ? _21 : this[symbols_1.kRetryBackoff];\n                                const backoffWait = backoff(0, 4, meta.attempts);\n                                if (backoffWait > 0) {\n                                    await (0, promises_1.setTimeout)(backoffWait * 1000);\n                                }\n                            }\n                            continue;\n                        }\n                        // Wrap the error to get a clean stack trace\n                        const wrappedError = error.name === 'TimeoutError'\n                            ? new errors_1.TimeoutError(error.message, result, errorOptions)\n                            : new errors_1.ConnectionError(error.message, result, errorOptions);\n                        this[symbols_1.kDiagnostic].emit('response', wrappedError, result);\n                        throw wrappedError;\n                    }\n                    // edge cases, such as bad compression\n                    default:\n                        this[symbols_1.kDiagnostic].emit('response', error, result);\n                        throw error;\n                }\n            }\n        }\n        return returnMeta ? result : result.body;\n    }\n    async request(params, options = {}) {\n        var _5, _6, _7;\n        // wrap in OpenTelemetry span\n        if (((_5 = params.meta) === null || _5 === void 0 ? void 0 : _5.name) != null) {\n            // gather OpenTelemetry attributes\n            const attributes = {\n                'db.system': 'elasticsearch',\n                'http.request.method': params.method,\n                'db.operation.name': (_6 = params.meta) === null || _6 === void 0 ? void 0 : _6.name\n            };\n            if (((_7 = params.meta) === null || _7 === void 0 ? void 0 : _7.pathParts) != null) {\n                for (const key of Object.keys(params.meta.pathParts)) {\n                    attributes[`db.elasticsearch.path_parts.${key}`] = params.meta.pathParts[key];\n                }\n            }\n            return await this[symbols_1.kOtelTracer].startActiveSpan(params.meta.name, { attributes, kind: api_1.SpanKind.CLIENT }, async (otelSpan) => {\n                var _5;\n                let response;\n                try {\n                    response = await this._request(params, options, otelSpan);\n                }\n                catch (err) {\n                    otelSpan.recordException(err);\n                    otelSpan.setStatus({ code: api_1.SpanStatusCode.ERROR });\n                    otelSpan.setAttribute('error.type', (_5 = err.name) !== null && _5 !== void 0 ? _5 : 'Error');\n                    throw err;\n                }\n                finally {\n                    otelSpan.end();\n                }\n                return response;\n            });\n        }\n        else {\n            return await this._request(params, options);\n        }\n    }\n    getConnection(opts) {\n        const now = Date.now();\n        if (this[symbols_1.kSniffEnabled] && now > this[symbols_1.kNextSniff]) {\n            this[symbols_1.kNextSniff] = now + this[symbols_1.kSniffInterval];\n            this.sniff({\n                reason: Transport.sniffReasons.SNIFF_INTERVAL,\n                requestId: opts.requestId,\n                context: opts.context\n            });\n        }\n        return this[symbols_1.kConnectionPool].getConnection({\n            filter: this[symbols_1.kNodeFilter],\n            selector: this[symbols_1.kNodeSelector],\n            requestId: opts.requestId,\n            name: this[symbols_1.kName],\n            context: opts.context,\n            now\n        });\n    }\n    /* istanbul ignore next */\n    sniff(opts) { }\n}\n_a = symbols_1.kNodeFilter, _b = symbols_1.kNodeSelector, _c = symbols_1.kHeaders, _d = symbols_1.kDiagnostic, _e = symbols_1.kConnectionPool, _f = symbols_1.kSerializer, _g = symbols_1.kContext, _h = symbols_1.kGenerateRequestId, _j = symbols_1.kOpaqueIdPrefix, _k = symbols_1.kName, _l = symbols_1.kMaxRetries, _m = symbols_1.kCompression, _o = symbols_1.kRequestTimeout, _p = symbols_1.kRetryOnTimeout, _q = symbols_1.kSniffEnabled, _r = symbols_1.kNextSniff, _s = symbols_1.kIsSniffing, _t = symbols_1.kSniffInterval, _u = symbols_1.kSniffOnConnectionFault, _v = symbols_1.kSniffEndpoint, _w = symbols_1.kProductCheck, _x = symbols_1.kMaxResponseSize, _y = symbols_1.kMaxCompressedResponseSize, _z = symbols_1.kJsonContentType, _0 = symbols_1.kNdjsonContentType, _1 = symbols_1.kAcceptHeader, _2 = symbols_1.kRedaction, _3 = symbols_1.kRetryBackoff, _4 = symbols_1.kOtelTracer;\nObject.defineProperty(Transport, \"sniffReasons\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        SNIFF_ON_START: 'sniff-on-start',\n        SNIFF_INTERVAL: 'sniff-interval',\n        SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n        DEFAULT: 'default'\n    }\n});\nexports[\"default\"] = Transport;\nfunction toMs(time) {\n    if (typeof time === 'string') {\n        return (0, ms_1.default)(time);\n    }\n    return time;\n}\nfunction shouldSerialize(obj) {\n    return typeof obj !== 'string' &&\n        typeof obj.pipe !== 'function' &&\n        !Buffer.isBuffer(obj);\n}\nfunction isStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction defaultNodeFilter(node) {\n    return true;\n}\nfunction roundRobinSelector() {\n    let current = -1;\n    return function _roundRobinSelector(connections) {\n        if (++current >= connections.length) {\n            current = 0;\n        }\n        return connections[current];\n    };\n}\nfunction generateRequestId() {\n    const maxInt = 2147483647;\n    let nextReqId = 0;\n    return function genReqId(params, options) {\n        return (nextReqId = (nextReqId + 1) & maxInt);\n    };\n}\nfunction lowerCaseHeaders(oldHeaders) {\n    if (oldHeaders == null)\n        return null;\n    const newHeaders = {};\n    for (const header in oldHeaders) {\n        // @ts-expect-error\n        newHeaders[header.toLowerCase()] = oldHeaders[header];\n    }\n    return newHeaders;\n}\n/**\n * Function for calculating how long to sleep, in seconds, before the next request retry\n * Uses the AWS \"equal jitter\" algorithm noted in this post:\n * https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\n * @param min The minimum number of seconds to wait\n * @param max The maximum number of seconds to wait\n * @param attempt How many retry attempts have been made\n * @returns The number of seconds to wait before the next retry\n */\nfunction retryBackoff(min, max, attempt) {\n    const ceiling = Math.min(max, 2 ** attempt) / 2;\n    return ceiling + ((Math.random() * (ceiling - min)) + min);\n}\n//# sourceMappingURL=Transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9UcmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0Isd0NBQXdDLG1CQUFPLENBQUMsc0RBQU87QUFDdkQsMENBQTBDLG1CQUFPLENBQUMsd0JBQVM7QUFDM0QsNENBQTRDLG1CQUFPLENBQUMsNEJBQVc7QUFDL0QsOENBQThDLG1CQUFPLENBQUMsZ0NBQWE7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsNEJBQVc7QUFDdkMsK0NBQStDLG1CQUFPLENBQUMsa0NBQWM7QUFDckUscUNBQXFDLG1CQUFPLENBQUMsNENBQUk7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsdUVBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMsNkdBQTZCO0FBQzlELDZDQUE2QyxtQkFBTyxDQUFDLCtFQUFjO0FBQ25FLDZDQUE2QyxtQkFBTyxDQUFDLCtFQUFjO0FBQ25FLGtCQUFrQixtQkFBTyxDQUFDLHlFQUFXO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLGtEQUFzQjtBQUNqRCxtQ0FBbUMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDL0QsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLDZFQUFpQixHQUFHO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQiwwQ0FBMEMsZUFBZSxHQUFHLDhCQUE4QixFQUFFLDRCQUE0QixHQUFHLDJCQUEyQixVQUFVLCtCQUErQixJQUFJO0FBQ25NO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLGtEQUFrRDtBQUNqSjtBQUNBO0FBQ0EseUdBQXlHLDJDQUEyQztBQUNwSjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSx5QkFBeUIsZ0NBQWdDLG9DQUFvQztBQUNwSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UscURBQXFELElBQUksbUNBQW1DO0FBQzVKO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtHQUFrRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLDRCQUE0QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSw0QkFBNEI7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsSUFBSTtBQUNsRTtBQUNBO0FBQ0EseUZBQXlGLHlDQUF5QztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQ0FBa0M7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL1RyYW5zcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94LCBfeSwgX3osIF8wLCBfMSwgXzIsIF8zLCBfNDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVSZXF1ZXN0SWQgPSBnZW5lcmF0ZVJlcXVlc3RJZDtcbmV4cG9ydHMubG93ZXJDYXNlSGVhZGVycyA9IGxvd2VyQ2FzZUhlYWRlcnM7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgZGVidWdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBub2RlX29zXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpvc1wiKSk7XG5jb25zdCBub2RlX3psaWJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnpsaWJcIikpO1xuY29uc3Qgbm9kZV9idWZmZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOmJ1ZmZlclwiKSk7XG5jb25zdCBub2RlX3V0aWxfMSA9IHJlcXVpcmUoXCJub2RlOnV0aWxcIik7XG5jb25zdCBub2RlX3Byb2Nlc3NfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnByb2Nlc3NcIikpO1xuY29uc3QgbXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJtc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IEJhc2VDb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uL0Jhc2VDb25uZWN0aW9uXCIpO1xuY29uc3QgRGlhZ25vc3RpY18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vRGlhZ25vc3RpY1wiKSk7XG5jb25zdCBTZXJpYWxpemVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TZXJpYWxpemVyXCIpKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG5jb25zdCBwcm9taXNlc18xID0gcmVxdWlyZShcIm5vZGU6dGltZXJzL3Byb21pc2VzXCIpO1xuY29uc3QgYXBpXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpKTtcbmNvbnN0IHsgdmVyc2lvbjogY2xpZW50VmVyc2lvbiB9ID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ2VsYXN0aWNzZWFyY2gnKTtcbmNvbnN0IGd6aXAgPSAoMCwgbm9kZV91dGlsXzEucHJvbWlzaWZ5KShub2RlX3psaWJfMS5kZWZhdWx0Lmd6aXApO1xuY29uc3QgdW56aXAgPSAoMCwgbm9kZV91dGlsXzEucHJvbWlzaWZ5KShub2RlX3psaWJfMS5kZWZhdWx0LnVuemlwKTtcbmNvbnN0IHsgY3JlYXRlR3ppcCB9ID0gbm9kZV96bGliXzEuZGVmYXVsdDtcbmNvbnN0IHVzZXJBZ2VudCA9IGBlbGFzdGljLXRyYW5zcG9ydC1qcy8ke2NsaWVudFZlcnNpb259ICgke25vZGVfb3NfMS5kZWZhdWx0LnBsYXRmb3JtKCl9ICR7bm9kZV9vc18xLmRlZmF1bHQucmVsZWFzZSgpfS0ke25vZGVfb3NfMS5kZWZhdWx0LmFyY2goKX07IE5vZGUuanMgJHtub2RlX3Byb2Nlc3NfMS5kZWZhdWx0LnZlcnNpb259KWA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmNsYXNzIFRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgXzUsIF82LCBfNywgXzgsIF85LCBfMTAsIF8xMSwgXzEyLCBfMTMsIF8xNCwgXzE1LCBfMTYsIF8xNywgXzE4LCBfMTksIF8yMCwgXzIxLCBfMjIsIF8yMywgXzI0LCBfMjUsIF8yNjtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9hLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2IsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfYywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9kLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2UsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfZiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9nLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2gsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfaiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9rLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfbSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9vLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3AsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfcSwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9yLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3MsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfdCwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF91LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3YsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfdywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF94LCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3ksIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfeiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8wLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXzEsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfMiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF8zLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXzQsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRzLmNvbm5lY3Rpb25Qb29sID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ1RoZSBDb25uZWN0aW9uIFBvb2wgb3B0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLm1heFJldHJpZXMgPT09ICdudW1iZXInICYmIG9wdHMubWF4UmV0cmllcyA8IDAgJiYgTnVtYmVyLmlzSW50ZWdlcihvcHRzLm1heFJldHJpZXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZmlndXJhdGlvbkVycm9yKCdUaGUgbWF4UmV0cmllcyBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgb3IgemVybycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnNuaWZmSW50ZXJ2YWwgPT09IHRydWUgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zbmlmZkludGVydmFsID09PSAnbnVtYmVyJyAmJiBvcHRzLnNuaWZmSW50ZXJ2YWwgPCAwICYmIE51bWJlci5pc0ludGVnZXIob3B0cy5zbmlmZkludGVydmFsKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ1RoZSBzbmlmZkludGVydmFsIG9wdGlvbiBtdXN0IGJlIGZhbHNlIG9yIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm1heFJlc3BvbnNlU2l6ZSAhPSBudWxsICYmIG9wdHMubWF4UmVzcG9uc2VTaXplID4gbm9kZV9idWZmZXJfMS5kZWZhdWx0LmNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbmZpZ3VyYXRpb25FcnJvcihgVGhlIG1heFJlc3BvbnNlU2l6ZSBjYW5ub3QgYmUgYmlnZ2VyIHRoYW4gJHtub2RlX2J1ZmZlcl8xLmRlZmF1bHQuY29uc3RhbnRzLk1BWF9TVFJJTkdfTEVOR1RIfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm1heENvbXByZXNzZWRSZXNwb25zZVNpemUgIT0gbnVsbCAmJiBvcHRzLm1heENvbXByZXNzZWRSZXNwb25zZVNpemUgPiBub2RlX2J1ZmZlcl8xLmRlZmF1bHQuY29uc3RhbnRzLk1BWF9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoYFRoZSBtYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplIGNhbm5vdCBiZSBiaWdnZXIgdGhhbiAke25vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX0xFTkdUSH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rTm9kZUZpbHRlcl0gPSAoXzUgPSBvcHRzLm5vZGVGaWx0ZXIpICE9PSBudWxsICYmIF81ICE9PSB2b2lkIDAgPyBfNSA6IGRlZmF1bHROb2RlRmlsdGVyO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rTm9kZVNlbGVjdG9yXSA9IChfNiA9IG9wdHMubm9kZVNlbGVjdG9yKSAhPT0gbnVsbCAmJiBfNiAhPT0gdm9pZCAwID8gXzYgOiByb3VuZFJvYmluU2VsZWN0b3IoKTtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua0hlYWRlcnNdID0gT2JqZWN0LmFzc2lnbih7fSwgeyAndXNlci1hZ2VudCc6IHVzZXJBZ2VudCB9LCBvcHRzLmNvbXByZXNzaW9uID09PSB0cnVlID8geyAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsZGVmbGF0ZScgfSA6IG51bGwsIGxvd2VyQ2FzZUhlYWRlcnMob3B0cy5oZWFkZXJzKSk7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXSA9IChfNyA9IG9wdHMuZGlhZ25vc3RpYykgIT09IG51bGwgJiYgXzcgIT09IHZvaWQgMCA/IF83IDogbmV3IERpYWdub3N0aWNfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtDb25uZWN0aW9uUG9vbF0gPSBvcHRzLmNvbm5lY3Rpb25Qb29sO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rU2VyaWFsaXplcl0gPSAoXzggPSBvcHRzLnNlcmlhbGl6ZXIpICE9PSBudWxsICYmIF84ICE9PSB2b2lkIDAgPyBfOCA6IG5ldyBTZXJpYWxpemVyXzEuZGVmYXVsdCgpO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rQ29udGV4dF0gPSAoXzkgPSBvcHRzLmNvbnRleHQpICE9PSBudWxsICYmIF85ICE9PSB2b2lkIDAgPyBfOSA6IG51bGw7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtHZW5lcmF0ZVJlcXVlc3RJZF0gPSAoXzEwID0gb3B0cy5nZW5lcmF0ZVJlcXVlc3RJZCkgIT09IG51bGwgJiYgXzEwICE9PSB2b2lkIDAgPyBfMTAgOiBnZW5lcmF0ZVJlcXVlc3RJZCgpO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rT3BhcXVlSWRQcmVmaXhdID0gKF8xMSA9IG9wdHMub3BhcXVlSWRQcmVmaXgpICE9PSBudWxsICYmIF8xMSAhPT0gdm9pZCAwID8gXzExIDogbnVsbDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua05hbWVdID0gKF8xMiA9IG9wdHMubmFtZSkgIT09IG51bGwgJiYgXzEyICE9PSB2b2lkIDAgPyBfMTIgOiAnZWxhc3RpYy10cmFuc3BvcnQtanMnO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rTWF4UmV0cmllc10gPSB0eXBlb2Ygb3B0cy5tYXhSZXRyaWVzID09PSAnbnVtYmVyJyA/IG9wdHMubWF4UmV0cmllcyA6IDM7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtDb21wcmVzc2lvbl0gPSBvcHRzLmNvbXByZXNzaW9uID09PSB0cnVlO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rUmVxdWVzdFRpbWVvdXRdID0gb3B0cy5yZXF1ZXN0VGltZW91dCAhPSBudWxsID8gdG9NcyhvcHRzLnJlcXVlc3RUaW1lb3V0KSA6IDMwMDAwO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rUmV0cnlPblRpbWVvdXRdID0gb3B0cy5yZXRyeU9uVGltZW91dCAhPSBudWxsID8gb3B0cy5yZXRyeU9uVGltZW91dCA6IGZhbHNlO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rU25pZmZJbnRlcnZhbF0gPSAoXzEzID0gb3B0cy5zbmlmZkludGVydmFsKSAhPT0gbnVsbCAmJiBfMTMgIT09IHZvaWQgMCA/IF8xMyA6IGZhbHNlO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rU25pZmZFbmFibGVkXSA9IHR5cGVvZiB0aGlzW3N5bWJvbHNfMS5rU25pZmZJbnRlcnZhbF0gPT09ICdudW1iZXInO1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rTmV4dFNuaWZmXSA9IHRoaXNbc3ltYm9sc18xLmtTbmlmZkVuYWJsZWRdID8gKERhdGUubm93KCkgKyB0aGlzW3N5bWJvbHNfMS5rU25pZmZJbnRlcnZhbF0pIDogMDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua0lzU25pZmZpbmddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtTbmlmZk9uQ29ubmVjdGlvbkZhdWx0XSA9IChfMTQgPSBvcHRzLnNuaWZmT25Db25uZWN0aW9uRmF1bHQpICE9PSBudWxsICYmIF8xNCAhPT0gdm9pZCAwID8gXzE0IDogZmFsc2U7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtTbmlmZkVuZHBvaW50XSA9IChfMTUgPSBvcHRzLnNuaWZmRW5kcG9pbnQpICE9PSBudWxsICYmIF8xNSAhPT0gdm9pZCAwID8gXzE1IDogbnVsbDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua1Byb2R1Y3RDaGVja10gPSAoXzE2ID0gb3B0cy5wcm9kdWN0Q2hlY2spICE9PSBudWxsICYmIF8xNiAhPT0gdm9pZCAwID8gXzE2IDogbnVsbDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua01heFJlc3BvbnNlU2l6ZV0gPSAoXzE3ID0gb3B0cy5tYXhSZXNwb25zZVNpemUpICE9PSBudWxsICYmIF8xNyAhPT0gdm9pZCAwID8gXzE3IDogbm9kZV9idWZmZXJfMS5kZWZhdWx0LmNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua01heENvbXByZXNzZWRSZXNwb25zZVNpemVdID0gKF8xOCA9IG9wdHMubWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSkgIT09IG51bGwgJiYgXzE4ICE9PSB2b2lkIDAgPyBfMTggOiBub2RlX2J1ZmZlcl8xLmRlZmF1bHQuY29uc3RhbnRzLk1BWF9MRU5HVEg7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtKc29uQ29udGVudFR5cGVdID0gKF8yMCA9IChfMTkgPSBvcHRzLnZlbmRvcmVkSGVhZGVycykgPT09IG51bGwgfHwgXzE5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfMTkuanNvbkNvbnRlbnRUeXBlKSAhPT0gbnVsbCAmJiBfMjAgIT09IHZvaWQgMCA/IF8yMCA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua05kanNvbkNvbnRlbnRUeXBlXSA9IChfMjIgPSAoXzIxID0gb3B0cy52ZW5kb3JlZEhlYWRlcnMpID09PSBudWxsIHx8IF8yMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogXzIxLm5kanNvbkNvbnRlbnRUeXBlKSAhPT0gbnVsbCAmJiBfMjIgIT09IHZvaWQgMCA/IF8yMiA6ICdhcHBsaWNhdGlvbi94LW5kanNvbic7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtBY2NlcHRIZWFkZXJdID0gKF8yNCA9IChfMjMgPSBvcHRzLnZlbmRvcmVkSGVhZGVycykgPT09IG51bGwgfHwgXzIzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfMjMuYWNjZXB0KSAhPT0gbnVsbCAmJiBfMjQgIT09IHZvaWQgMCA/IF8yNCA6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluJztcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua1JlZGFjdGlvbl0gPSAoXzI1ID0gb3B0cy5yZWRhY3Rpb24pICE9PSBudWxsICYmIF8yNSAhPT0gdm9pZCAwID8gXzI1IDogeyB0eXBlOiAncmVwbGFjZScsIGFkZGl0aW9uYWxLZXlzOiBbXSB9O1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rUmV0cnlCYWNrb2ZmXSA9IChfMjYgPSBvcHRzLnJldHJ5QmFja29mZikgIT09IG51bGwgJiYgXzI2ICE9PSB2b2lkIDAgPyBfMjYgOiByZXRyeUJhY2tvZmY7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtPdGVsVHJhY2VyXSA9IGFwaV8xLmRlZmF1bHQudHJhY2UuZ2V0VHJhY2VyKCdAZWxhc3RpYy90cmFuc3BvcnQnLCBjbGllbnRWZXJzaW9uKTtcbiAgICAgICAgaWYgKG9wdHMuc25pZmZPblN0YXJ0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnNuaWZmKHtcbiAgICAgICAgICAgICAgICByZWFzb246IFRyYW5zcG9ydC5zbmlmZlJlYXNvbnMuU05JRkZfT05fU1RBUlQsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkOiB0aGlzW3N5bWJvbHNfMS5rR2VuZXJhdGVSZXF1ZXN0SWRdKHsgbWV0aG9kOiAnR0VUJywgcGF0aDogdGhpc1tzeW1ib2xzXzEua1NuaWZmRW5kcG9pbnRdIH0sIHsgY29udGV4dDogdGhpc1tzeW1ib2xzXzEua0NvbnRleHRdIH0pLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXNbc3ltYm9sc18xLmtDb250ZXh0XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNvbm5lY3Rpb25Qb29sKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzeW1ib2xzXzEua0Nvbm5lY3Rpb25Qb29sXTtcbiAgICB9XG4gICAgZ2V0IHNuaWZmRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbc3ltYm9sc18xLmtTbmlmZkVuYWJsZWRdO1xuICAgIH1cbiAgICBnZXQgbmV4dFNuaWZmKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzeW1ib2xzXzEua05leHRTbmlmZl07XG4gICAgfVxuICAgIGdldCBzbmlmZkVuZHBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzeW1ib2xzXzEua1NuaWZmRW5kcG9pbnRdO1xuICAgIH1cbiAgICBnZXQgaXNTbmlmZmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbc3ltYm9sc18xLmtJc1NuaWZmaW5nXTtcbiAgICB9XG4gICAgc2V0IGlzU25pZmZpbmcodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoYGlzU25pZmZpbmcgbXVzdCBiZSBhIGJvb2xlYW4sIGluc3RlYWQgZ290ICR7dHlwZW9mIHZhbH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rSXNTbmlmZmluZ10gPSB2YWw7XG4gICAgfVxuICAgIGdldCBkaWFnbm9zdGljKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzeW1ib2xzXzEua0RpYWdub3N0aWNdO1xuICAgIH1cbiAgICBhc3luYyBfcmVxdWVzdChwYXJhbXMsIG9wdGlvbnMgPSB7fSwgb3RlbFNwYW4pIHtcbiAgICAgICAgdmFyIF81LCBfNiwgXzcsIF84LCBfOSwgXzEwLCBfMTEsIF8xMiwgXzEzLCBfMTQsIF8xNSwgXzE2LCBfMTcsIF8xOCwgXzE5LCBfMjAsIF8yMTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvblBhcmFtcyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcy5wYXRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICAgICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgIHBhcmFtczogY29ubmVjdGlvblBhcmFtcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIGlkOiAoXzUgPSBvcHRpb25zLmlkKSAhPT0gbnVsbCAmJiBfNSAhPT0gdm9pZCAwID8gXzUgOiB0aGlzW3N5bWJvbHNfMS5rR2VuZXJhdGVSZXF1ZXN0SWRdKHBhcmFtcywgb3B0aW9ucylcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuYW1lOiB0aGlzW3N5bWJvbHNfMS5rTmFtZV0sXG4gICAgICAgICAgICBjb25uZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgYXR0ZW1wdHM6IDAsXG4gICAgICAgICAgICBhYm9ydGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXR1cm5NZXRhID0gKF82ID0gb3B0aW9ucy5tZXRhKSAhPT0gbnVsbCAmJiBfNiAhPT0gdm9pZCAwID8gXzYgOiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXNbc3ltYm9sc18xLmtDb250ZXh0XSAhPSBudWxsICYmIG9wdGlvbnMuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBtZXRhLmNvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzW3N5bWJvbHNfMS5rQ29udGV4dF0sIG9wdGlvbnMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpc1tzeW1ib2xzXzEua0NvbnRleHRdICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtZXRhLmNvbnRleHQgPSB0aGlzW3N5bWJvbHNfMS5rQ29udGV4dF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1ldGEuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAvLyB0aGUgZGVmYXVsdCBib2R5IHZhbHVlIGNhbid0IGJlIGBudWxsYFxuICAgICAgICAgICAgLy8gYXMgaXQncyBhIHZhbGlkIEpTT04gdmFsdWVcbiAgICAgICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICBnZXQgd2FybmluZ3MoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF81O1xuICAgICAgICAgICAgICAgIGlmICgoKF81ID0gdGhpcy5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogXzUud2FybmluZykgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3YXJuaW5nIH0gPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgICAgICAgICAgLy8gaWYgbXVsdGlwbGUgSFRUUCBoZWFkZXJzIGhhdmUgdGhlIHNhbWUgbmFtZSwgVW5kaWNpIHJlcHJlc2VudHMgdGhlbSBhcyBhbiBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gQXJyYXkuaXNBcnJheSh3YXJuaW5nKSA/IHdhcm5pbmcgOiBbd2FybmluZ107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhcm5pbmdzXG4gICAgICAgICAgICAgICAgICAgIC5mbGF0TWFwKHcgPT4gdy5zcGxpdCgvKD8hXFxCXCJbXlwiXSopLCg/IVteXCJdKlwiXFxCKS8pKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh3YXJuaW5nKSA9PiB3YXJuaW5nLm1hdGNoKC9eXFxkXFxkXFxkIEVsYXN0aWNzZWFyY2gtLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHJldHJ5IGlmIHdlIGFyZSBzZW5kaW5nIGEgc3RyZWFtIGJvZHksIGJlY2F1c2Ugd2Ugc2hvdWxkIHN0b3JlIGluIG1lbW9yeVxuICAgICAgICAvLyBhIGNvcHkgb2YgdGhlIHN0cmVhbSB0byBiZSBhYmxlIHRvIHNlbmQgaXQgYWdhaW4sIGJ1dCBzaW5jZSB3ZSBkb24ndCBrbm93IGluIGFkdmFuY2VcbiAgICAgICAgLy8gdGhlIHNpemUgb2YgdGhlIHN0cmVhbSwgd2UgcmlzayB0byB0YWtlIHRvbyBtdWNoIG1lbW9yeS5cbiAgICAgICAgLy8gRnVydGhlcm1vcmUsIGNvcHlpbmcgZXZlcnkgdGltZSB0aGUgc3RyZWFtIGlzIHZlcnkgYSBleHBlbnNpdmUgb3BlcmF0aW9uLlxuICAgICAgICBjb25zdCBtYXhSZXRyaWVzID0gaXNTdHJlYW0oKF83ID0gcGFyYW1zLmJvZHkpICE9PSBudWxsICYmIF83ICE9PSB2b2lkIDAgPyBfNyA6IHBhcmFtcy5idWxrQm9keSkgPyAwIDogKHR5cGVvZiBvcHRpb25zLm1heFJldHJpZXMgPT09ICdudW1iZXInID8gb3B0aW9ucy5tYXhSZXRyaWVzIDogdGhpc1tzeW1ib2xzXzEua01heFJldHJpZXNdKTtcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb24gPSB0eXBlb2Ygb3B0aW9ucy5jb21wcmVzc2lvbiA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5jb21wcmVzc2lvbiA6IHRoaXNbc3ltYm9sc18xLmtDb21wcmVzc2lvbl07XG4gICAgICAgIGNvbnN0IHNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsO1xuICAgICAgICBjb25zdCBtYXhSZXNwb25zZVNpemUgPSAoXzggPSBvcHRpb25zLm1heFJlc3BvbnNlU2l6ZSkgIT09IG51bGwgJiYgXzggIT09IHZvaWQgMCA/IF84IDogdGhpc1tzeW1ib2xzXzEua01heFJlc3BvbnNlU2l6ZV07XG4gICAgICAgIGNvbnN0IG1heENvbXByZXNzZWRSZXNwb25zZVNpemUgPSAoXzkgPSBvcHRpb25zLm1heENvbXByZXNzZWRSZXNwb25zZVNpemUpICE9PSBudWxsICYmIF85ICE9PSB2b2lkIDAgPyBfOSA6IHRoaXNbc3ltYm9sc18xLmtNYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplXTtcbiAgICAgICAgY29uc3QgZXJyb3JPcHRpb25zID0ge1xuICAgICAgICAgICAgcmVkYWN0aW9uOiB0eXBlb2Ygb3B0aW9ucy5yZWRhY3Rpb24gPT09ICdvYmplY3QnID8gb3B0aW9ucy5yZWRhY3Rpb24gOiB0aGlzW3N5bWJvbHNfMS5rUmVkYWN0aW9uXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY10uZW1pdCgnc2VyaWFsaXphdGlvbicsIG51bGwsIHJlc3VsdCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzW3N5bWJvbHNfMS5rSGVhZGVyc10sIGxvd2VyQ2FzZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKSk7XG4gICAgICAgIGlmIChvcHRpb25zLm9wYXF1ZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ3gtb3BhcXVlLWlkJ10gPSB0eXBlb2YgdGhpc1tzeW1ib2xzXzEua09wYXF1ZUlkUHJlZml4XSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IHRoaXNbc3ltYm9sc18xLmtPcGFxdWVJZFByZWZpeF0gKyBvcHRpb25zLm9wYXF1ZUlkIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgICAgICA6IG9wdGlvbnMub3BhcXVlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGpzb24gYm9keVxuICAgICAgICBpZiAocGFyYW1zLmJvZHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNlcmlhbGl6ZShwYXJhbXMuYm9keSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUGFyYW1zLmJvZHkgPSB0aGlzW3N5bWJvbHNfMS5rU2VyaWFsaXplcl0uc2VyaWFsaXplKHBhcmFtcy5ib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY10uZW1pdCgncmVxdWVzdCcsIGVyciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IChfMTAgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSkgIT09IG51bGwgJiYgXzEwICE9PSB2b2lkIDAgPyBfMTAgOiB0aGlzW3N5bWJvbHNfMS5rSnNvbkNvbnRlbnRUeXBlXTtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IChfMTEgPSBoZWFkZXJzLmFjY2VwdCkgIT09IG51bGwgJiYgXzExICE9PSB2b2lkIDAgPyBfMTEgOiB0aGlzW3N5bWJvbHNfMS5rSnNvbkNvbnRlbnRUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYm9keSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAoXzEyID0gaGVhZGVyc1snY29udGVudC10eXBlJ10pICE9PSBudWxsICYmIF8xMiAhPT0gdm9pZCAwID8gXzEyIDogJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IChfMTMgPSBoZWFkZXJzLmFjY2VwdCkgIT09IG51bGwgJiYgXzEzICE9PSB2b2lkIDAgPyBfMTMgOiB0aGlzW3N5bWJvbHNfMS5rQWNjZXB0SGVhZGVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblBhcmFtcy5ib2R5ID0gcGFyYW1zLmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgbmRqc29uIGJvZHlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJhbXMuYnVsa0JvZHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNlcmlhbGl6ZShwYXJhbXMuYnVsa0JvZHkpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvblBhcmFtcy5ib2R5ID0gdGhpc1tzeW1ib2xzXzEua1NlcmlhbGl6ZXJdLm5kc2VyaWFsaXplKHBhcmFtcy5idWxrQm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xzXzEua0RpYWdub3N0aWNdLmVtaXQoJ3JlcXVlc3QnLCBlcnIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUGFyYW1zLmJvZHkgPSBwYXJhbXMuYnVsa0JvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvblBhcmFtcy5ib2R5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gKF8xNCA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSAhPT0gbnVsbCAmJiBfMTQgIT09IHZvaWQgMCA/IF8xNCA6IHRoaXNbc3ltYm9sc18xLmtOZGpzb25Db250ZW50VHlwZV07XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hY2NlcHQgPSAoXzE1ID0gaGVhZGVycy5hY2NlcHQpICE9PSBudWxsICYmIF8xNSAhPT0gdm9pZCAwID8gXzE1IDogdGhpc1tzeW1ib2xzXzEua0pzb25Db250ZW50VHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VyaWFsaXplcyB0aGUgcXVlcnlzdHJpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMucXVlcnlzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvblBhcmFtcy5xdWVyeXN0cmluZyA9IHRoaXNbc3ltYm9sc18xLmtTZXJpYWxpemVyXS5xc2VyaWFsaXplKHBhcmFtcy5xdWVyeXN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uUGFyYW1zLnF1ZXJ5c3RyaW5nID0gdGhpc1tzeW1ib2xzXzEua1NlcmlhbGl6ZXJdLnFzZXJpYWxpemUoT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLnF1ZXJ5c3RyaW5nLCBvcHRpb25zLnF1ZXJ5c3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGNvbXByZXNzaW9uXG4gICAgICAgIGlmIChjb25uZWN0aW9uUGFyYW1zLmJvZHkgIT09ICcnICYmIGNvbm5lY3Rpb25QYXJhbXMuYm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoaXNTdHJlYW0oY29ubmVjdGlvblBhcmFtcy5ib2R5KSkge1xuICAgICAgICAgICAgICAgIGlmIChjb21wcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25QYXJhbXMuYm9keSA9IGNvbm5lY3Rpb25QYXJhbXMuYm9keS5waXBlKGNyZWF0ZUd6aXAoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uUGFyYW1zLmJvZHkgPSBhd2FpdCBnemlwKGNvbm5lY3Rpb25QYXJhbXMuYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xzXzEua0RpYWdub3N0aWNdLmVtaXQoJ3JlcXVlc3QnLCBlcnIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddID0gJ2d6aXAnO1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSAnJyArIEJ1ZmZlci5ieXRlTGVuZ3RoKGNvbm5lY3Rpb25QYXJhbXMuYm9keSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSAnJyArIEJ1ZmZlci5ieXRlTGVuZ3RoKGNvbm5lY3Rpb25QYXJhbXMuYm9keSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoZWFkZXJzLmFjY2VwdCA9IChfMTYgPSBoZWFkZXJzLmFjY2VwdCkgIT09IG51bGwgJiYgXzE2ICE9PSB2b2lkIDAgPyBfMTYgOiB0aGlzW3N5bWJvbHNfMS5rQWNjZXB0SGVhZGVyXTtcbiAgICAgICAgY29ubmVjdGlvblBhcmFtcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgd2hpbGUgKG1ldGEuYXR0ZW1wdHMgPD0gbWF4UmV0cmllcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsID09PSBudWxsIHx8IHNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2lnbmFsLmFib3J0ZWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUmVxdWVzdEFib3J0ZWRFcnJvcignUmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkIGJ5IHRoZSB1c2VyJywgcmVzdWx0LCBlcnJvck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRhLmNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IG1ldGEucmVxdWVzdC5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbWV0YS5jb250ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGEuY29ubmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yKCdUaGVyZSBhcmUgbm8gbGl2aW5nIGNvbm5lY3Rpb25zJywgcmVzdWx0LCBlcnJvck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZW5lcmF0ZSByZXF1aXJlZCBPcGVuVGVsZW1ldHJ5IGF0dHJpYnV0ZXMgZnJvbSB0aGUgcmVxdWVzdCBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0VXJsID0gbWV0YS5jb25uZWN0aW9uLnVybDtcbiAgICAgICAgICAgICAgICBvdGVsU3BhbiA9PT0gbnVsbCB8fCBvdGVsU3BhbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3RlbFNwYW4uc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICd1cmwuZnVsbCc6IHJlcXVlc3RVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgJ3NlcnZlci5hZGRyZXNzJzogcmVxdWVzdFVybC5ob3N0bmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsLnBvcnQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0VXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3RlbFNwYW4gPT09IG51bGwgfHwgb3RlbFNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG90ZWxTcGFuLnNldEF0dHJpYnV0ZSgnc2VydmVyLnBvcnQnLCA0NDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3RVcmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90ZWxTcGFuID09PSBudWxsIHx8IG90ZWxTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdGVsU3Bhbi5zZXRBdHRyaWJ1dGUoJ3NlcnZlci5wb3J0JywgODApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcXVlc3RVcmwucG9ydCAhPT0gJzkyMDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIG90ZWxTcGFuID09PSBudWxsIHx8IG90ZWxTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdGVsU3Bhbi5zZXRBdHRyaWJ1dGUoJ3NlcnZlci5wb3J0JywgcGFyc2VJbnQocmVxdWVzdFVybC5wb3J0LCAxMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY10uZW1pdCgncmVxdWVzdCcsIG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgYWN0dWFsIGh0dHAgcmVxdWVzdFxuICAgICAgICAgICAgICAgIGxldCB7IHN0YXR1c0NvZGUsIGhlYWRlcnMsIGJvZHkgfSA9IGF3YWl0IG1ldGEuY29ubmVjdGlvbi5yZXF1ZXN0KGNvbm5lY3Rpb25QYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdElkOiBtZXRhLnJlcXVlc3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXNbc3ltYm9sc18xLmtOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogbWV0YS5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICBtYXhSZXNwb25zZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIG1heENvbXByZXNzZWRSZXNwb25zZVNpemUsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogdG9NcyhvcHRpb25zLnJlcXVlc3RUaW1lb3V0ICE9IG51bGwgPyBvcHRpb25zLnJlcXVlc3RUaW1lb3V0IDogdGhpc1tzeW1ib2xzXzEua1JlcXVlc3RUaW1lb3V0XSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihvcHRpb25zLmFzU3RyZWFtID09PSB0cnVlID8geyBhc1N0cmVhbTogdHJ1ZSB9IDogbnVsbClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXJzWyd4LWZvdW5kLWhhbmRsaW5nLWNsdXN0ZXInXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG90ZWxTcGFuID09PSBudWxsIHx8IG90ZWxTcGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdGVsU3Bhbi5zZXRBdHRyaWJ1dGUoJ2RiLmVsYXN0aWNzZWFyY2guY2x1c3Rlci5uYW1lJywgaGVhZGVyc1sneC1mb3VuZC1oYW5kbGluZy1jbHVzdGVyJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyc1sneC1mb3VuZC1oYW5kbGluZy1pbnN0YW5jZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3RlbFNwYW4gPT09IG51bGwgfHwgb3RlbFNwYW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG90ZWxTcGFuLnNldEF0dHJpYnV0ZSgnZGIuZWxhc3RpY3NlYXJjaC5ub2RlLm5hbWUnLCBoZWFkZXJzWyd4LWZvdW5kLWhhbmRsaW5nLWluc3RhbmNlJ10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpc1tzeW1ib2xzXzEua1Byb2R1Y3RDaGVja10gIT0gbnVsbCAmJiBoZWFkZXJzWyd4LWVsYXN0aWMtcHJvZHVjdCddICE9PSB0aGlzW3N5bWJvbHNfMS5rUHJvZHVjdENoZWNrXSAmJiBzdGF0dXNDb2RlID49IDIwMCAmJiBzdGF0dXNDb2RlIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlByb2R1Y3ROb3RTdXBwb3J0ZWRFcnJvcih0aGlzW3N5bWJvbHNfMS5rUHJvZHVjdENoZWNrXSwgcmVzdWx0LCBlcnJvck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItdHMtZXhwZWN0LWVycm9yICovXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFzU3RyZWFtID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xzXzEua0RpYWdub3N0aWNdLmVtaXQoJ3Jlc3BvbnNlJywgbnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybk1ldGEgPyByZXN1bHQgOiBib2R5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSAoKF8xNyA9IGhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkgIT09IG51bGwgJiYgXzE3ICE9PSB2b2lkIDAgPyBfMTcgOiAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGVudEVuY29kaW5nLmluY2x1ZGVzKCdnemlwJykgfHwgY29udGVudEVuY29kaW5nLmluY2x1ZGVzKCdkZWZsYXRlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGF3YWl0IHVuemlwKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpICYmICEoMCwgQmFzZUNvbm5lY3Rpb25fMS5pc0JpbmFyeSkoKF8xOCA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSAhPT0gbnVsbCAmJiBfMTggIT09IHZvaWQgMCA/IF8xOCA6ICcnKSkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWQgPSBwYXJhbXMubWV0aG9kID09PSAnSEVBRCc7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgdGhlIHBheWxvYWQgZGVzZXJpYWxpemF0aW9uIG9ubHkgaWY6XG4gICAgICAgICAgICAgICAgLy8gICAgLSBhIGBjb250ZW50LXR5cGVgIGlzIGRlZmluZWQgYW5kIGlzIGVxdWFsIHRvIGBhcHBsaWNhdGlvbi9qc29uYFxuICAgICAgICAgICAgICAgIC8vICAgIC0gdGhlIHJlcXVlc3QgaXMgbm90IGEgSEVBRCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgLy8gICAgLSB0aGUgcGF5bG9hZCBpcyBub3QgYW4gZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCgoXzE5ID0gaGVhZGVyc1snY29udGVudC10eXBlJ10pID09PSBudWxsIHx8IF8xOSA9PT0gdm9pZCAwID8gdm9pZCAwIDogXzE5LmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKF8yMCA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSA9PT0gbnVsbCB8fCBfMjAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF8yMC5pbmNsdWRlcygnYXBwbGljYXRpb24vdm5kLmVsYXN0aWNzZWFyY2granNvbicpKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSGVhZCAmJiBib2R5ICE9PSAnJykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gdGhpc1tzeW1ib2xzXzEua1NlcmlhbGl6ZXJdLmRlc2VyaWFsaXplKGJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FzdCB0byBib29sZWFuIGlmIHRoZSByZXF1ZXN0IG1ldGhvZCB3YXMgSEVBRCBhbmQgdGhlcmUgd2FzIG5vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ib2R5ID0gaXNIZWFkICYmIHN0YXR1c0NvZGUgPCA0MDAgPyB0cnVlIDogYm9keTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIGlnbm9yZSB0aGUgc3RhdHVzQ29kZSBpZiB0aGUgdXNlciBoYXMgY29uZmlndXJlZCB0aGUgYGlnbm9yZWAgZmllbGQgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGF0dXNDb2RlIHdlIGp1c3QgZ290IG9yIGlmIHRoZSByZXF1ZXN0IG1ldGhvZCBpcyBIRUFEIGFuZCB0aGUgc3RhdHVzQ29kZSBpcyA0MDRcbiAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVTdGF0dXNDb2RlID0gKEFycmF5LmlzQXJyYXkob3B0aW9ucy5pZ25vcmUpICYmIG9wdGlvbnMuaWdub3JlLmluY2x1ZGVzKHN0YXR1c0NvZGUpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNIZWFkICYmIHN0YXR1c0NvZGUgPT09IDQwNCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVTdGF0dXNDb2RlICYmIChzdGF0dXNDb2RlID09PSA1MDIgfHwgc3RhdHVzQ29kZSA9PT0gNTAzIHx8IHN0YXR1c0NvZGUgPT09IDUwNCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXR1c0NvZGUgaXMgNTAyLzMvNCB3ZSBzaG91bGQgcnVuIG91ciByZXRyeSBzdHJhdGVneVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbWFyayB0aGUgY29ubmVjdGlvbiBhcyBkZWFkXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtDb25uZWN0aW9uUG9vbF0ubWFya0RlYWQobWV0YS5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnkgbG9naWNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEuYXR0ZW1wdHMgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhLmF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhgUmV0cnlpbmcgcmVxdWVzdCwgdGhlcmUgYXJlIHN0aWxsICR7bWF4UmV0cmllcyAtIG1ldGEuYXR0ZW1wdHN9IGF0dGVtcHRzYCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVyeXRoaW5nIGhhcyB3b3JrZWQgYXMgZXhwZWN0ZWQsIGxldCdzIG1hcmtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbm5lY3Rpb24gYXMgYWxpdmUgKG9yIGNvbmZpcm0gaXQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtDb25uZWN0aW9uUG9vbF0ubWFya0FsaXZlKG1ldGEuY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaWdub3JlU3RhdHVzQ29kZSAmJiBzdGF0dXNDb2RlID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUmVzcG9uc2VFcnJvcihyZXN1bHQsIGVycm9yT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXN0IHRvIGJvb2xlYW4gaWYgdGhlIHJlcXVlc3QgbWV0aG9kIHdhcyBIRUFEXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hlYWQgJiYgc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYm9keSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXS5lbWl0KCdyZXNwb25zZScsIG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5NZXRhID8gcmVzdWx0IDogcmVzdWx0LmJvZHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlcnJvci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUHJvZHVjdE5vdFN1cHBvcnRlZEVycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRGVzZXJpYWxpemF0aW9uRXJyb3InOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdSZXNwb25zZUVycm9yJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXS5lbWl0KCdyZXNwb25zZScsIGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JlcXVlc3RBYm9ydGVkRXJyb3InOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgZXJyb3IgdG8gZ2V0IGEgY2xlYW4gc3RhY2sgdHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRFcnJvciA9IG5ldyBlcnJvcnNfMS5SZXF1ZXN0QWJvcnRlZEVycm9yKGVycm9yLm1lc3NhZ2UsIHJlc3VsdCwgZXJyb3JPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXS5lbWl0KCdyZXNwb25zZScsIHdyYXBwZWRFcnJvciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHdyYXBwZWRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbWF5YmUgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgY2FzZWAgZmFsbHRocm91Z2ggaXMgaW50ZW50aW9uYWw6IHNob3VsZCByZXRyeSBpZiByZXRyeU9uVGltZW91dCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1RpbWVvdXRFcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNbc3ltYm9sc18xLmtSZXRyeU9uVGltZW91dF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3cmFwcGVkRXJyb3IgPSBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKGVycm9yLm1lc3NhZ2UsIHJlc3VsdCwgZXJyb3JPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY10uZW1pdCgncmVzcG9uc2UnLCB3cmFwcGVkRXJyb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgd3JhcHBlZEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0Nvbm5lY3Rpb25FcnJvcic6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQncyBtYXJrIHRoZSBjb25uZWN0aW9uIGFzIGRlYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtDb25uZWN0aW9uUG9vbF0ubWFya0RlYWQobWV0YS5jb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzW3N5bWJvbHNfMS5rU25pZmZPbkNvbm5lY3Rpb25GYXVsdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNuaWZmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBUcmFuc3BvcnQuc25pZmZSZWFzb25zLlNOSUZGX09OX0NPTk5FQ1RJT05fRkFVTFQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogbWV0YS5yZXF1ZXN0LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBtZXRhLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5IGxvZ2ljXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YS5hdHRlbXB0cyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhLmF0dGVtcHRzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoYFJldHJ5aW5nIHJlcXVlc3QsIHRoZXJlIGFyZSBzdGlsbCAke21heFJldHJpZXMgLSBtZXRhLmF0dGVtcHRzfSBhdHRlbXB0c2AsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGV4cG9uZW50aWFsIGJhY2tvZmYgdW50aWwgcmV0cnlpbmcgb24gZWFjaCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGEuYXR0ZW1wdHMgPj0gdGhpc1tzeW1ib2xzXzEua0Nvbm5lY3Rpb25Qb29sXS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmYgb24gcmV0cmllcywgd2l0aCBqaXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja29mZiA9IChfMjEgPSBvcHRpb25zLnJldHJ5QmFja29mZikgIT09IG51bGwgJiYgXzIxICE9PSB2b2lkIDAgPyBfMjEgOiB0aGlzW3N5bWJvbHNfMS5rUmV0cnlCYWNrb2ZmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFja29mZldhaXQgPSBiYWNrb2ZmKDAsIDQsIG1ldGEuYXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFja29mZldhaXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoMCwgcHJvbWlzZXNfMS5zZXRUaW1lb3V0KShiYWNrb2ZmV2FpdCAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgZXJyb3IgdG8gZ2V0IGEgY2xlYW4gc3RhY2sgdHJhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRFcnJvciA9IGVycm9yLm5hbWUgPT09ICdUaW1lb3V0RXJyb3InXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKGVycm9yLm1lc3NhZ2UsIHJlc3VsdCwgZXJyb3JPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbmV3IGVycm9yc18xLkNvbm5lY3Rpb25FcnJvcihlcnJvci5tZXNzYWdlLCByZXN1bHQsIGVycm9yT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY10uZW1pdCgncmVzcG9uc2UnLCB3cmFwcGVkRXJyb3IsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cmFwcGVkRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZWRnZSBjYXNlcywgc3VjaCBhcyBiYWQgY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXS5lbWl0KCdyZXNwb25zZScsIGVycm9yLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXR1cm5NZXRhID8gcmVzdWx0IDogcmVzdWx0LmJvZHk7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocGFyYW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF81LCBfNiwgXzc7XG4gICAgICAgIC8vIHdyYXAgaW4gT3BlblRlbGVtZXRyeSBzcGFuXG4gICAgICAgIGlmICgoKF81ID0gcGFyYW1zLm1ldGEpID09PSBudWxsIHx8IF81ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfNS5uYW1lKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBnYXRoZXIgT3BlblRlbGVtZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgICdkYi5zeXN0ZW0nOiAnZWxhc3RpY3NlYXJjaCcsXG4gICAgICAgICAgICAgICAgJ2h0dHAucmVxdWVzdC5tZXRob2QnOiBwYXJhbXMubWV0aG9kLFxuICAgICAgICAgICAgICAgICdkYi5vcGVyYXRpb24ubmFtZSc6IChfNiA9IHBhcmFtcy5tZXRhKSA9PT0gbnVsbCB8fCBfNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogXzYubmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoKF83ID0gcGFyYW1zLm1ldGEpID09PSBudWxsIHx8IF83ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfNy5wYXRoUGFydHMpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbXMubWV0YS5wYXRoUGFydHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbYGRiLmVsYXN0aWNzZWFyY2gucGF0aF9wYXJ0cy4ke2tleX1gXSA9IHBhcmFtcy5tZXRhLnBhdGhQYXJ0c1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzW3N5bWJvbHNfMS5rT3RlbFRyYWNlcl0uc3RhcnRBY3RpdmVTcGFuKHBhcmFtcy5tZXRhLm5hbWUsIHsgYXR0cmlidXRlcywga2luZDogYXBpXzEuU3BhbktpbmQuQ0xJRU5UIH0sIGFzeW5jIChvdGVsU3BhbikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfNTtcbiAgICAgICAgICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0KHBhcmFtcywgb3B0aW9ucywgb3RlbFNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIG90ZWxTcGFuLnJlY29yZEV4Y2VwdGlvbihlcnIpO1xuICAgICAgICAgICAgICAgICAgICBvdGVsU3Bhbi5zZXRTdGF0dXMoeyBjb2RlOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5FUlJPUiB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3RlbFNwYW4uc2V0QXR0cmlidXRlKCdlcnJvci50eXBlJywgKF81ID0gZXJyLm5hbWUpICE9PSBudWxsICYmIF81ICE9PSB2b2lkIDAgPyBfNSA6ICdFcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBvdGVsU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVxdWVzdChwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENvbm5lY3Rpb24ob3B0cykge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAodGhpc1tzeW1ib2xzXzEua1NuaWZmRW5hYmxlZF0gJiYgbm93ID4gdGhpc1tzeW1ib2xzXzEua05leHRTbmlmZl0pIHtcbiAgICAgICAgICAgIHRoaXNbc3ltYm9sc18xLmtOZXh0U25pZmZdID0gbm93ICsgdGhpc1tzeW1ib2xzXzEua1NuaWZmSW50ZXJ2YWxdO1xuICAgICAgICAgICAgdGhpcy5zbmlmZih7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBUcmFuc3BvcnQuc25pZmZSZWFzb25zLlNOSUZGX0lOVEVSVkFMLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogb3B0cy5yZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgY29udGV4dDogb3B0cy5jb250ZXh0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tzeW1ib2xzXzEua0Nvbm5lY3Rpb25Qb29sXS5nZXRDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGZpbHRlcjogdGhpc1tzeW1ib2xzXzEua05vZGVGaWx0ZXJdLFxuICAgICAgICAgICAgc2VsZWN0b3I6IHRoaXNbc3ltYm9sc18xLmtOb2RlU2VsZWN0b3JdLFxuICAgICAgICAgICAgcmVxdWVzdElkOiBvcHRzLnJlcXVlc3RJZCxcbiAgICAgICAgICAgIG5hbWU6IHRoaXNbc3ltYm9sc18xLmtOYW1lXSxcbiAgICAgICAgICAgIGNvbnRleHQ6IG9wdHMuY29udGV4dCxcbiAgICAgICAgICAgIG5vd1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBzbmlmZihvcHRzKSB7IH1cbn1cbl9hID0gc3ltYm9sc18xLmtOb2RlRmlsdGVyLCBfYiA9IHN5bWJvbHNfMS5rTm9kZVNlbGVjdG9yLCBfYyA9IHN5bWJvbHNfMS5rSGVhZGVycywgX2QgPSBzeW1ib2xzXzEua0RpYWdub3N0aWMsIF9lID0gc3ltYm9sc18xLmtDb25uZWN0aW9uUG9vbCwgX2YgPSBzeW1ib2xzXzEua1NlcmlhbGl6ZXIsIF9nID0gc3ltYm9sc18xLmtDb250ZXh0LCBfaCA9IHN5bWJvbHNfMS5rR2VuZXJhdGVSZXF1ZXN0SWQsIF9qID0gc3ltYm9sc18xLmtPcGFxdWVJZFByZWZpeCwgX2sgPSBzeW1ib2xzXzEua05hbWUsIF9sID0gc3ltYm9sc18xLmtNYXhSZXRyaWVzLCBfbSA9IHN5bWJvbHNfMS5rQ29tcHJlc3Npb24sIF9vID0gc3ltYm9sc18xLmtSZXF1ZXN0VGltZW91dCwgX3AgPSBzeW1ib2xzXzEua1JldHJ5T25UaW1lb3V0LCBfcSA9IHN5bWJvbHNfMS5rU25pZmZFbmFibGVkLCBfciA9IHN5bWJvbHNfMS5rTmV4dFNuaWZmLCBfcyA9IHN5bWJvbHNfMS5rSXNTbmlmZmluZywgX3QgPSBzeW1ib2xzXzEua1NuaWZmSW50ZXJ2YWwsIF91ID0gc3ltYm9sc18xLmtTbmlmZk9uQ29ubmVjdGlvbkZhdWx0LCBfdiA9IHN5bWJvbHNfMS5rU25pZmZFbmRwb2ludCwgX3cgPSBzeW1ib2xzXzEua1Byb2R1Y3RDaGVjaywgX3ggPSBzeW1ib2xzXzEua01heFJlc3BvbnNlU2l6ZSwgX3kgPSBzeW1ib2xzXzEua01heENvbXByZXNzZWRSZXNwb25zZVNpemUsIF96ID0gc3ltYm9sc18xLmtKc29uQ29udGVudFR5cGUsIF8wID0gc3ltYm9sc18xLmtOZGpzb25Db250ZW50VHlwZSwgXzEgPSBzeW1ib2xzXzEua0FjY2VwdEhlYWRlciwgXzIgPSBzeW1ib2xzXzEua1JlZGFjdGlvbiwgXzMgPSBzeW1ib2xzXzEua1JldHJ5QmFja29mZiwgXzQgPSBzeW1ib2xzXzEua090ZWxUcmFjZXI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNwb3J0LCBcInNuaWZmUmVhc29uc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgU05JRkZfT05fU1RBUlQ6ICdzbmlmZi1vbi1zdGFydCcsXG4gICAgICAgIFNOSUZGX0lOVEVSVkFMOiAnc25pZmYtaW50ZXJ2YWwnLFxuICAgICAgICBTTklGRl9PTl9DT05ORUNUSU9OX0ZBVUxUOiAnc25pZmYtb24tY29ubmVjdGlvbi1mYXVsdCcsXG4gICAgICAgIERFRkFVTFQ6ICdkZWZhdWx0J1xuICAgIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNwb3J0O1xuZnVuY3Rpb24gdG9Ncyh0aW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKDAsIG1zXzEuZGVmYXVsdCkodGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0aW1lO1xufVxuZnVuY3Rpb24gc2hvdWxkU2VyaWFsaXplKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnBpcGUgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgIUJ1ZmZlci5pc0J1ZmZlcihvYmopO1xufVxuZnVuY3Rpb24gaXNTdHJlYW0ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGRlZmF1bHROb2RlRmlsdGVyKG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJvdW5kUm9iaW5TZWxlY3RvcigpIHtcbiAgICBsZXQgY3VycmVudCA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBfcm91bmRSb2JpblNlbGVjdG9yKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIGlmICgrK2N1cnJlbnQgPj0gY29ubmVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbnNbY3VycmVudF07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUmVxdWVzdElkKCkge1xuICAgIGNvbnN0IG1heEludCA9IDIxNDc0ODM2NDc7XG4gICAgbGV0IG5leHRSZXFJZCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdlblJlcUlkKHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG5leHRSZXFJZCA9IChuZXh0UmVxSWQgKyAxKSAmIG1heEludCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxvd2VyQ2FzZUhlYWRlcnMob2xkSGVhZGVycykge1xuICAgIGlmIChvbGRIZWFkZXJzID09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG5ld0hlYWRlcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBpbiBvbGRIZWFkZXJzKSB7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgbmV3SGVhZGVyc1toZWFkZXIudG9Mb3dlckNhc2UoKV0gPSBvbGRIZWFkZXJzW2hlYWRlcl07XG4gICAgfVxuICAgIHJldHVybiBuZXdIZWFkZXJzO1xufVxuLyoqXG4gKiBGdW5jdGlvbiBmb3IgY2FsY3VsYXRpbmcgaG93IGxvbmcgdG8gc2xlZXAsIGluIHNlY29uZHMsIGJlZm9yZSB0aGUgbmV4dCByZXF1ZXN0IHJldHJ5XG4gKiBVc2VzIHRoZSBBV1MgXCJlcXVhbCBqaXR0ZXJcIiBhbGdvcml0aG0gbm90ZWQgaW4gdGhpcyBwb3N0OlxuICogaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9ibG9ncy9hcmNoaXRlY3R1cmUvZXhwb25lbnRpYWwtYmFja29mZi1hbmQtaml0dGVyL1xuICogQHBhcmFtIG1pbiBUaGUgbWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyB0byB3YWl0XG4gKiBAcGFyYW0gbWF4IFRoZSBtYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXRcbiAqIEBwYXJhbSBhdHRlbXB0IEhvdyBtYW55IHJldHJ5IGF0dGVtcHRzIGhhdmUgYmVlbiBtYWRlXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gd2FpdCBiZWZvcmUgdGhlIG5leHQgcmV0cnlcbiAqL1xuZnVuY3Rpb24gcmV0cnlCYWNrb2ZmKG1pbiwgbWF4LCBhdHRlbXB0KSB7XG4gICAgY29uc3QgY2VpbGluZyA9IE1hdGgubWluKG1heCwgMiAqKiBhdHRlbXB0KSAvIDI7XG4gICAgcmV0dXJuIGNlaWxpbmcgKyAoKE1hdGgucmFuZG9tKCkgKiAoY2VpbGluZyAtIG1pbikpICsgbWluKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/Transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/connection/BaseConnection.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.prepareHeaders = prepareHeaders;\nexports.getIssuerCertificate = getIssuerCertificate;\nexports.isCaFingerprintMatch = isCaFingerprintMatch;\nexports.isBinary = isBinary;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst node_util_1 = __webpack_require__(/*! node:util */ \"node:util\");\nconst Diagnostic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../Diagnostic */ \"(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js\"));\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst symbols_1 = __webpack_require__(/*! ../symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\n/**\n * An HTTP connection to a single Elasticsearch node.\n */\nclass BaseConnection {\n    constructor(opts) {\n        var _d, _e, _f, _g, _h, _j, _k;\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"deadCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_openRequests\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"weight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxEventListeners\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.url = opts.url;\n        this.tls = (_d = opts.tls) !== null && _d !== void 0 ? _d : null;\n        this.id = (_e = opts.id) !== null && _e !== void 0 ? _e : stripAuth(opts.url.href);\n        this.headers = prepareHeaders(opts.headers, opts.auth);\n        this.timeout = (_f = opts.timeout) !== null && _f !== void 0 ? _f : 30000;\n        this.deadCount = 0;\n        this.resurrectTimeout = 0;\n        this.weight = 0;\n        this._openRequests = 0;\n        this.maxEventListeners = (_g = opts.maxEventListeners) !== null && _g !== void 0 ? _g : 100;\n        this[symbols_1.kStatus] = (_h = opts.status) !== null && _h !== void 0 ? _h : BaseConnection.statuses.ALIVE;\n        this[symbols_1.kDiagnostic] = (_j = opts.diagnostic) !== null && _j !== void 0 ? _j : new Diagnostic_1.default();\n        this[symbols_1.kCaFingerprint] = (_k = opts.caFingerprint) !== null && _k !== void 0 ? _k : null;\n        if (!['http:', 'https:'].includes(this.url.protocol)) {\n            throw new errors_1.ConfigurationError(`Invalid protocol: '${this.url.protocol}'`);\n        }\n    }\n    get status() {\n        return this[symbols_1.kStatus];\n    }\n    set status(status) {\n        if (!validStatuses.includes(status)) {\n            throw new errors_1.ConfigurationError(`Unsupported status: '${status}'`);\n        }\n        this[symbols_1.kStatus] = status;\n    }\n    get diagnostic() {\n        return this[symbols_1.kDiagnostic];\n    }\n    async request(params, options) {\n        throw new errors_1.ConfigurationError('The request method should be implemented by extended classes');\n    }\n    /* istanbul ignore next */\n    async close() {\n        throw new errors_1.ConfigurationError('The close method should be implemented by extended classes');\n    }\n    // Handles console.log and utils.inspect invocations.\n    // We want to hide `auth`, `agent` and `tls` since they made\n    // the logs very hard to read. The user can still\n    // access them with `instance.agent` and `instance.tls`.\n    [(_a = symbols_1.kStatus, _b = symbols_1.kCaFingerprint, _c = symbols_1.kDiagnostic, node_util_1.inspect.custom)](depth, options) {\n        const { authorization, ...headers } = this.headers;\n        return {\n            url: stripAuth(this.url.toString()),\n            id: this.id,\n            headers,\n            status: this.status\n        };\n    }\n    toJSON() {\n        const { authorization, ...headers } = this.headers;\n        return {\n            url: stripAuth(this.url.toString()),\n            id: this.id,\n            headers,\n            status: this.status\n        };\n    }\n}\nObject.defineProperty(BaseConnection, \"statuses\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        ALIVE: 'alive',\n        DEAD: 'dead'\n    }\n});\nexports[\"default\"] = BaseConnection;\nconst validStatuses = Object.keys(BaseConnection.statuses)\n    // @ts-expect-error\n    .map(k => BaseConnection.statuses[k]);\nfunction stripAuth(url) {\n    if (!url.includes('@'))\n        return url;\n    return url.slice(0, url.indexOf('//') + 2) + url.slice(url.indexOf('@') + 1);\n}\nfunction prepareHeaders(headers = {}, auth) {\n    if (auth != null && headers.authorization == null) {\n        /* istanbul ignore else */\n        if (isApiKeyAuth(auth)) {\n            if (typeof auth.apiKey === 'object') {\n                headers.authorization = 'ApiKey ' + Buffer.from(`${auth.apiKey.id}:${auth.apiKey.api_key}`).toString('base64');\n            }\n            else {\n                headers.authorization = `ApiKey ${auth.apiKey}`;\n            }\n        }\n        else if (isBearerAuth(auth)) {\n            headers.authorization = `Bearer ${auth.bearer}`;\n        }\n        else if (auth.username != null && auth.password != null) {\n            headers.authorization = 'Basic ' + Buffer.from(`${auth.username}:${auth.password}`).toString('base64');\n        }\n    }\n    return headers;\n}\nfunction isApiKeyAuth(auth) {\n    return auth.apiKey != null;\n}\nfunction isBearerAuth(auth) {\n    return auth.bearer != null;\n}\nfunction getIssuerCertificate(socket) {\n    let certificate = socket.getPeerCertificate(true);\n    while (certificate !== null && Object.keys(certificate).length > 0) {\n        // invalid certificate\n        if (certificate.issuerCertificate == null) {\n            return null;\n        }\n        // We have reached the root certificate.\n        // In case of self-signed certificates, `issuerCertificate` may be a circular reference.\n        if (certificate.fingerprint256 === certificate.issuerCertificate.fingerprint256) {\n            break;\n        }\n        // continue the loop\n        certificate = certificate.issuerCertificate;\n    }\n    return certificate;\n}\nfunction isCaFingerprintMatch(cert1, cert2) {\n    if (typeof cert1 === 'string' && typeof cert2 === 'string') {\n        const c1 = cert1.toLowerCase().replace(/:/g, '');\n        const c2 = cert2.toLowerCase().replace(/:/g, '');\n        return c1 === c2;\n    }\n    return cert1 === cert2;\n}\nfunction isBinary(contentType) {\n    const binaryTypes = [\n        'application/vnd.mapbox-vector-tile',\n        'application/vnd.apache.arrow.stream',\n        'application/vnd.elasticsearch+arrow+stream',\n        'application/smile',\n        'application/vnd.elasticsearch+smile',\n        'application/cbor',\n        'application/vnd.elasticsearch+cbor'\n    ];\n    return binaryTypes\n        .map(type => contentType.includes(type))\n        .includes(true);\n}\n//# sourceMappingURL=BaseConnection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL0Jhc2VDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QixnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsNEJBQVc7QUFDdkMsNkNBQTZDLG1CQUFPLENBQUMsZ0ZBQWU7QUFDcEUsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVc7QUFDcEMsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGtCQUFrQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGVBQWUsR0FBRyxvQkFBb0I7QUFDekc7QUFDQTtBQUNBLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQSw4REFBOEQsY0FBYyxHQUFHLGNBQWM7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL3RyYW5zcG9ydC9saWIvY29ubmVjdGlvbi9CYXNlQ29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9hLCBfYiwgX2M7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByZXBhcmVIZWFkZXJzID0gcHJlcGFyZUhlYWRlcnM7XG5leHBvcnRzLmdldElzc3VlckNlcnRpZmljYXRlID0gZ2V0SXNzdWVyQ2VydGlmaWNhdGU7XG5leHBvcnRzLmlzQ2FGaW5nZXJwcmludE1hdGNoID0gaXNDYUZpbmdlcnByaW50TWF0Y2g7XG5leHBvcnRzLmlzQmluYXJ5ID0gaXNCaW5hcnk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3Qgbm9kZV91dGlsXzEgPSByZXF1aXJlKFwibm9kZTp1dGlsXCIpO1xuY29uc3QgRGlhZ25vc3RpY18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL0RpYWdub3N0aWNcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3Qgc3ltYm9sc18xID0gcmVxdWlyZShcIi4uL3N5bWJvbHNcIik7XG4vKipcbiAqIEFuIEhUVFAgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBFbGFzdGljc2VhcmNoIG5vZGUuXG4gKi9cbmNsYXNzIEJhc2VDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHZhciBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXJsXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0aW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImhlYWRlcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGVhZENvdW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3VycmVjdFRpbWVvdXRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX29wZW5SZXF1ZXN0c1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3ZWlnaHRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4RXZlbnRMaXN0ZW5lcnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9hLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2IsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfYywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cmwgPSBvcHRzLnVybDtcbiAgICAgICAgdGhpcy50bHMgPSAoX2QgPSBvcHRzLnRscykgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IChfZSA9IG9wdHMuaWQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHN0cmlwQXV0aChvcHRzLnVybC5ocmVmKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gcHJlcGFyZUhlYWRlcnMob3B0cy5oZWFkZXJzLCBvcHRzLmF1dGgpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSAoX2YgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IDMwMDAwO1xuICAgICAgICB0aGlzLmRlYWRDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVzdXJyZWN0VGltZW91dCA9IDA7XG4gICAgICAgIHRoaXMud2VpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fb3BlblJlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5tYXhFdmVudExpc3RlbmVycyA9IChfZyA9IG9wdHMubWF4RXZlbnRMaXN0ZW5lcnMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDEwMDtcbiAgICAgICAgdGhpc1tzeW1ib2xzXzEua1N0YXR1c10gPSAoX2ggPSBvcHRzLnN0YXR1cykgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMuQUxJVkU7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtEaWFnbm9zdGljXSA9IChfaiA9IG9wdHMuZGlhZ25vc3RpYykgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogbmV3IERpYWdub3N0aWNfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtDYUZpbmdlcnByaW50XSA9IChfayA9IG9wdHMuY2FGaW5nZXJwcmludCkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogbnVsbDtcbiAgICAgICAgaWYgKCFbJ2h0dHA6JywgJ2h0dHBzOiddLmluY2x1ZGVzKHRoaXMudXJsLnByb3RvY29sKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbmZpZ3VyYXRpb25FcnJvcihgSW52YWxpZCBwcm90b2NvbDogJyR7dGhpcy51cmwucHJvdG9jb2x9J2ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3N5bWJvbHNfMS5rU3RhdHVzXTtcbiAgICB9XG4gICAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKCF2YWxpZFN0YXR1c2VzLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoYFVuc3VwcG9ydGVkIHN0YXR1czogJyR7c3RhdHVzfSdgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW3N5bWJvbHNfMS5rU3RhdHVzXSA9IHN0YXR1cztcbiAgICB9XG4gICAgZ2V0IGRpYWdub3N0aWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3N5bWJvbHNfMS5rRGlhZ25vc3RpY107XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ1RoZSByZXF1ZXN0IG1ldGhvZCBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYnkgZXh0ZW5kZWQgY2xhc3NlcycpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGFzeW5jIGNsb3NlKCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29uZmlndXJhdGlvbkVycm9yKCdUaGUgY2xvc2UgbWV0aG9kIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBleHRlbmRlZCBjbGFzc2VzJyk7XG4gICAgfVxuICAgIC8vIEhhbmRsZXMgY29uc29sZS5sb2cgYW5kIHV0aWxzLmluc3BlY3QgaW52b2NhdGlvbnMuXG4gICAgLy8gV2Ugd2FudCB0byBoaWRlIGBhdXRoYCwgYGFnZW50YCBhbmQgYHRsc2Agc2luY2UgdGhleSBtYWRlXG4gICAgLy8gdGhlIGxvZ3MgdmVyeSBoYXJkIHRvIHJlYWQuIFRoZSB1c2VyIGNhbiBzdGlsbFxuICAgIC8vIGFjY2VzcyB0aGVtIHdpdGggYGluc3RhbmNlLmFnZW50YCBhbmQgYGluc3RhbmNlLnRsc2AuXG4gICAgWyhfYSA9IHN5bWJvbHNfMS5rU3RhdHVzLCBfYiA9IHN5bWJvbHNfMS5rQ2FGaW5nZXJwcmludCwgX2MgPSBzeW1ib2xzXzEua0RpYWdub3N0aWMsIG5vZGVfdXRpbF8xLmluc3BlY3QuY3VzdG9tKV0oZGVwdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBhdXRob3JpemF0aW9uLCAuLi5oZWFkZXJzIH0gPSB0aGlzLmhlYWRlcnM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IHN0cmlwQXV0aCh0aGlzLnVybC50b1N0cmluZygpKSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCB7IGF1dGhvcml6YXRpb24sIC4uLmhlYWRlcnMgfSA9IHRoaXMuaGVhZGVycztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVybDogc3RyaXBBdXRoKHRoaXMudXJsLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1c1xuICAgICAgICB9O1xuICAgIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ29ubmVjdGlvbiwgXCJzdGF0dXNlc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgdmFsdWU6IHtcbiAgICAgICAgQUxJVkU6ICdhbGl2ZScsXG4gICAgICAgIERFQUQ6ICdkZWFkJ1xuICAgIH1cbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZUNvbm5lY3Rpb247XG5jb25zdCB2YWxpZFN0YXR1c2VzID0gT2JqZWN0LmtleXMoQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMpXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIC5tYXAoayA9PiBCYXNlQ29ubmVjdGlvbi5zdGF0dXNlc1trXSk7XG5mdW5jdGlvbiBzdHJpcEF1dGgodXJsKSB7XG4gICAgaWYgKCF1cmwuaW5jbHVkZXMoJ0AnKSlcbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICByZXR1cm4gdXJsLnNsaWNlKDAsIHVybC5pbmRleE9mKCcvLycpICsgMikgKyB1cmwuc2xpY2UodXJsLmluZGV4T2YoJ0AnKSArIDEpO1xufVxuZnVuY3Rpb24gcHJlcGFyZUhlYWRlcnMoaGVhZGVycyA9IHt9LCBhdXRoKSB7XG4gICAgaWYgKGF1dGggIT0gbnVsbCAmJiBoZWFkZXJzLmF1dGhvcml6YXRpb24gPT0gbnVsbCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNBcGlLZXlBdXRoKGF1dGgpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGF1dGguYXBpS2V5ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdBcGlLZXkgJyArIEJ1ZmZlci5mcm9tKGAke2F1dGguYXBpS2V5LmlkfToke2F1dGguYXBpS2V5LmFwaV9rZXl9YCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5hdXRob3JpemF0aW9uID0gYEFwaUtleSAke2F1dGguYXBpS2V5fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCZWFyZXJBdXRoKGF1dGgpKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7YXV0aC5iZWFyZXJ9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdXRoLnVzZXJuYW1lICE9IG51bGwgJiYgYXV0aC5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKGAke2F1dGgudXNlcm5hbWV9OiR7YXV0aC5wYXNzd29yZH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG5mdW5jdGlvbiBpc0FwaUtleUF1dGgoYXV0aCkge1xuICAgIHJldHVybiBhdXRoLmFwaUtleSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNCZWFyZXJBdXRoKGF1dGgpIHtcbiAgICByZXR1cm4gYXV0aC5iZWFyZXIgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldElzc3VlckNlcnRpZmljYXRlKHNvY2tldCkge1xuICAgIGxldCBjZXJ0aWZpY2F0ZSA9IHNvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUodHJ1ZSk7XG4gICAgd2hpbGUgKGNlcnRpZmljYXRlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKGNlcnRpZmljYXRlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIGludmFsaWQgY2VydGlmaWNhdGVcbiAgICAgICAgaWYgKGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgcmVhY2hlZCB0aGUgcm9vdCBjZXJ0aWZpY2F0ZS5cbiAgICAgICAgLy8gSW4gY2FzZSBvZiBzZWxmLXNpZ25lZCBjZXJ0aWZpY2F0ZXMsIGBpc3N1ZXJDZXJ0aWZpY2F0ZWAgbWF5IGJlIGEgY2lyY3VsYXIgcmVmZXJlbmNlLlxuICAgICAgICBpZiAoY2VydGlmaWNhdGUuZmluZ2VycHJpbnQyNTYgPT09IGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlLmZpbmdlcnByaW50MjU2KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBjb250aW51ZSB0aGUgbG9vcFxuICAgICAgICBjZXJ0aWZpY2F0ZSA9IGNlcnRpZmljYXRlLmlzc3VlckNlcnRpZmljYXRlO1xuICAgIH1cbiAgICByZXR1cm4gY2VydGlmaWNhdGU7XG59XG5mdW5jdGlvbiBpc0NhRmluZ2VycHJpbnRNYXRjaChjZXJ0MSwgY2VydDIpIHtcbiAgICBpZiAodHlwZW9mIGNlcnQxID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgY2VydDIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGMxID0gY2VydDEudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC86L2csICcnKTtcbiAgICAgICAgY29uc3QgYzIgPSBjZXJ0Mi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLzovZywgJycpO1xuICAgICAgICByZXR1cm4gYzEgPT09IGMyO1xuICAgIH1cbiAgICByZXR1cm4gY2VydDEgPT09IGNlcnQyO1xufVxuZnVuY3Rpb24gaXNCaW5hcnkoY29udGVudFR5cGUpIHtcbiAgICBjb25zdCBiaW5hcnlUeXBlcyA9IFtcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5tYXBib3gtdmVjdG9yLXRpbGUnLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmFwYWNoZS5hcnJvdy5zdHJlYW0nLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmVsYXN0aWNzZWFyY2grYXJyb3crc3RyZWFtJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3NtaWxlJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL3ZuZC5lbGFzdGljc2VhcmNoK3NtaWxlJyxcbiAgICAgICAgJ2FwcGxpY2F0aW9uL2Nib3InLFxuICAgICAgICAnYXBwbGljYXRpb24vdm5kLmVsYXN0aWNzZWFyY2grY2JvcidcbiAgICBdO1xuICAgIHJldHVybiBiaW5hcnlUeXBlc1xuICAgICAgICAubWFwKHR5cGUgPT4gY29udGVudFR5cGUuaW5jbHVkZXModHlwZSkpXG4gICAgICAgIC5pbmNsdWRlcyh0cnVlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VDb25uZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/connection/HttpConnection.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/connection/HttpConnection.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nconst hpagent_1 = tslib_1.__importDefault(__webpack_require__(/*! hpagent */ \"(rsc)/./node_modules/hpagent/index.js\"));\nconst node_http_1 = tslib_1.__importDefault(__webpack_require__(/*! node:http */ \"node:http\"));\nconst node_https_1 = tslib_1.__importDefault(__webpack_require__(/*! node:https */ \"node:https\"));\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst node_buffer_1 = tslib_1.__importDefault(__webpack_require__(/*! node:buffer */ \"node:buffer\"));\nconst BaseConnection_1 = tslib_1.__importStar(__webpack_require__(/*! ./BaseConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\"));\nconst symbols_1 = __webpack_require__(/*! ../symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\nconst node_stream_1 = __webpack_require__(/*! node:stream */ \"node:stream\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst promises_1 = __webpack_require__(/*! node:timers/promises */ \"node:timers/promises\");\nconst debug = (0, debug_1.default)('elasticsearch');\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;\nconst noop = () => { };\n/**\n * A connection to an Elasticsearch node, managed by the `http` client in the standard library\n */\nclass HttpConnection extends BaseConnection_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"agent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"makeRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof opts.agent === 'function') {\n            this.agent = opts.agent(opts);\n        }\n        else if (typeof opts.agent === 'boolean') {\n            this.agent = undefined;\n        }\n        else {\n            if (opts.agent != null && !isHttpAgentOptions(opts.agent)) {\n                throw new errors_1.ConfigurationError('Bad agent configuration for Http agent');\n            }\n            const agentOptions = Object.assign({}, {\n                keepAlive: true,\n                keepAliveMsecs: 1000,\n                maxSockets: 256,\n                maxFreeSockets: 256,\n                scheduling: 'lifo'\n            }, opts.agent);\n            if (opts.proxy != null) {\n                const proxyAgentOptions = {\n                    ...agentOptions,\n                    proxy: opts.proxy\n                };\n                this.agent = this.url.protocol === 'http:'\n                    ? new hpagent_1.default.HttpProxyAgent(proxyAgentOptions)\n                    : new hpagent_1.default.HttpsProxyAgent(Object.assign({}, proxyAgentOptions, this.tls));\n            }\n            else {\n                this.agent = this.url.protocol === 'http:'\n                    ? new node_http_1.default.Agent(agentOptions)\n                    : new node_https_1.default.Agent(Object.assign({}, agentOptions, this.tls));\n            }\n        }\n        this.makeRequest = this.url.protocol === 'http:'\n            ? node_http_1.default.request\n            : node_https_1.default.request;\n    }\n    async request(params, options) {\n        return await new Promise((resolve, reject) => {\n            var _a, _b;\n            let cleanedListeners = false;\n            const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;\n            const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;\n            const requestParams = this.buildRequestObject(params, options);\n            // https://github.com/nodejs/node/commit/b961d9fd83\n            if (INVALID_PATH_REGEX.test(requestParams.path)) {\n                return reject(new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`));\n            }\n            debug('Starting a new request', params);\n            let request;\n            try {\n                request = this.makeRequest(requestParams);\n            }\n            catch (err) {\n                return reject(err);\n            }\n            const abortListener = () => {\n                request.destroy(new errors_1.RequestAbortedError('Request aborted'));\n            };\n            this._openRequests++;\n            if (options.signal != null) {\n                options.signal.addEventListener('abort', abortListener, { once: true });\n            }\n            const onResponse = (response) => {\n                var _a, _b;\n                cleanListeners();\n                request.on('error', noop); // There are some edge cases where the request emits an error while processing the response.\n                this._openRequests--;\n                if (options.asStream === true) {\n                    return resolve({\n                        body: response,\n                        statusCode: response.statusCode,\n                        headers: response.headers\n                    });\n                }\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate');\n                const bodyIsBinary = (0, BaseConnection_1.isBinary)((_b = response.headers['content-type']) !== null && _b !== void 0 ? _b : '');\n                /* istanbul ignore else */\n                if (response.headers['content-length'] !== undefined) {\n                    const contentLength = Number(response.headers['content-length']);\n                    if (isCompressed && contentLength > maxCompressedResponseSize) {\n                        response.destroy();\n                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));\n                    }\n                    else if (contentLength > maxResponseSize) {\n                        response.destroy();\n                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));\n                    }\n                }\n                // if the response is compressed, we must handle it\n                // as buffer for allowing decompression later\n                let payload = isCompressed || bodyIsBinary ? new Array() : '';\n                const onData = isCompressed || bodyIsBinary ? onDataAsBuffer : onDataAsString;\n                let currentLength = 0;\n                function onDataAsBuffer(chunk) {\n                    currentLength += Buffer.byteLength(chunk);\n                    if (currentLength > maxCompressedResponseSize) {\n                        response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));\n                    }\n                    else {\n                        payload.push(chunk);\n                    }\n                }\n                function onDataAsString(chunk) {\n                    currentLength += Buffer.byteLength(chunk);\n                    if (currentLength > maxResponseSize) {\n                        response.destroy(new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));\n                    }\n                    else {\n                        payload = `${payload}${chunk}`;\n                    }\n                }\n                const onEnd = (err) => {\n                    response.removeListener('data', onData);\n                    response.removeListener('end', onEnd);\n                    response.removeListener('error', onEnd);\n                    request.removeListener('error', noop);\n                    if (err != null) {\n                        // @ts-expect-error\n                        if (err.message === 'aborted' && err.code === 'ECONNRESET') {\n                            response.destroy();\n                            return reject(new errors_1.ConnectionError('Response aborted while reading the body'));\n                        }\n                        if (err.name === 'RequestAbortedError') {\n                            return reject(err);\n                        }\n                        return reject(new errors_1.ConnectionError(err.message));\n                    }\n                    resolve({\n                        body: isCompressed || bodyIsBinary ? Buffer.concat(payload) : payload,\n                        statusCode: response.statusCode,\n                        headers: response.headers\n                    });\n                };\n                if (!isCompressed && !bodyIsBinary) {\n                    response.setEncoding('utf8');\n                }\n                this.diagnostic.emit('deserialization', null, options);\n                response.on('data', onData);\n                response.on('error', onEnd);\n                response.on('end', onEnd);\n            };\n            const onTimeout = () => {\n                cleanListeners();\n                this._openRequests--;\n                request.once('error', () => { }); // we need to catch the request aborted error\n                request.destroy();\n                reject(new errors_1.TimeoutError('Request timed out'));\n            };\n            const onError = (err) => {\n                var _a, _b, _c, _d, _e, _f, _g, _h;\n                cleanListeners();\n                this._openRequests--;\n                let message = err.message;\n                if (err.name === 'RequestAbortedError') {\n                    return reject(err);\n                }\n                // @ts-expect-error\n                if (err.code === 'ECONNRESET') {\n                    message += ` - Local: ${(_b = (_a = request.socket) === null || _a === void 0 ? void 0 : _a.localAddress) !== null && _b !== void 0 ? _b : 'unknown'}:${(_d = (_c = request.socket) === null || _c === void 0 ? void 0 : _c.localPort) !== null && _d !== void 0 ? _d : 'unknown'}, Remote: ${(_f = (_e = request.socket) === null || _e === void 0 ? void 0 : _e.remoteAddress) !== null && _f !== void 0 ? _f : 'unknown'}:${(_h = (_g = request.socket) === null || _g === void 0 ? void 0 : _g.remotePort) !== null && _h !== void 0 ? _h : 'unknown'}`;\n                }\n                reject(new errors_1.ConnectionError(message));\n            };\n            const onSocket = (socket) => {\n                /* istanbul ignore else */\n                if (!socket.isSessionReused()) {\n                    socket.once('secureConnect', () => {\n                        const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);\n                        /* istanbul ignore next */\n                        if (issuerCertificate == null) {\n                            onError(new Error('Invalid or malformed certificate'));\n                            request.once('error', () => { }); // we need to catch the request aborted error\n                            return request.destroy();\n                        }\n                        // Check if fingerprint matches\n                        /* istanbul ignore else */\n                        if (!(0, BaseConnection_1.isCaFingerprintMatch)(this[symbols_1.kCaFingerprint], issuerCertificate.fingerprint256)) {\n                            onError(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'));\n                            request.once('error', () => { }); // we need to catch the request aborted error\n                            return request.destroy();\n                        }\n                    });\n                }\n            };\n            request.on('response', onResponse);\n            request.on('timeout', onTimeout);\n            request.on('error', onError);\n            if (this[symbols_1.kCaFingerprint] != null && requestParams.protocol === 'https:') {\n                request.on('socket', onSocket);\n            }\n            // Disables the Nagle algorithm\n            request.setNoDelay(true);\n            // starts the request\n            if (isStream(params.body)) {\n                (0, node_stream_1.pipeline)(params.body, request, err => {\n                    /* istanbul ignore if  */\n                    if (err != null && !cleanedListeners) {\n                        cleanListeners();\n                        this._openRequests--;\n                        reject(err);\n                    }\n                });\n            }\n            else {\n                request.end(params.body);\n            }\n            return request;\n            function cleanListeners() {\n                request.removeListener('response', onResponse);\n                request.removeListener('timeout', onTimeout);\n                request.removeListener('error', onError);\n                request.removeListener('socket', onSocket);\n                if (options.signal != null) {\n                    if ('removeEventListener' in options.signal) {\n                        options.signal.removeEventListener('abort', abortListener);\n                    }\n                    else {\n                        options.signal.removeListener('abort', abortListener);\n                    }\n                }\n                cleanedListeners = true;\n            }\n        });\n    }\n    async close() {\n        debug('Closing connection', this.id);\n        while (this._openRequests > 0) {\n            await (0, promises_1.setTimeout)(1000);\n        }\n        /* istanbul ignore else */\n        if (this.agent !== undefined) {\n            this.agent.destroy();\n        }\n    }\n    buildRequestObject(params, options) {\n        var _a;\n        const url = this.url;\n        let search = url.search;\n        let pathname = url.pathname;\n        const request = {\n            protocol: url.protocol,\n            hostname: url.hostname[0] === '['\n                ? url.hostname.slice(1, -1)\n                : url.hostname,\n            path: '',\n            // https://github.com/elastic/elasticsearch-js/issues/843\n            port: url.port !== '' ? url.port : undefined,\n            headers: this.headers,\n            agent: this.agent,\n            timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : this.timeout\n        };\n        const paramsKeys = Object.keys(params);\n        for (let i = 0, len = paramsKeys.length; i < len; i++) {\n            const key = paramsKeys[i];\n            if (key === 'path') {\n                pathname = resolve(pathname, params[key]);\n            }\n            else if (key === 'querystring' && Boolean(params[key])) {\n                if (search === '') {\n                    search = `?${params[key]}`;\n                }\n                else {\n                    search += `&${params[key]}`;\n                }\n            }\n            else if (key === 'headers') {\n                request.headers = Object.assign({}, request.headers, params.headers);\n            }\n            else {\n                // @ts-expect-error\n                request[key] = params[key];\n            }\n        }\n        request.path = pathname + search;\n        return request;\n    }\n}\nexports[\"default\"] = HttpConnection;\nfunction isStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction resolve(host, path) {\n    const hostEndWithSlash = host[host.length - 1] === '/';\n    const pathStartsWithSlash = path[0] === '/';\n    if (hostEndWithSlash && pathStartsWithSlash) {\n        return host + path.slice(1);\n    }\n    else if (hostEndWithSlash !== pathStartsWithSlash) {\n        return host + path;\n    }\n    else {\n        return host + '/' + path;\n    }\n}\n/* istanbul ignore next */\nfunction isHttpAgentOptions(opts) {\n    if (opts.keepAliveTimeout != null)\n        return false;\n    if (opts.keepAliveMaxTimeout != null)\n        return false;\n    if (opts.keepAliveTimeoutThreshold != null)\n        return false;\n    if (opts.pipelining != null)\n        return false;\n    if (opts.maxHeaderSize != null)\n        return false;\n    if (opts.connections != null)\n        return false;\n    return true;\n}\n//# sourceMappingURL=HttpConnection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL0h0dHBDb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0I7QUFDQSwwQ0FBMEMsbUJBQU8sQ0FBQyxzREFBUztBQUMzRCw0Q0FBNEMsbUJBQU8sQ0FBQyw0QkFBVztBQUMvRCw2Q0FBNkMsbUJBQU8sQ0FBQyw4QkFBWTtBQUNqRSx3Q0FBd0MsbUJBQU8sQ0FBQyxzREFBTztBQUN2RCw4Q0FBOEMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNuRSw4Q0FBOEMsbUJBQU8sQ0FBQyxrR0FBa0I7QUFDeEUsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVk7QUFDdEMsc0JBQXNCLG1CQUFPLENBQUMsZ0NBQWE7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVc7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsa0RBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsbUJBQW1CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsWUFBWTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGNBQWMsK0NBQStDLDBCQUEwQjtBQUNyTDtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsY0FBYywrQ0FBK0MsZ0JBQWdCO0FBQzNLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsK0NBQStDLDBCQUEwQjtBQUN4TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGNBQWMsK0NBQStDLGdCQUFnQjtBQUM5SztBQUNBO0FBQ0EscUNBQXFDLFFBQVEsRUFBRSxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZIQUE2SCxHQUFHLDBIQUEwSCxZQUFZLDhIQUE4SCxHQUFHLDJIQUEySDtBQUM5aUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL0h0dHBDb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zICovXG5jb25zdCBocGFnZW50XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaHBhZ2VudFwiKSk7XG5jb25zdCBub2RlX2h0dHBfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOmh0dHBcIikpO1xuY29uc3Qgbm9kZV9odHRwc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6aHR0cHNcIikpO1xuY29uc3QgZGVidWdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBub2RlX2J1ZmZlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6YnVmZmVyXCIpKTtcbmNvbnN0IEJhc2VDb25uZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9CYXNlQ29ubmVjdGlvblwiKSk7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vc3ltYm9sc1wiKTtcbmNvbnN0IG5vZGVfc3RyZWFtXzEgPSByZXF1aXJlKFwibm9kZTpzdHJlYW1cIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCBwcm9taXNlc18xID0gcmVxdWlyZShcIm5vZGU6dGltZXJzL3Byb21pc2VzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnZWxhc3RpY3NlYXJjaCcpO1xuY29uc3QgSU5WQUxJRF9QQVRIX1JFR0VYID0gL1teXFx1MDAyMS1cXHUwMGZmXS87XG5jb25zdCBNQVhfQlVGRkVSX0xFTkdUSCA9IG5vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX0xFTkdUSDtcbmNvbnN0IE1BWF9TVFJJTkdfTEVOR1RIID0gbm9kZV9idWZmZXJfMS5kZWZhdWx0LmNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSDtcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhbiBFbGFzdGljc2VhcmNoIG5vZGUsIG1hbmFnZWQgYnkgdGhlIGBodHRwYCBjbGllbnQgaW4gdGhlIHN0YW5kYXJkIGxpYnJhcnlcbiAqL1xuY2xhc3MgSHR0cENvbm5lY3Rpb24gZXh0ZW5kcyBCYXNlQ29ubmVjdGlvbl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFnZW50XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ha2VSZXF1ZXN0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5hZ2VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdHMuYWdlbnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5hZ2VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmFnZW50ICE9IG51bGwgJiYgIWlzSHR0cEFnZW50T3B0aW9ucyhvcHRzLmFnZW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ0JhZCBhZ2VudCBjb25maWd1cmF0aW9uIGZvciBIdHRwIGFnZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2VudE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtlZXBBbGl2ZU1zZWNzOiAxMDAwLFxuICAgICAgICAgICAgICAgIG1heFNvY2tldHM6IDI1NixcbiAgICAgICAgICAgICAgICBtYXhGcmVlU29ja2V0czogMjU2LFxuICAgICAgICAgICAgICAgIHNjaGVkdWxpbmc6ICdsaWZvJ1xuICAgICAgICAgICAgfSwgb3B0cy5hZ2VudCk7XG4gICAgICAgICAgICBpZiAob3B0cy5wcm94eSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJveHlBZ2VudE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFnZW50T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcHJveHk6IG9wdHMucHJveHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuYWdlbnQgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gJ2h0dHA6J1xuICAgICAgICAgICAgICAgICAgICA/IG5ldyBocGFnZW50XzEuZGVmYXVsdC5IdHRwUHJveHlBZ2VudChwcm94eUFnZW50T3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgaHBhZ2VudF8xLmRlZmF1bHQuSHR0cHNQcm94eUFnZW50KE9iamVjdC5hc3NpZ24oe30sIHByb3h5QWdlbnRPcHRpb25zLCB0aGlzLnRscykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZ2VudCA9IHRoaXMudXJsLnByb3RvY29sID09PSAnaHR0cDonXG4gICAgICAgICAgICAgICAgICAgID8gbmV3IG5vZGVfaHR0cF8xLmRlZmF1bHQuQWdlbnQoYWdlbnRPcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBub2RlX2h0dHBzXzEuZGVmYXVsdC5BZ2VudChPYmplY3QuYXNzaWduKHt9LCBhZ2VudE9wdGlvbnMsIHRoaXMudGxzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWtlUmVxdWVzdCA9IHRoaXMudXJsLnByb3RvY29sID09PSAnaHR0cDonXG4gICAgICAgICAgICA/IG5vZGVfaHR0cF8xLmRlZmF1bHQucmVxdWVzdFxuICAgICAgICAgICAgOiBub2RlX2h0dHBzXzEuZGVmYXVsdC5yZXF1ZXN0O1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGxldCBjbGVhbmVkTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXNwb25zZVNpemUgPSAoX2EgPSBvcHRpb25zLm1heFJlc3BvbnNlU2l6ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTUFYX1NUUklOR19MRU5HVEg7XG4gICAgICAgICAgICBjb25zdCBtYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplID0gKF9iID0gb3B0aW9ucy5tYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBNQVhfQlVGRkVSX0xFTkdUSDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSB0aGlzLmJ1aWxkUmVxdWVzdE9iamVjdChwYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC9iOTYxZDlmZDgzXG4gICAgICAgICAgICBpZiAoSU5WQUxJRF9QQVRIX1JFR0VYLnRlc3QocmVxdWVzdFBhcmFtcy5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFR5cGVFcnJvcihgRVJSX1VORVNDQVBFRF9DSEFSQUNURVJTOiAke3JlcXVlc3RQYXJhbXMucGF0aH1gKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZygnU3RhcnRpbmcgYSBuZXcgcmVxdWVzdCcsIHBhcmFtcyk7XG4gICAgICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHRoaXMubWFrZVJlcXVlc3QocmVxdWVzdFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWJvcnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmRlc3Ryb3kobmV3IGVycm9yc18xLlJlcXVlc3RBYm9ydGVkRXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9vcGVuUmVxdWVzdHMrKztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydExpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvblJlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgbm9vcCk7IC8vIFRoZXJlIGFyZSBzb21lIGVkZ2UgY2FzZXMgd2hlcmUgdGhlIHJlcXVlc3QgZW1pdHMgYW4gZXJyb3Igd2hpbGUgcHJvY2Vzc2luZyB0aGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlblJlcXVlc3RzLS07XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXNTdHJlYW0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gKChfYSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDb21wcmVzc2VkID0gY29udGVudEVuY29kaW5nLmluY2x1ZGVzKCdnemlwJykgfHwgY29udGVudEVuY29kaW5nLmluY2x1ZGVzKCdkZWZsYXRlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUlzQmluYXJ5ID0gKDAsIEJhc2VDb25uZWN0aW9uXzEuaXNCaW5hcnkpKChfYiA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSBOdW1iZXIocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQgJiYgY29udGVudExlbmd0aCA+IG1heENvbXByZXNzZWRSZXNwb25zZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGVycm9yc18xLlJlcXVlc3RBYm9ydGVkRXJyb3IoYFRoZSBjb250ZW50IGxlbmd0aCAoJHtjb250ZW50TGVuZ3RofSkgaXMgYmlnZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBidWZmZXIgKCR7bWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZX0pYCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnRMZW5ndGggPiBtYXhSZXNwb25zZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IGVycm9yc18xLlJlcXVlc3RBYm9ydGVkRXJyb3IoYFRoZSBjb250ZW50IGxlbmd0aCAoJHtjb250ZW50TGVuZ3RofSkgaXMgYmlnZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgKCR7bWF4UmVzcG9uc2VTaXplfSlgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHJlc3BvbnNlIGlzIGNvbXByZXNzZWQsIHdlIG11c3QgaGFuZGxlIGl0XG4gICAgICAgICAgICAgICAgLy8gYXMgYnVmZmVyIGZvciBhbGxvd2luZyBkZWNvbXByZXNzaW9uIGxhdGVyXG4gICAgICAgICAgICAgICAgbGV0IHBheWxvYWQgPSBpc0NvbXByZXNzZWQgfHwgYm9keUlzQmluYXJ5ID8gbmV3IEFycmF5KCkgOiAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBvbkRhdGEgPSBpc0NvbXByZXNzZWQgfHwgYm9keUlzQmluYXJ5ID8gb25EYXRhQXNCdWZmZXIgOiBvbkRhdGFBc1N0cmluZztcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gb25EYXRhQXNCdWZmZXIoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID4gbWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGVzdHJveShuZXcgZXJyb3JzXzEuUmVxdWVzdEFib3J0ZWRFcnJvcihgVGhlIGNvbnRlbnQgbGVuZ3RoICgke2N1cnJlbnRMZW5ndGh9KSBpcyBiaWdnZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIGJ1ZmZlciAoJHttYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplfSlgKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uRGF0YUFzU3RyaW5nKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuZGVzdHJveShuZXcgZXJyb3JzXzEuUmVxdWVzdEFib3J0ZWRFcnJvcihgVGhlIGNvbnRlbnQgbGVuZ3RoICgke2N1cnJlbnRMZW5ndGh9KSBpcyBiaWdnZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHN0cmluZyAoJHttYXhSZXNwb25zZVNpemV9KWApKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBgJHtwYXlsb2FkfSR7Y2h1bmt9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvbkVuZCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgbm9vcCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSAnYWJvcnRlZCcgJiYgZXJyLmNvZGUgPT09ICdFQ09OTlJFU0VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBlcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IoJ1Jlc3BvbnNlIGFib3J0ZWQgd2hpbGUgcmVhZGluZyB0aGUgYm9keScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ1JlcXVlc3RBYm9ydGVkRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBpc0NvbXByZXNzZWQgfHwgYm9keUlzQmluYXJ5ID8gQnVmZmVyLmNvbmNhdChwYXlsb2FkKSA6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghaXNDb21wcmVzc2VkICYmICFib2R5SXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljLmVtaXQoJ2Rlc2VyaWFsaXphdGlvbicsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvblRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vcGVuUmVxdWVzdHMtLTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgKCkgPT4geyB9KTsgLy8gd2UgbmVlZCB0byBjYXRjaCB0aGUgcmVxdWVzdCBhYm9ydGVkIGVycm9yXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoJ1JlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgICBjbGVhbkxpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wZW5SZXF1ZXN0cy0tO1xuICAgICAgICAgICAgICAgIGxldCBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnUmVxdWVzdEFib3J0ZWRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgIC0gTG9jYWw6ICR7KF9iID0gKF9hID0gcmVxdWVzdC5zb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbEFkZHJlc3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJ306JHsoX2QgPSAoX2MgPSByZXF1ZXN0LnNvY2tldCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxvY2FsUG9ydCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJ3Vua25vd24nfSwgUmVtb3RlOiAkeyhfZiA9IChfZSA9IHJlcXVlc3Quc29ja2V0KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucmVtb3RlQWRkcmVzcykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogJ3Vua25vd24nfTokeyhfaCA9IChfZyA9IHJlcXVlc3Quc29ja2V0KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucmVtb3RlUG9ydCkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogJ3Vua25vd24nfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKG1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvblNvY2tldCA9IChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICghc29ja2V0LmlzU2Vzc2lvblJldXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5vbmNlKCdzZWN1cmVDb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNzdWVyQ2VydGlmaWNhdGUgPSAoMCwgQmFzZUNvbm5lY3Rpb25fMS5nZXRJc3N1ZXJDZXJ0aWZpY2F0ZSkoc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWVyQ2VydGlmaWNhdGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIG9yIG1hbGZvcm1lZCBjZXJ0aWZpY2F0ZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgKCkgPT4geyB9KTsgLy8gd2UgbmVlZCB0byBjYXRjaCB0aGUgcmVxdWVzdCBhYm9ydGVkIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmluZ2VycHJpbnQgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKDAsIEJhc2VDb25uZWN0aW9uXzEuaXNDYUZpbmdlcnByaW50TWF0Y2gpKHRoaXNbc3ltYm9sc18xLmtDYUZpbmdlcnByaW50XSwgaXNzdWVyQ2VydGlmaWNhdGUuZmluZ2VycHJpbnQyNTYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihuZXcgRXJyb3IoJ1NlcnZlciBjZXJ0aWZpY2F0ZSBDQSBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCB0aGUgdmFsdWUgY29uZmlndXJlZCBpbiBjYUZpbmdlcnByaW50JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25jZSgnZXJyb3InLCAoKSA9PiB7IH0pOyAvLyB3ZSBuZWVkIHRvIGNhdGNoIHRoZSByZXF1ZXN0IGFib3J0ZWQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKCdyZXNwb25zZScsIG9uUmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbigndGltZW91dCcsIG9uVGltZW91dCk7XG4gICAgICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKHRoaXNbc3ltYm9sc18xLmtDYUZpbmdlcnByaW50XSAhPSBudWxsICYmIHJlcXVlc3RQYXJhbXMucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5vbignc29ja2V0Jywgb25Tb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzYWJsZXMgdGhlIE5hZ2xlIGFsZ29yaXRobVxuICAgICAgICAgICAgcmVxdWVzdC5zZXROb0RlbGF5KHRydWUpO1xuICAgICAgICAgICAgLy8gc3RhcnRzIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICBpZiAoaXNTdHJlYW0ocGFyYW1zLmJvZHkpKSB7XG4gICAgICAgICAgICAgICAgKDAsIG5vZGVfc3RyZWFtXzEucGlwZWxpbmUpKHBhcmFtcy5ib2R5LCByZXF1ZXN0LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCAmJiAhY2xlYW5lZExpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5MaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wZW5SZXF1ZXN0cy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuZW5kKHBhcmFtcy5ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgICAgICAgICAgZnVuY3Rpb24gY2xlYW5MaXN0ZW5lcnMoKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVMaXN0ZW5lcigncmVzcG9uc2UnLCBvblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCd0aW1lb3V0Jywgb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlTGlzdGVuZXIoJ3NvY2tldCcsIG9uU29ja2V0KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0TGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zaWduYWwucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYW5lZExpc3RlbmVycyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcoJ0Nsb3NpbmcgY29ubmVjdGlvbicsIHRoaXMuaWQpO1xuICAgICAgICB3aGlsZSAodGhpcy5fb3BlblJlcXVlc3RzID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgKDAsIHByb21pc2VzXzEuc2V0VGltZW91dCkoMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMuYWdlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hZ2VudC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRSZXF1ZXN0T2JqZWN0KHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMudXJsO1xuICAgICAgICBsZXQgc2VhcmNoID0gdXJsLnNlYXJjaDtcbiAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgcHJvdG9jb2w6IHVybC5wcm90b2NvbCxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB1cmwuaG9zdG5hbWVbMF0gPT09ICdbJ1xuICAgICAgICAgICAgICAgID8gdXJsLmhvc3RuYW1lLnNsaWNlKDEsIC0xKVxuICAgICAgICAgICAgICAgIDogdXJsLmhvc3RuYW1lLFxuICAgICAgICAgICAgcGF0aDogJycsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9lbGFzdGljc2VhcmNoLWpzL2lzc3Vlcy84NDNcbiAgICAgICAgICAgIHBvcnQ6IHVybC5wb3J0ICE9PSAnJyA/IHVybC5wb3J0IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgICAgICAgICB0aW1lb3V0OiAoX2EgPSBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJhbXNLZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtc0tleXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhcmFtc0tleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAncGF0aCcpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJlc29sdmUocGF0aG5hbWUsIHBhcmFtc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3F1ZXJ5c3RyaW5nJyAmJiBCb29sZWFuKHBhcmFtc1trZXldKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaCA9IGA/JHtwYXJhbXNba2V5XX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VhcmNoICs9IGAmJHtwYXJhbXNba2V5XX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2hlYWRlcnMnKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdC5oZWFkZXJzLCBwYXJhbXMuaGVhZGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgcmVxdWVzdFtrZXldID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5wYXRoID0gcGF0aG5hbWUgKyBzZWFyY2g7XG4gICAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHBDb25uZWN0aW9uO1xuZnVuY3Rpb24gaXNTdHJlYW0ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaG9zdCwgcGF0aCkge1xuICAgIGNvbnN0IGhvc3RFbmRXaXRoU2xhc2ggPSBob3N0W2hvc3QubGVuZ3RoIC0gMV0gPT09ICcvJztcbiAgICBjb25zdCBwYXRoU3RhcnRzV2l0aFNsYXNoID0gcGF0aFswXSA9PT0gJy8nO1xuICAgIGlmIChob3N0RW5kV2l0aFNsYXNoICYmIHBhdGhTdGFydHNXaXRoU2xhc2gpIHtcbiAgICAgICAgcmV0dXJuIGhvc3QgKyBwYXRoLnNsaWNlKDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChob3N0RW5kV2l0aFNsYXNoICE9PSBwYXRoU3RhcnRzV2l0aFNsYXNoKSB7XG4gICAgICAgIHJldHVybiBob3N0ICsgcGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBob3N0ICsgJy8nICsgcGF0aDtcbiAgICB9XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNIdHRwQWdlbnRPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAob3B0cy5rZWVwQWxpdmVUaW1lb3V0ICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5rZWVwQWxpdmVNYXhUaW1lb3V0ICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5rZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5waXBlbGluaW5nICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5tYXhIZWFkZXJTaXplICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5jb25uZWN0aW9ucyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IdHRwQ29ubmVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/connection/HttpConnection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/connection/UndiciConnection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/connection/UndiciConnection.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst node_buffer_1 = tslib_1.__importDefault(__webpack_require__(/*! node:buffer */ \"node:buffer\"));\nconst BaseConnection_1 = tslib_1.__importStar(__webpack_require__(/*! ./BaseConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\"));\nconst undici_1 = __webpack_require__(/*! undici */ \"(rsc)/./node_modules/undici/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst symbols_1 = __webpack_require__(/*! ../symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\nconst debug = (0, debug_1.default)('elasticsearch');\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst MAX_BUFFER_LENGTH = node_buffer_1.default.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = node_buffer_1.default.constants.MAX_STRING_LENGTH;\n/**\n * A connection to an Elasticsearch node, managed by the Undici HTTP client library\n */\nclass Connection extends BaseConnection_1.default {\n    constructor(opts) {\n        var _a;\n        super(opts);\n        Object.defineProperty(this, \"pool\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (opts.proxy != null) {\n            throw new errors_1.ConfigurationError('Undici connection can\\'t work with proxies');\n        }\n        if (typeof opts.agent === 'function' || typeof opts.agent === 'boolean') {\n            throw new errors_1.ConfigurationError('Undici connection agent options can\\'t be a function or a boolean');\n        }\n        if (opts.agent != null && !isUndiciAgentOptions(opts.agent)) {\n            throw new errors_1.ConfigurationError('Bad agent configuration for Undici agent');\n        }\n        const undiciOptions = {\n            keepAliveTimeout: 600e3,\n            keepAliveMaxTimeout: 600e3,\n            keepAliveTimeoutThreshold: 1000,\n            pipelining: 1,\n            maxHeaderSize: 16384,\n            connections: 256,\n            headersTimeout: this.timeout,\n            bodyTimeout: this.timeout,\n            ...opts.agent\n        };\n        if (this[symbols_1.kCaFingerprint] !== null) {\n            const caFingerprint = this[symbols_1.kCaFingerprint];\n            const connector = (0, undici_1.buildConnector)(((_a = this.tls) !== null && _a !== void 0 ? _a : {}));\n            undiciOptions.connect = function (opts, cb) {\n                connector(opts, (err, socket) => {\n                    if (err != null) {\n                        return cb(err, null);\n                    }\n                    if (caFingerprint !== null && isTlsSocket(opts, socket)) {\n                        const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);\n                        /* istanbul ignore next */\n                        if (issuerCertificate == null) {\n                            socket.destroy();\n                            return cb(new Error('Invalid or malformed certificate'), null);\n                        }\n                        // Check if fingerprint matches\n                        /* istanbul ignore else */\n                        if (!(0, BaseConnection_1.isCaFingerprintMatch)(caFingerprint, issuerCertificate.fingerprint256)) {\n                            socket.destroy();\n                            return cb(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'), null);\n                        }\n                    }\n                    return cb(null, socket);\n                });\n            };\n        }\n        else if (this.tls !== null) {\n            undiciOptions.connect = this.tls;\n        }\n        this.pool = new undici_1.Pool(this.url.toString(), undiciOptions);\n    }\n    async request(params, options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;\n        const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;\n        const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;\n        const requestParams = {\n            method: params.method,\n            path: params.path + (params.querystring == null || params.querystring === '' ? '' : `?${params.querystring}`),\n            headers: Object.assign({}, this.headers, params.headers),\n            body: params.body,\n            signal: (_c = options.signal) !== null && _c !== void 0 ? _c : new AbortController().signal\n        };\n        if (requestParams.path[0] !== '/') {\n            requestParams.path = `/${requestParams.path}`;\n        }\n        // undici does not support per-request timeouts,\n        // to address this issue, we default to the constructor\n        // timeout (which is handled by undici) and create a local\n        // setTimeout callback if the request-specific timeout\n        // is different from the constructor timeout.\n        let timedout = false;\n        let timeoutId;\n        if (options.timeout != null && options.timeout !== this.timeout) {\n            timeoutId = setTimeout(() => {\n                timedout = true;\n                requestParams.signal.dispatchEvent(new Event('abort'));\n            }, options.timeout);\n        }\n        // https://github.com/nodejs/node/commit/b961d9fd83\n        if (INVALID_PATH_REGEX.test(requestParams.path)) {\n            throw new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`);\n        }\n        debug('Starting a new request', params);\n        let response;\n        try {\n            // @ts-expect-error method it's fine as string\n            response = (await this.pool.request(requestParams));\n            if (timeoutId != null)\n                clearTimeout(timeoutId);\n        }\n        catch (err) {\n            if (timeoutId != null)\n                clearTimeout(timeoutId);\n            switch (err.code) {\n                case 'UND_ERR_ABORTED':\n                case DOMException.ABORT_ERR:\n                    throw (timedout ? new errors_1.TimeoutError('Request timed out') : new errors_1.RequestAbortedError('Request aborted'));\n                case 'UND_ERR_HEADERS_TIMEOUT':\n                    throw new errors_1.TimeoutError('Request timed out');\n                case 'UND_ERR_SOCKET':\n                    throw new errors_1.ConnectionError(`${err.message} - Local: ${(_e = (_d = err.socket) === null || _d === void 0 ? void 0 : _d.localAddress) !== null && _e !== void 0 ? _e : 'unknown'}:${(_g = (_f = err.socket) === null || _f === void 0 ? void 0 : _f.localPort) !== null && _g !== void 0 ? _g : 'unknown'}, Remote: ${(_j = (_h = err.socket) === null || _h === void 0 ? void 0 : _h.remoteAddress) !== null && _j !== void 0 ? _j : 'unknown'}:${(_l = (_k = err.socket) === null || _k === void 0 ? void 0 : _k.remotePort) !== null && _l !== void 0 ? _l : 'unknown'}`); // eslint-disable-line\n                default:\n                    throw new errors_1.ConnectionError(err.message);\n            }\n        }\n        if (options.asStream === true) {\n            return {\n                statusCode: response.statusCode,\n                headers: response.headers,\n                body: response.body\n            };\n        }\n        // @ts-expect-error Assume header is not string[] for now.\n        const contentEncoding = ((_m = response.headers['content-encoding']) !== null && _m !== void 0 ? _m : '').toLowerCase();\n        const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate'); // eslint-disable-line\n        const bodyIsBinary = (0, BaseConnection_1.isBinary)((_o = response.headers['content-type']) !== null && _o !== void 0 ? _o : '');\n        /* istanbul ignore else */\n        if (response.headers['content-length'] !== undefined) {\n            const contentLength = Number(response.headers['content-length']);\n            if (isCompressed && contentLength > maxCompressedResponseSize) { // eslint-disable-line\n                response.body.destroy();\n                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);\n            }\n            else if (contentLength > maxResponseSize) {\n                response.body.destroy();\n                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);\n            }\n        }\n        this.diagnostic.emit('deserialization', null, options);\n        try {\n            if (isCompressed || bodyIsBinary) { // eslint-disable-line\n                let currentLength = 0;\n                const payload = [];\n                for await (const chunk of response.body) {\n                    currentLength += Buffer.byteLength(chunk);\n                    if (currentLength > maxCompressedResponseSize) {\n                        response.body.destroy();\n                        throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);\n                    }\n                    payload.push(chunk);\n                }\n                return {\n                    statusCode: response.statusCode,\n                    headers: response.headers,\n                    body: Buffer.concat(payload)\n                };\n            }\n            else {\n                let payload = '';\n                let currentLength = 0;\n                response.body.setEncoding('utf8');\n                for await (const chunk of response.body) {\n                    currentLength += Buffer.byteLength(chunk);\n                    if (currentLength > maxResponseSize) {\n                        response.body.destroy();\n                        throw new errors_1.RequestAbortedError(`The content length (${currentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);\n                    }\n                    payload += chunk;\n                }\n                return {\n                    statusCode: response.statusCode,\n                    headers: response.headers,\n                    body: payload\n                };\n            }\n        }\n        catch (err) {\n            if (err.name === 'RequestAbortedError') {\n                throw err;\n            }\n            throw new errors_1.ConnectionError(err.message);\n        }\n    }\n    async close() {\n        debug('Closing connection', this.id);\n        await this.pool.close();\n    }\n}\nexports[\"default\"] = Connection;\n/* istanbul ignore next */\nfunction isUndiciAgentOptions(opts) {\n    if (opts.keepAlive != null)\n        return false;\n    if (opts.keepAliveMsecs != null)\n        return false;\n    if (opts.maxSockets != null)\n        return false;\n    if (opts.maxFreeSockets != null)\n        return false;\n    if (opts.scheduling != null)\n        return false;\n    if (opts.proxy != null)\n        return false;\n    return true;\n}\nfunction isTlsSocket(opts, socket) {\n    return socket !== null && opts.protocol === 'https:';\n}\n//# sourceMappingURL=UndiciConnection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL1VuZGljaUNvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQjtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLHNEQUFPO0FBQ3ZELDhDQUE4QyxtQkFBTyxDQUFDLGdDQUFhO0FBQ25FLDhDQUE4QyxtQkFBTyxDQUFDLGtHQUFrQjtBQUN4RSxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVztBQUNwQyxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLG1CQUFtQjtBQUN2SCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUJBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUJBQW1CO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGFBQWEsV0FBVyx5SEFBeUgsR0FBRyxzSEFBc0gsWUFBWSwwSEFBMEgsR0FBRyx1SEFBdUgsSUFBSTtBQUN4a0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSw4RUFBOEUsY0FBYywrQ0FBK0MsMEJBQTBCO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxjQUFjLCtDQUErQyxnQkFBZ0I7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWMsK0NBQStDLDBCQUEwQjtBQUM3SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGNBQWMsK0NBQStDLGdCQUFnQjtBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL3RyYW5zcG9ydC9saWIvY29ubmVjdGlvbi9VbmRpY2lDb25uZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zICovXG5jb25zdCBkZWJ1Z18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IG5vZGVfYnVmZmVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTpidWZmZXJcIikpO1xuY29uc3QgQmFzZUNvbm5lY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL0Jhc2VDb25uZWN0aW9uXCIpKTtcbmNvbnN0IHVuZGljaV8xID0gcmVxdWlyZShcInVuZGljaVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHN5bWJvbHNfMSA9IHJlcXVpcmUoXCIuLi9zeW1ib2xzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnZWxhc3RpY3NlYXJjaCcpO1xuY29uc3QgSU5WQUxJRF9QQVRIX1JFR0VYID0gL1teXFx1MDAyMS1cXHUwMGZmXS87XG5jb25zdCBNQVhfQlVGRkVSX0xFTkdUSCA9IG5vZGVfYnVmZmVyXzEuZGVmYXVsdC5jb25zdGFudHMuTUFYX0xFTkdUSDtcbmNvbnN0IE1BWF9TVFJJTkdfTEVOR1RIID0gbm9kZV9idWZmZXJfMS5kZWZhdWx0LmNvbnN0YW50cy5NQVhfU1RSSU5HX0xFTkdUSDtcbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIGFuIEVsYXN0aWNzZWFyY2ggbm9kZSwgbWFuYWdlZCBieSB0aGUgVW5kaWNpIEhUVFAgY2xpZW50IGxpYnJhcnlcbiAqL1xuY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIEJhc2VDb25uZWN0aW9uXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwb29sXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHRzLnByb3h5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ1VuZGljaSBjb25uZWN0aW9uIGNhblxcJ3Qgd29yayB3aXRoIHByb3hpZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdHMuYWdlbnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9wdHMuYWdlbnQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbmZpZ3VyYXRpb25FcnJvcignVW5kaWNpIGNvbm5lY3Rpb24gYWdlbnQgb3B0aW9ucyBjYW5cXCd0IGJlIGEgZnVuY3Rpb24gb3IgYSBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYWdlbnQgIT0gbnVsbCAmJiAhaXNVbmRpY2lBZ2VudE9wdGlvbnMob3B0cy5hZ2VudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25maWd1cmF0aW9uRXJyb3IoJ0JhZCBhZ2VudCBjb25maWd1cmF0aW9uIGZvciBVbmRpY2kgYWdlbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bmRpY2lPcHRpb25zID0ge1xuICAgICAgICAgICAga2VlcEFsaXZlVGltZW91dDogNjAwZTMsXG4gICAgICAgICAgICBrZWVwQWxpdmVNYXhUaW1lb3V0OiA2MDBlMyxcbiAgICAgICAgICAgIGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQ6IDEwMDAsXG4gICAgICAgICAgICBwaXBlbGluaW5nOiAxLFxuICAgICAgICAgICAgbWF4SGVhZGVyU2l6ZTogMTYzODQsXG4gICAgICAgICAgICBjb25uZWN0aW9uczogMjU2LFxuICAgICAgICAgICAgaGVhZGVyc1RpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgICAgICAgIGJvZHlUaW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICAgICAgICAuLi5vcHRzLmFnZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW3N5bWJvbHNfMS5rQ2FGaW5nZXJwcmludF0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhRmluZ2VycHJpbnQgPSB0aGlzW3N5bWJvbHNfMS5rQ2FGaW5nZXJwcmludF07XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0b3IgPSAoMCwgdW5kaWNpXzEuYnVpbGRDb25uZWN0b3IpKCgoX2EgPSB0aGlzLnRscykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pKTtcbiAgICAgICAgICAgIHVuZGljaU9wdGlvbnMuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RvcihvcHRzLCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FGaW5nZXJwcmludCAhPT0gbnVsbCAmJiBpc1Rsc1NvY2tldChvcHRzLCBzb2NrZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc3N1ZXJDZXJ0aWZpY2F0ZSA9ICgwLCBCYXNlQ29ubmVjdGlvbl8xLmdldElzc3VlckNlcnRpZmljYXRlKShzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZXJDZXJ0aWZpY2F0ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdJbnZhbGlkIG9yIG1hbGZvcm1lZCBjZXJ0aWZpY2F0ZScpLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGZpbmdlcnByaW50IG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCBCYXNlQ29ubmVjdGlvbl8xLmlzQ2FGaW5nZXJwcmludE1hdGNoKShjYUZpbmdlcnByaW50LCBpc3N1ZXJDZXJ0aWZpY2F0ZS5maW5nZXJwcmludDI1NikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1NlcnZlciBjZXJ0aWZpY2F0ZSBDQSBmaW5nZXJwcmludCBkb2VzIG5vdCBtYXRjaCB0aGUgdmFsdWUgY29uZmlndXJlZCBpbiBjYUZpbmdlcnByaW50JyksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihudWxsLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5kaWNpT3B0aW9ucy5jb25uZWN0ID0gdGhpcy50bHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb29sID0gbmV3IHVuZGljaV8xLlBvb2wodGhpcy51cmwudG9TdHJpbmcoKSwgdW5kaWNpT3B0aW9ucyk7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3QocGFyYW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbztcbiAgICAgICAgY29uc3QgbWF4UmVzcG9uc2VTaXplID0gKF9hID0gb3B0aW9ucy5tYXhSZXNwb25zZVNpemUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE1BWF9TVFJJTkdfTEVOR1RIO1xuICAgICAgICBjb25zdCBtYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplID0gKF9iID0gb3B0aW9ucy5tYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBNQVhfQlVGRkVSX0xFTkdUSDtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogcGFyYW1zLm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcy5wYXRoICsgKHBhcmFtcy5xdWVyeXN0cmluZyA9PSBudWxsIHx8IHBhcmFtcy5xdWVyeXN0cmluZyA9PT0gJycgPyAnJyA6IGA/JHtwYXJhbXMucXVlcnlzdHJpbmd9YCksXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMsIHBhcmFtcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIGJvZHk6IHBhcmFtcy5ib2R5LFxuICAgICAgICAgICAgc2lnbmFsOiAoX2MgPSBvcHRpb25zLnNpZ25hbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdFBhcmFtcy5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMucGF0aCA9IGAvJHtyZXF1ZXN0UGFyYW1zLnBhdGh9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1bmRpY2kgZG9lcyBub3Qgc3VwcG9ydCBwZXItcmVxdWVzdCB0aW1lb3V0cyxcbiAgICAgICAgLy8gdG8gYWRkcmVzcyB0aGlzIGlzc3VlLCB3ZSBkZWZhdWx0IHRvIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICAvLyB0aW1lb3V0ICh3aGljaCBpcyBoYW5kbGVkIGJ5IHVuZGljaSkgYW5kIGNyZWF0ZSBhIGxvY2FsXG4gICAgICAgIC8vIHNldFRpbWVvdXQgY2FsbGJhY2sgaWYgdGhlIHJlcXVlc3Qtc3BlY2lmaWMgdGltZW91dFxuICAgICAgICAvLyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY29uc3RydWN0b3IgdGltZW91dC5cbiAgICAgICAgbGV0IHRpbWVkb3V0ID0gZmFsc2U7XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIGlmIChvcHRpb25zLnRpbWVvdXQgIT0gbnVsbCAmJiBvcHRpb25zLnRpbWVvdXQgIT09IHRoaXMudGltZW91dCkge1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGltZWRvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMuc2lnbmFsLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2NvbW1pdC9iOTYxZDlmZDgzXG4gICAgICAgIGlmIChJTlZBTElEX1BBVEhfUkVHRVgudGVzdChyZXF1ZXN0UGFyYW1zLnBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFUlJfVU5FU0NBUEVEX0NIQVJBQ1RFUlM6ICR7cmVxdWVzdFBhcmFtcy5wYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdTdGFydGluZyBhIG5ldyByZXF1ZXN0JywgcGFyYW1zKTtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBtZXRob2QgaXQncyBmaW5lIGFzIHN0cmluZ1xuICAgICAgICAgICAgcmVzcG9uc2UgPSAoYXdhaXQgdGhpcy5wb29sLnJlcXVlc3QocmVxdWVzdFBhcmFtcykpO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdVTkRfRVJSX0FCT1JURUQnOlxuICAgICAgICAgICAgICAgIGNhc2UgRE9NRXhjZXB0aW9uLkFCT1JUX0VSUjpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgKHRpbWVkb3V0ID8gbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcignUmVxdWVzdCB0aW1lZCBvdXQnKSA6IG5ldyBlcnJvcnNfMS5SZXF1ZXN0QWJvcnRlZEVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnKSk7XG4gICAgICAgICAgICAgICAgY2FzZSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnOlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1VORF9FUlJfU09DS0VUJzpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbm5lY3Rpb25FcnJvcihgJHtlcnIubWVzc2FnZX0gLSBMb2NhbDogJHsoX2UgPSAoX2QgPSBlcnIuc29ja2V0KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubG9jYWxBZGRyZXNzKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAndW5rbm93bid9OiR7KF9nID0gKF9mID0gZXJyLnNvY2tldCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmxvY2FsUG9ydCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogJ3Vua25vd24nfSwgUmVtb3RlOiAkeyhfaiA9IChfaCA9IGVyci5zb2NrZXQpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZW1vdGVBZGRyZXNzKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAndW5rbm93bid9OiR7KF9sID0gKF9rID0gZXJyLnNvY2tldCkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnJlbW90ZVBvcnQpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6ICd1bmtub3duJ31gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFzU3RyZWFtID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiByZXNwb25zZS5ib2R5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgQXNzdW1lIGhlYWRlciBpcyBub3Qgc3RyaW5nW10gZm9yIG5vdy5cbiAgICAgICAgY29uc3QgY29udGVudEVuY29kaW5nID0gKChfbSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzQ29tcHJlc3NlZCA9IGNvbnRlbnRFbmNvZGluZy5pbmNsdWRlcygnZ3ppcCcpIHx8IGNvbnRlbnRFbmNvZGluZy5pbmNsdWRlcygnZGVmbGF0ZScpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGNvbnN0IGJvZHlJc0JpbmFyeSA9ICgwLCBCYXNlQ29ubmVjdGlvbl8xLmlzQmluYXJ5KSgoX28gPSByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSkgIT09IG51bGwgJiYgX28gIT09IHZvaWQgMCA/IF9vIDogJycpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gTnVtYmVyKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCAmJiBjb250ZW50TGVuZ3RoID4gbWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJlcXVlc3RBYm9ydGVkRXJyb3IoYFRoZSBjb250ZW50IGxlbmd0aCAoJHtjb250ZW50TGVuZ3RofSkgaXMgYmlnZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBidWZmZXIgKCR7bWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZX0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb250ZW50TGVuZ3RoID4gbWF4UmVzcG9uc2VTaXplKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlJlcXVlc3RBYm9ydGVkRXJyb3IoYFRoZSBjb250ZW50IGxlbmd0aCAoJHtjb250ZW50TGVuZ3RofSkgaXMgYmlnZ2VyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBzdHJpbmcgKCR7bWF4UmVzcG9uc2VTaXplfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpYWdub3N0aWMuZW1pdCgnZGVzZXJpYWxpemF0aW9uJywgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkIHx8IGJvZHlJc0JpbmFyeSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID4gbWF4Q29tcHJlc3NlZFJlc3BvbnNlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuYm9keS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUmVxdWVzdEFib3J0ZWRFcnJvcihgVGhlIGNvbnRlbnQgbGVuZ3RoICgke2N1cnJlbnRMZW5ndGh9KSBpcyBiaWdnZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIGJ1ZmZlciAoJHttYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBCdWZmZXIuY29uY2F0KHBheWxvYWQpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBwYXlsb2FkID0gJyc7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLmJvZHkuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGVuZ3RoID4gbWF4UmVzcG9uc2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5ib2R5LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SZXF1ZXN0QWJvcnRlZEVycm9yKGBUaGUgY29udGVudCBsZW5ndGggKCR7Y3VycmVudExlbmd0aH0pIGlzIGJpZ2dlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgc3RyaW5nICgke21heFJlc3BvbnNlU2l6ZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCArPSBjaHVuaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogcGF5bG9hZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5uYW1lID09PSAnUmVxdWVzdEFib3J0ZWRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgZGVidWcoJ0Nsb3NpbmcgY29ubmVjdGlvbicsIHRoaXMuaWQpO1xuICAgICAgICBhd2FpdCB0aGlzLnBvb2wuY2xvc2UoKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzVW5kaWNpQWdlbnRPcHRpb25zKG9wdHMpIHtcbiAgICBpZiAob3B0cy5rZWVwQWxpdmUgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChvcHRzLmtlZXBBbGl2ZU1zZWNzICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5tYXhTb2NrZXRzICE9IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAob3B0cy5tYXhGcmVlU29ja2V0cyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9wdHMuc2NoZWR1bGluZyAhPSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG9wdHMucHJveHkgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNUbHNTb2NrZXQob3B0cywgc29ja2V0KSB7XG4gICAgcmV0dXJuIHNvY2tldCAhPT0gbnVsbCAmJiBvcHRzLnByb3RvY29sID09PSAnaHR0cHM6Jztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuZGljaUNvbm5lY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/connection/UndiciConnection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/connection/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/connection/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the 'License'); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UndiciConnection = exports.HttpConnection = exports.BaseConnection = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst BaseConnection_1 = tslib_1.__importDefault(__webpack_require__(/*! ./BaseConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/BaseConnection.js\"));\nexports.BaseConnection = BaseConnection_1.default;\nconst HttpConnection_1 = tslib_1.__importDefault(__webpack_require__(/*! ./HttpConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/HttpConnection.js\"));\nexports.HttpConnection = HttpConnection_1.default;\nconst UndiciConnection_1 = tslib_1.__importDefault(__webpack_require__(/*! ./UndiciConnection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/UndiciConnection.js\"));\nexports.UndiciConnection = UndiciConnection_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQzFFLGdCQUFnQixtQkFBTyxDQUFDLHVEQUFPO0FBQy9CLGlEQUFpRCxtQkFBTyxDQUFDLGtHQUFrQjtBQUMzRSxzQkFBc0I7QUFDdEIsaURBQWlELG1CQUFPLENBQUMsa0dBQWtCO0FBQzNFLHNCQUFzQjtBQUN0QixtREFBbUQsbUJBQU8sQ0FBQyxzR0FBb0I7QUFDL0Usd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9jb25uZWN0aW9uL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgJ0xpY2Vuc2UnKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiAnQVMgSVMnIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVW5kaWNpQ29ubmVjdGlvbiA9IGV4cG9ydHMuSHR0cENvbm5lY3Rpb24gPSBleHBvcnRzLkJhc2VDb25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IEJhc2VDb25uZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXNlQ29ubmVjdGlvblwiKSk7XG5leHBvcnRzLkJhc2VDb25uZWN0aW9uID0gQmFzZUNvbm5lY3Rpb25fMS5kZWZhdWx0O1xuY29uc3QgSHR0cENvbm5lY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0h0dHBDb25uZWN0aW9uXCIpKTtcbmV4cG9ydHMuSHR0cENvbm5lY3Rpb24gPSBIdHRwQ29ubmVjdGlvbl8xLmRlZmF1bHQ7XG5jb25zdCBVbmRpY2lDb25uZWN0aW9uXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9VbmRpY2lDb25uZWN0aW9uXCIpKTtcbmV4cG9ydHMuVW5kaWNpQ29ubmVjdGlvbiA9IFVuZGljaUNvbm5lY3Rpb25fMS5kZWZhdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/connection/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/errors.js":
/*!*******************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/errors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProductNotSupportedError = exports.RequestAbortedError = exports.ResponseError = exports.ConfigurationError = exports.DeserializationError = exports.SerializationError = exports.NoLivingConnectionsError = exports.ConnectionError = exports.TimeoutError = exports.ElasticsearchClientError = void 0;\nconst security_1 = __webpack_require__(/*! ./security */ \"(rsc)/./node_modules/@elastic/transport/lib/security.js\");\nclass ElasticsearchClientError extends Error {\n    constructor(message, options) {\n        super(message);\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = 'ElasticsearchClientError';\n        this.options = {\n            redaction: {\n                type: 'replace',\n                additionalKeys: []\n            }\n        };\n        if (isObject(options)) {\n            this.options.redaction = { ...this.options.redaction, ...options.redaction };\n        }\n    }\n}\nexports.ElasticsearchClientError = ElasticsearchClientError;\nclass TimeoutError extends ElasticsearchClientError {\n    constructor(message, meta, options) {\n        super(message, options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, TimeoutError);\n        this.name = 'TimeoutError';\n        this.message = message !== null && message !== void 0 ? message : 'Timeout Error';\n        if (isObject(meta))\n            meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n        this.meta = meta;\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass ConnectionError extends ElasticsearchClientError {\n    constructor(message, meta, options) {\n        super(message, options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ConnectionError);\n        this.name = 'ConnectionError';\n        this.message = message !== null && message !== void 0 ? message : 'Connection Error';\n        if (isObject(meta))\n            meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n        this.meta = meta;\n    }\n}\nexports.ConnectionError = ConnectionError;\nclass NoLivingConnectionsError extends ElasticsearchClientError {\n    constructor(message, meta, options) {\n        super(message, options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, NoLivingConnectionsError);\n        this.name = 'NoLivingConnectionsError';\n        this.message = message !== null && message !== void 0 ? message : 'Given the configuration, the ConnectionPool was not able to find a usable Connection for this request.';\n        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n    }\n}\nexports.NoLivingConnectionsError = NoLivingConnectionsError;\nclass SerializationError extends ElasticsearchClientError {\n    constructor(message, data) {\n        super(message);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, SerializationError);\n        this.name = 'SerializationError';\n        this.message = message !== null && message !== void 0 ? message : 'Serialization Error';\n        this.data = data;\n    }\n}\nexports.SerializationError = SerializationError;\nclass DeserializationError extends ElasticsearchClientError {\n    constructor(message, data) {\n        super(message);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, DeserializationError);\n        this.name = 'DeserializationError';\n        this.message = message !== null && message !== void 0 ? message : 'Deserialization Error';\n        this.data = data;\n    }\n}\nexports.DeserializationError = DeserializationError;\nclass ConfigurationError extends ElasticsearchClientError {\n    constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ConfigurationError);\n        this.name = 'ConfigurationError';\n        this.message = message !== null && message !== void 0 ? message : 'Configuration Error';\n    }\n}\nexports.ConfigurationError = ConfigurationError;\nclass ResponseError extends ElasticsearchClientError {\n    constructor(meta, options) {\n        var _a;\n        super('Response Error', options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ResponseError);\n        this.name = 'ResponseError';\n        if (meta.statusCode === 410) {\n            this.message = 'This API is unavailable in the version of Elasticsearch you are using.';\n        }\n        else if (isObject(meta.body) && meta.body.error != null && meta.body.error.type != null) {\n            this.message = meta.body.error.type;\n            if (isObject(meta.body.error.caused_by)) {\n                const { type, reason } = meta.body.error.caused_by;\n                const causedBy = [\n                    '\\tCaused by:',\n                    `\\t\\t${type}: ${reason}`\n                ].join('\\n');\n                this.message += `\\n${causedBy}`;\n            }\n            if (Array.isArray(meta.body.error.root_cause) && meta.body.error.root_cause.length !== 0) {\n                const formatRootCause = (entry) => `\\t\\t${entry.type}: ${entry.reason}`;\n                const rootCauses = [\n                    '\\tRoot causes:',\n                    ...meta.body.error.root_cause.map(formatRootCause)\n                ].join('\\n');\n                this.message += `\\n${rootCauses}`;\n            }\n        }\n        else if (typeof meta.body === 'object' && meta.body != null) {\n            this.message = JSON.stringify(meta.body);\n        }\n        else {\n            this.message = (_a = meta.body) !== null && _a !== void 0 ? _a : 'Response Error';\n        }\n        this.meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n    }\n    get body() {\n        return this.meta.body;\n    }\n    get statusCode() {\n        if (isObject(this.meta.body) && typeof this.meta.body.status === 'number') {\n            return this.meta.body.status;\n        }\n        return this.meta.statusCode;\n    }\n    get headers() {\n        return this.meta.headers;\n    }\n}\nexports.ResponseError = ResponseError;\nclass RequestAbortedError extends ElasticsearchClientError {\n    constructor(message, meta, options) {\n        super(message, options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = 'RequestAbortedError';\n        this.message = message !== null && message !== void 0 ? message : 'Request aborted';\n        if (isObject(meta))\n            meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n        this.meta = meta;\n    }\n}\nexports.RequestAbortedError = RequestAbortedError;\nclass ProductNotSupportedError extends ElasticsearchClientError {\n    constructor(product, meta, options) {\n        super('Product Not Supported Error', options);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ProductNotSupportedError);\n        this.name = 'ProductNotSupportedError';\n        this.message = `The client noticed that the server is not ${product} and we do not support this unknown product.`;\n        if (isObject(meta))\n            meta = (0, security_1.redactDiagnostic)(meta, this.options.redaction);\n        this.meta = meta;\n    }\n}\nexports.ProductNotSupportedError = ProductNotSupportedError;\nfunction isObject(obj) {\n    return typeof obj === 'object' && obj !== null;\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRyxxQkFBcUIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEIsR0FBRyxnQ0FBZ0MsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0M7QUFDdFMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0EsMkJBQTJCLEtBQUssSUFBSSxPQUFPO0FBQzNDO0FBQ0EscUNBQXFDLFNBQVM7QUFDOUM7QUFDQTtBQUNBLDBEQUEwRCxXQUFXLElBQUksYUFBYTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9FQUFvRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9kdWN0Tm90U3VwcG9ydGVkRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RBYm9ydGVkRXJyb3IgPSBleHBvcnRzLlJlc3BvbnNlRXJyb3IgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb25FcnJvciA9IGV4cG9ydHMuRGVzZXJpYWxpemF0aW9uRXJyb3IgPSBleHBvcnRzLlNlcmlhbGl6YXRpb25FcnJvciA9IGV4cG9ydHMuTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yID0gZXhwb3J0cy5Db25uZWN0aW9uRXJyb3IgPSBleHBvcnRzLlRpbWVvdXRFcnJvciA9IGV4cG9ydHMuRWxhc3RpY3NlYXJjaENsaWVudEVycm9yID0gdm9pZCAwO1xuY29uc3Qgc2VjdXJpdHlfMSA9IHJlcXVpcmUoXCIuL3NlY3VyaXR5XCIpO1xuY2xhc3MgRWxhc3RpY3NlYXJjaENsaWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm9wdGlvbnNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0VsYXN0aWNzZWFyY2hDbGllbnRFcnJvcic7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlZGFjdGlvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgICAgICAgICAgICBhZGRpdGlvbmFsS2V5czogW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVkYWN0aW9uID0geyAuLi50aGlzLm9wdGlvbnMucmVkYWN0aW9uLCAuLi5vcHRpb25zLnJlZGFjdGlvbiB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5FbGFzdGljc2VhcmNoQ2xpZW50RXJyb3IgPSBFbGFzdGljc2VhcmNoQ2xpZW50RXJyb3I7XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFbGFzdGljc2VhcmNoQ2xpZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG1ldGEsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVGltZW91dEVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RpbWVvdXRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdUaW1lb3V0IEVycm9yJztcbiAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGEpKVxuICAgICAgICAgICAgbWV0YSA9ICgwLCBzZWN1cml0eV8xLnJlZGFjdERpYWdub3N0aWMpKG1ldGEsIHRoaXMub3B0aW9ucy5yZWRhY3Rpb24pO1xuICAgICAgICB0aGlzLm1ldGEgPSBtZXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuY2xhc3MgQ29ubmVjdGlvbkVycm9yIGV4dGVuZHMgRWxhc3RpY3NlYXJjaENsaWVudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBtZXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIENvbm5lY3Rpb25FcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDb25uZWN0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnQ29ubmVjdGlvbiBFcnJvcic7XG4gICAgICAgIGlmIChpc09iamVjdChtZXRhKSlcbiAgICAgICAgICAgIG1ldGEgPSAoMCwgc2VjdXJpdHlfMS5yZWRhY3REaWFnbm9zdGljKShtZXRhLCB0aGlzLm9wdGlvbnMucmVkYWN0aW9uKTtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbmNsYXNzIE5vTGl2aW5nQ29ubmVjdGlvbnNFcnJvciBleHRlbmRzIEVsYXN0aWNzZWFyY2hDbGllbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgbWV0YSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb0xpdmluZ0Nvbm5lY3Rpb25zRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ0dpdmVuIHRoZSBjb25maWd1cmF0aW9uLCB0aGUgQ29ubmVjdGlvblBvb2wgd2FzIG5vdCBhYmxlIHRvIGZpbmQgYSB1c2FibGUgQ29ubmVjdGlvbiBmb3IgdGhpcyByZXF1ZXN0Lic7XG4gICAgICAgIHRoaXMubWV0YSA9ICgwLCBzZWN1cml0eV8xLnJlZGFjdERpYWdub3N0aWMpKG1ldGEsIHRoaXMub3B0aW9ucy5yZWRhY3Rpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yID0gTm9MaXZpbmdDb25uZWN0aW9uc0Vycm9yO1xuY2xhc3MgU2VyaWFsaXphdGlvbkVycm9yIGV4dGVuZHMgRWxhc3RpY3NlYXJjaENsaWVudEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFNlcmlhbGl6YXRpb25FcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXJpYWxpemF0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAnU2VyaWFsaXphdGlvbiBFcnJvcic7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJpYWxpemF0aW9uRXJyb3IgPSBTZXJpYWxpemF0aW9uRXJyb3I7XG5jbGFzcyBEZXNlcmlhbGl6YXRpb25FcnJvciBleHRlbmRzIEVsYXN0aWNzZWFyY2hDbGllbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGF0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBEZXNlcmlhbGl6YXRpb25FcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9ICdEZXNlcmlhbGl6YXRpb25FcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdEZXNlcmlhbGl6YXRpb24gRXJyb3InO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVzZXJpYWxpemF0aW9uRXJyb3IgPSBEZXNlcmlhbGl6YXRpb25FcnJvcjtcbmNsYXNzIENvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVsYXN0aWNzZWFyY2hDbGllbnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ29uZmlndXJhdGlvbkVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbmZpZ3VyYXRpb25FcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICdDb25maWd1cmF0aW9uIEVycm9yJztcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ3VyYXRpb25FcnJvciA9IENvbmZpZ3VyYXRpb25FcnJvcjtcbmNsYXNzIFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFbGFzdGljc2VhcmNoQ2xpZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcignUmVzcG9uc2UgRXJyb3InLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBSZXNwb25zZUVycm9yKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlRXJyb3InO1xuICAgICAgICBpZiAobWV0YS5zdGF0dXNDb2RlID09PSA0MTApIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9ICdUaGlzIEFQSSBpcyB1bmF2YWlsYWJsZSBpbiB0aGUgdmVyc2lvbiBvZiBFbGFzdGljc2VhcmNoIHlvdSBhcmUgdXNpbmcuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChtZXRhLmJvZHkpICYmIG1ldGEuYm9keS5lcnJvciAhPSBudWxsICYmIG1ldGEuYm9keS5lcnJvci50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1ldGEuYm9keS5lcnJvci50eXBlO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KG1ldGEuYm9keS5lcnJvci5jYXVzZWRfYnkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlLCByZWFzb24gfSA9IG1ldGEuYm9keS5lcnJvci5jYXVzZWRfYnk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F1c2VkQnkgPSBbXG4gICAgICAgICAgICAgICAgICAgICdcXHRDYXVzZWQgYnk6JyxcbiAgICAgICAgICAgICAgICAgICAgYFxcdFxcdCR7dHlwZX06ICR7cmVhc29ufWBcbiAgICAgICAgICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBgXFxuJHtjYXVzZWRCeX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWV0YS5ib2R5LmVycm9yLnJvb3RfY2F1c2UpICYmIG1ldGEuYm9keS5lcnJvci5yb290X2NhdXNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdFJvb3RDYXVzZSA9IChlbnRyeSkgPT4gYFxcdFxcdCR7ZW50cnkudHlwZX06ICR7ZW50cnkucmVhc29ufWA7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vdENhdXNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ1xcdFJvb3QgY2F1c2VzOicsXG4gICAgICAgICAgICAgICAgICAgIC4uLm1ldGEuYm9keS5lcnJvci5yb290X2NhdXNlLm1hcChmb3JtYXRSb290Q2F1c2UpXG4gICAgICAgICAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gYFxcbiR7cm9vdENhdXNlc31gO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXRhLmJvZHkgPT09ICdvYmplY3QnICYmIG1ldGEuYm9keSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShtZXRhLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gKF9hID0gbWV0YS5ib2R5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnUmVzcG9uc2UgRXJyb3InO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0YSA9ICgwLCBzZWN1cml0eV8xLnJlZGFjdERpYWdub3N0aWMpKG1ldGEsIHRoaXMub3B0aW9ucy5yZWRhY3Rpb24pO1xuICAgIH1cbiAgICBnZXQgYm9keSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5ib2R5O1xuICAgIH1cbiAgICBnZXQgc3RhdHVzQ29kZSgpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRoaXMubWV0YS5ib2R5KSAmJiB0eXBlb2YgdGhpcy5tZXRhLmJvZHkuc3RhdHVzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YS5ib2R5LnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tZXRhLnN0YXR1c0NvZGU7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhLmhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNwb25zZUVycm9yID0gUmVzcG9uc2VFcnJvcjtcbmNsYXNzIFJlcXVlc3RBYm9ydGVkRXJyb3IgZXh0ZW5kcyBFbGFzdGljc2VhcmNoQ2xpZW50RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG1ldGEsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1ldGFcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUmVxdWVzdEFib3J0ZWRFcnJvcik7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSZXF1ZXN0QWJvcnRlZEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ1JlcXVlc3QgYWJvcnRlZCc7XG4gICAgICAgIGlmIChpc09iamVjdChtZXRhKSlcbiAgICAgICAgICAgIG1ldGEgPSAoMCwgc2VjdXJpdHlfMS5yZWRhY3REaWFnbm9zdGljKShtZXRhLCB0aGlzLm9wdGlvbnMucmVkYWN0aW9uKTtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RBYm9ydGVkRXJyb3IgPSBSZXF1ZXN0QWJvcnRlZEVycm9yO1xuY2xhc3MgUHJvZHVjdE5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRWxhc3RpY3NlYXJjaENsaWVudEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9kdWN0LCBtZXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCdQcm9kdWN0IE5vdCBTdXBwb3J0ZWQgRXJyb3InLCBvcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWV0YVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBQcm9kdWN0Tm90U3VwcG9ydGVkRXJyb3IpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUHJvZHVjdE5vdFN1cHBvcnRlZEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFRoZSBjbGllbnQgbm90aWNlZCB0aGF0IHRoZSBzZXJ2ZXIgaXMgbm90ICR7cHJvZHVjdH0gYW5kIHdlIGRvIG5vdCBzdXBwb3J0IHRoaXMgdW5rbm93biBwcm9kdWN0LmA7XG4gICAgICAgIGlmIChpc09iamVjdChtZXRhKSlcbiAgICAgICAgICAgIG1ldGEgPSAoMCwgc2VjdXJpdHlfMS5yZWRhY3REaWFnbm9zdGljKShtZXRhLCB0aGlzLm9wdGlvbnMucmVkYWN0aW9uKTtcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICB9XG59XG5leHBvcnRzLlByb2R1Y3ROb3RTdXBwb3J0ZWRFcnJvciA9IFByb2R1Y3ROb3RTdXBwb3J0ZWRFcnJvcjtcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGw7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js":
/*!************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst Diagnostic_1 = tslib_1.__importDefault(__webpack_require__(/*! ../Diagnostic */ \"(rsc)/./node_modules/@elastic/transport/lib/Diagnostic.js\"));\nconst symbols_1 = __webpack_require__(/*! ../symbols */ \"(rsc)/./node_modules/@elastic/transport/lib/symbols.js\");\nconst connection_1 = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/index.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/@elastic/transport/lib/errors.js\");\nconst debug = (0, debug_1.default)('elasticsearch');\n/**\n * Manages the HTTP connections to each Elasticsearch node,\n * keeping track of which are currently dead or alive, and\n * provides the functionality for deciding which node to send\n * a request to.\n */\nclass BaseConnectionPool {\n    constructor(opts) {\n        var _b;\n        Object.defineProperty(this, \"connections\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"Connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"diagnostic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"auth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_agent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_proxy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // list of nodes and weights\n        this.connections = [];\n        // how many nodes we have in our scheduler\n        this.size = this.connections.length;\n        this.Connection = opts.Connection;\n        this.diagnostic = (_b = opts.diagnostic) !== null && _b !== void 0 ? _b : new Diagnostic_1.default();\n        this.auth = opts.auth;\n        this._tls = opts.tls;\n        this._agent = opts.agent;\n        this._proxy = opts.proxy;\n        this[symbols_1.kCaFingerprint] = opts.caFingerprint;\n    }\n    markAlive(connection) {\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        return this;\n    }\n    markDead(connection) {\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        return this;\n    }\n    getConnection(opts) {\n        throw new errors_1.ConfigurationError('The getConnection method should be implemented by extended classes');\n    }\n    /**\n     * Creates a new connection instance.\n     */\n    createConnection(opts) {\n        if (typeof opts === 'string') {\n            opts = this.urlToHost(opts);\n        }\n        if (this.auth != null) {\n            opts.auth = this.auth;\n        }\n        else if (opts.url.username !== '' && opts.url.password !== '') {\n            opts.auth = {\n                username: decodeURIComponent(opts.url.username),\n                password: decodeURIComponent(opts.url.password)\n            };\n        }\n        /* istanbul ignore else */\n        if (opts.tls == null)\n            opts.tls = this._tls;\n        /* istanbul ignore else */\n        if (opts.agent == null)\n            opts.agent = this._agent;\n        /* istanbul ignore else */\n        if (opts.proxy == null)\n            opts.proxy = this._proxy;\n        /* istanbul ignore else */\n        if (opts.diagnostic == null)\n            opts.diagnostic = this.diagnostic;\n        /* istanbul ignore else */\n        if (opts.caFingerprint == null)\n            opts.caFingerprint = this[symbols_1.kCaFingerprint];\n        const connection = new this.Connection(opts);\n        for (const conn of this.connections) {\n            if (conn.id === connection.id) {\n                throw new Error(`Connection with id '${connection.id}' is already present`);\n            }\n        }\n        return connection;\n    }\n    /**\n     * Adds a new connection to the pool.\n     *\n     * @param connection Connection options, or the URL of a node\n     * @returns This ConnectionPool instance\n     */\n    addConnection(connection) {\n        if (Array.isArray(connection)) {\n            const connections = [];\n            for (const conn of connection) {\n                connections.push(this.createConnection(conn));\n            }\n            return this.update([...this.connections, ...connections]);\n        }\n        else {\n            return this.update([...this.connections, this.createConnection(connection)]);\n        }\n    }\n    /**\n     * Removes a connection from the pool.\n     *\n     * @param connection The connection to remove\n     * @returns This ConnectionPool instance\n     */\n    removeConnection(connection) {\n        debug('Removing connection', connection);\n        return this.update(this.connections.filter(c => c.id !== connection.id));\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        debug('Emptying the connection pool');\n        const connections = this.connections;\n        this.connections = [];\n        this.size = 0;\n        for (const connection of connections) {\n            await connection.close();\n        }\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param nodes array of connections\n     * @returns {ConnectionPool}\n     */\n    update(nodes) {\n        debug('Updating the connection pool');\n        const newConnections = [];\n        const oldConnections = [];\n        for (const node of nodes) {\n            // if we already have a given connection in the pool\n            // we mark it as alive and we do not close the connection\n            // to avoid socket issues\n            const connectionById = this.connections.find(c => c.id === node.id);\n            const connectionByUrl = this.connections.find(c => c.id === node.url.href);\n            if (connectionById != null) {\n                debug(`The connection with id '${node.id}' is already present`);\n                this.markAlive(connectionById);\n                newConnections.push(connectionById);\n                // in case the user has passed a single url (or an array of urls),\n                // the connection id will be the full href; to avoid closing valid connections\n                // because are not present in the pool, we check also the node url,\n                // and if is already present we update its id with the ES provided one.\n            }\n            else if (connectionByUrl != null) {\n                connectionByUrl.id = node.id;\n                this.markAlive(connectionByUrl);\n                newConnections.push(connectionByUrl);\n            }\n            else {\n                if (node instanceof connection_1.BaseConnection) {\n                    newConnections.push(node);\n                }\n                else {\n                    newConnections.push(this.createConnection(node));\n                }\n            }\n        }\n        const ids = nodes.map(c => c.id);\n        // remove all the dead connections and old connections\n        for (const connection of this.connections) {\n            if (!ids.includes(connection.id)) {\n                oldConnections.push(connection);\n            }\n        }\n        // close old connections\n        for (const connection of oldConnections) {\n            connection.close().catch(/* istanbul ignore next */ () => { });\n        }\n        this.connections = newConnections;\n        this.size = this.connections.length;\n        return this;\n    }\n    /**\n     * Transforms the nodes objects to a host object.\n     *\n     * @param {object} nodes\n     * @returns {array} hosts\n     */\n    nodesToHost(nodes, protocol) {\n        const ids = Object.keys(nodes);\n        const hosts = [];\n        for (let i = 0, len = ids.length; i < len; i++) {\n            const node = nodes[ids[i]];\n            // newly-added nodes do not have http assigned yet, so skip\n            if (node.http === undefined)\n                continue;\n            // If there is no protocol in\n            // the `publish_address` new URL will throw\n            // the publish_address can have two forms:\n            //   - ip:port\n            //   - hostname/ip:port\n            // if we encounter the second case, we should\n            // use the hostname instead of the ip\n            let address = node.http.publish_address;\n            const parts = address.split('/');\n            // the url is in the form of hostname/ip:port\n            if (parts.length > 1) {\n                const hostname = parts[0];\n                const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n                address = `${hostname}:${port}`;\n            }\n            address = address.slice(0, 4) === 'http'\n                /* istanbul ignore next */\n                ? address\n                : `${protocol}//${address}`;\n            hosts.push({\n                url: new node_url_1.URL(address),\n                id: ids[i]\n            });\n        }\n        return hosts;\n    }\n    /**\n     * Transforms an url string to a host object\n     *\n     * @param {string} url\n     * @returns {object} host\n     */\n    urlToHost(url) {\n        return {\n            url: new node_url_1.URL(url)\n        };\n    }\n}\n_a = symbols_1.kCaFingerprint;\nexports[\"default\"] = BaseConnectionPool;\n//# sourceMappingURL=BaseConnectionPool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL0Jhc2VDb25uZWN0aW9uUG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLG1CQUFPLENBQUMsdURBQU87QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsMEJBQVU7QUFDckMsd0NBQXdDLG1CQUFPLENBQUMsc0RBQU87QUFDdkQsNkNBQTZDLG1CQUFPLENBQUMsZ0ZBQWU7QUFDcEUsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVk7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsc0ZBQWU7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUyxHQUFHLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUyxJQUFJLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL3RyYW5zcG9ydC9saWIvcG9vbC9CYXNlQ29ubmVjdGlvblBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBub2RlX3VybF8xID0gcmVxdWlyZShcIm5vZGU6dXJsXCIpO1xuY29uc3QgZGVidWdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBEaWFnbm9zdGljXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vRGlhZ25vc3RpY1wiKSk7XG5jb25zdCBzeW1ib2xzXzEgPSByZXF1aXJlKFwiLi4vc3ltYm9sc1wiKTtcbmNvbnN0IGNvbm5lY3Rpb25fMSA9IHJlcXVpcmUoXCIuLi9jb25uZWN0aW9uXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KSgnZWxhc3RpY3NlYXJjaCcpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBIVFRQIGNvbm5lY3Rpb25zIHRvIGVhY2ggRWxhc3RpY3NlYXJjaCBub2RlLFxuICoga2VlcGluZyB0cmFjayBvZiB3aGljaCBhcmUgY3VycmVudGx5IGRlYWQgb3IgYWxpdmUsIGFuZFxuICogcHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgZm9yIGRlY2lkaW5nIHdoaWNoIG5vZGUgdG8gc2VuZFxuICogYSByZXF1ZXN0IHRvLlxuICovXG5jbGFzcyBCYXNlQ29ubmVjdGlvblBvb2wge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9iO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25uZWN0aW9uc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaXplXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIkNvbm5lY3Rpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGlhZ25vc3RpY1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhdXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9hZ2VudFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcHJveHlcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiX3Rsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2EsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGxpc3Qgb2Ygbm9kZXMgYW5kIHdlaWdodHNcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICAvLyBob3cgbWFueSBub2RlcyB3ZSBoYXZlIGluIG91ciBzY2hlZHVsZXJcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHRoaXMuQ29ubmVjdGlvbiA9IG9wdHMuQ29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5kaWFnbm9zdGljID0gKF9iID0gb3B0cy5kaWFnbm9zdGljKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgRGlhZ25vc3RpY18xLmRlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5hdXRoID0gb3B0cy5hdXRoO1xuICAgICAgICB0aGlzLl90bHMgPSBvcHRzLnRscztcbiAgICAgICAgdGhpcy5fYWdlbnQgPSBvcHRzLmFnZW50O1xuICAgICAgICB0aGlzLl9wcm94eSA9IG9wdHMucHJveHk7XG4gICAgICAgIHRoaXNbc3ltYm9sc18xLmtDYUZpbmdlcnByaW50XSA9IG9wdHMuY2FGaW5nZXJwcmludDtcbiAgICB9XG4gICAgbWFya0FsaXZlKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMgPSBjb25uZWN0aW9uXzEuQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMuQUxJVkU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXJrRGVhZChjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzID0gY29ubmVjdGlvbl8xLkJhc2VDb25uZWN0aW9uLnN0YXR1c2VzLkRFQUQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uKG9wdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNvbmZpZ3VyYXRpb25FcnJvcignVGhlIGdldENvbm5lY3Rpb24gbWV0aG9kIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBleHRlbmRlZCBjbGFzc2VzJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29ubmVjdGlvbiBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjcmVhdGVDb25uZWN0aW9uKG9wdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3B0cyA9IHRoaXMudXJsVG9Ib3N0KG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dGggIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5hdXRoID0gdGhpcy5hdXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMudXJsLnVzZXJuYW1lICE9PSAnJyAmJiBvcHRzLnVybC5wYXNzd29yZCAhPT0gJycpIHtcbiAgICAgICAgICAgIG9wdHMuYXV0aCA9IHtcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogZGVjb2RlVVJJQ29tcG9uZW50KG9wdHMudXJsLnVzZXJuYW1lKSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogZGVjb2RlVVJJQ29tcG9uZW50KG9wdHMudXJsLnBhc3N3b3JkKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob3B0cy50bHMgPT0gbnVsbClcbiAgICAgICAgICAgIG9wdHMudGxzID0gdGhpcy5fdGxzO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob3B0cy5hZ2VudCA9PSBudWxsKVxuICAgICAgICAgICAgb3B0cy5hZ2VudCA9IHRoaXMuX2FnZW50O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob3B0cy5wcm94eSA9PSBudWxsKVxuICAgICAgICAgICAgb3B0cy5wcm94eSA9IHRoaXMuX3Byb3h5O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAob3B0cy5kaWFnbm9zdGljID09IG51bGwpXG4gICAgICAgICAgICBvcHRzLmRpYWdub3N0aWMgPSB0aGlzLmRpYWdub3N0aWM7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChvcHRzLmNhRmluZ2VycHJpbnQgPT0gbnVsbClcbiAgICAgICAgICAgIG9wdHMuY2FGaW5nZXJwcmludCA9IHRoaXNbc3ltYm9sc18xLmtDYUZpbmdlcnByaW50XTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IG5ldyB0aGlzLkNvbm5lY3Rpb24ob3B0cyk7XG4gICAgICAgIGZvciAoY29uc3QgY29ubiBvZiB0aGlzLmNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29ubi5pZCA9PT0gY29ubmVjdGlvbi5pZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiB3aXRoIGlkICcke2Nvbm5lY3Rpb24uaWR9JyBpcyBhbHJlYWR5IHByZXNlbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBjb25uZWN0aW9uIHRvIHRoZSBwb29sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb24gQ29ubmVjdGlvbiBvcHRpb25zLCBvciB0aGUgVVJMIG9mIGEgbm9kZVxuICAgICAqIEByZXR1cm5zIFRoaXMgQ29ubmVjdGlvblBvb2wgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbm4gb2YgY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25zLnB1c2godGhpcy5jcmVhdGVDb25uZWN0aW9uKGNvbm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShbLi4udGhpcy5jb25uZWN0aW9ucywgLi4uY29ubmVjdGlvbnNdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZShbLi4udGhpcy5jb25uZWN0aW9ucywgdGhpcy5jcmVhdGVDb25uZWN0aW9uKGNvbm5lY3Rpb24pXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNvbm5lY3Rpb24gZnJvbSB0aGUgcG9vbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm5zIFRoaXMgQ29ubmVjdGlvblBvb2wgaW5zdGFuY2VcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgZGVidWcoJ1JlbW92aW5nIGNvbm5lY3Rpb24nLCBjb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKHRoaXMuY29ubmVjdGlvbnMuZmlsdGVyKGMgPT4gYy5pZCAhPT0gY29ubmVjdGlvbi5pZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbXB0aWVzIHRoZSBjb25uZWN0aW9uIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvblBvb2x9XG4gICAgICovXG4gICAgYXN5bmMgZW1wdHkoKSB7XG4gICAgICAgIGRlYnVnKCdFbXB0eWluZyB0aGUgY29ubmVjdGlvbiBwb29sJyk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGF3YWl0IGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIENvbm5lY3Rpb25Qb29sIHdpdGggbmV3IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vZGVzIGFycmF5IG9mIGNvbm5lY3Rpb25zXG4gICAgICogQHJldHVybnMge0Nvbm5lY3Rpb25Qb29sfVxuICAgICAqL1xuICAgIHVwZGF0ZShub2Rlcykge1xuICAgICAgICBkZWJ1ZygnVXBkYXRpbmcgdGhlIGNvbm5lY3Rpb24gcG9vbCcpO1xuICAgICAgICBjb25zdCBuZXdDb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBvbGRDb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdpdmVuIGNvbm5lY3Rpb24gaW4gdGhlIHBvb2xcbiAgICAgICAgICAgIC8vIHdlIG1hcmsgaXQgYXMgYWxpdmUgYW5kIHdlIGRvIG5vdCBjbG9zZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgc29ja2V0IGlzc3Vlc1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbkJ5SWQgPSB0aGlzLmNvbm5lY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBub2RlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25CeVVybCA9IHRoaXMuY29ubmVjdGlvbnMuZmluZChjID0+IGMuaWQgPT09IG5vZGUudXJsLmhyZWYpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb25CeUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhgVGhlIGNvbm5lY3Rpb24gd2l0aCBpZCAnJHtub2RlLmlkfScgaXMgYWxyZWFkeSBwcmVzZW50YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrQWxpdmUoY29ubmVjdGlvbkJ5SWQpO1xuICAgICAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb25zLnB1c2goY29ubmVjdGlvbkJ5SWQpO1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCBhIHNpbmdsZSB1cmwgKG9yIGFuIGFycmF5IG9mIHVybHMpLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb25uZWN0aW9uIGlkIHdpbGwgYmUgdGhlIGZ1bGwgaHJlZjsgdG8gYXZvaWQgY2xvc2luZyB2YWxpZCBjb25uZWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBwb29sLCB3ZSBjaGVjayBhbHNvIHRoZSBub2RlIHVybCxcbiAgICAgICAgICAgICAgICAvLyBhbmQgaWYgaXMgYWxyZWFkeSBwcmVzZW50IHdlIHVwZGF0ZSBpdHMgaWQgd2l0aCB0aGUgRVMgcHJvdmlkZWQgb25lLlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29ubmVjdGlvbkJ5VXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uQnlVcmwuaWQgPSBub2RlLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMubWFya0FsaXZlKGNvbm5lY3Rpb25CeVVybCk7XG4gICAgICAgICAgICAgICAgbmV3Q29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uQnlVcmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBjb25uZWN0aW9uXzEuQmFzZUNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29ubmVjdGlvbnMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Nvbm5lY3Rpb25zLnB1c2godGhpcy5jcmVhdGVDb25uZWN0aW9uKG5vZGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRzID0gbm9kZXMubWFwKGMgPT4gYy5pZCk7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgdGhlIGRlYWQgY29ubmVjdGlvbnMgYW5kIG9sZCBjb25uZWN0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgdGhpcy5jb25uZWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFpZHMuaW5jbHVkZXMoY29ubmVjdGlvbi5pZCkpIHtcbiAgICAgICAgICAgICAgICBvbGRDb25uZWN0aW9ucy5wdXNoKGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGNsb3NlIG9sZCBjb25uZWN0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2Ygb2xkQ29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKS5jYXRjaCgvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMgPSBuZXdDb25uZWN0aW9ucztcbiAgICAgICAgdGhpcy5zaXplID0gdGhpcy5jb25uZWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBub2RlcyBvYmplY3RzIHRvIGEgaG9zdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbm9kZXNcbiAgICAgKiBAcmV0dXJucyB7YXJyYXl9IGhvc3RzXG4gICAgICovXG4gICAgbm9kZXNUb0hvc3Qobm9kZXMsIHByb3RvY29sKSB7XG4gICAgICAgIGNvbnN0IGlkcyA9IE9iamVjdC5rZXlzKG5vZGVzKTtcbiAgICAgICAgY29uc3QgaG9zdHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGlkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2lkc1tpXV07XG4gICAgICAgICAgICAvLyBuZXdseS1hZGRlZCBub2RlcyBkbyBub3QgaGF2ZSBodHRwIGFzc2lnbmVkIHlldCwgc28gc2tpcFxuICAgICAgICAgICAgaWYgKG5vZGUuaHR0cCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJvdG9jb2wgaW5cbiAgICAgICAgICAgIC8vIHRoZSBgcHVibGlzaF9hZGRyZXNzYCBuZXcgVVJMIHdpbGwgdGhyb3dcbiAgICAgICAgICAgIC8vIHRoZSBwdWJsaXNoX2FkZHJlc3MgY2FuIGhhdmUgdHdvIGZvcm1zOlxuICAgICAgICAgICAgLy8gICAtIGlwOnBvcnRcbiAgICAgICAgICAgIC8vICAgLSBob3N0bmFtZS9pcDpwb3J0XG4gICAgICAgICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNlY29uZCBjYXNlLCB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgaG9zdG5hbWUgaW5zdGVhZCBvZiB0aGUgaXBcbiAgICAgICAgICAgIGxldCBhZGRyZXNzID0gbm9kZS5odHRwLnB1Ymxpc2hfYWRkcmVzcztcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLycpO1xuICAgICAgICAgICAgLy8gdGhlIHVybCBpcyBpbiB0aGUgZm9ybSBvZiBob3N0bmFtZS9pcDpwb3J0XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RuYW1lID0gcGFydHNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydCA9IHBhcnRzWzFdLm1hdGNoKC8oKD86OikpKD86WzAtOV0rKSQvZylbMF0uc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9IGAke2hvc3RuYW1lfToke3BvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIDQpID09PSAnaHR0cCdcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgID8gYWRkcmVzc1xuICAgICAgICAgICAgICAgIDogYCR7cHJvdG9jb2x9Ly8ke2FkZHJlc3N9YDtcbiAgICAgICAgICAgIGhvc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgIHVybDogbmV3IG5vZGVfdXJsXzEuVVJMKGFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIGlkOiBpZHNbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBhbiB1cmwgc3RyaW5nIHRvIGEgaG9zdCBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBob3N0XG4gICAgICovXG4gICAgdXJsVG9Ib3N0KHVybCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXJsOiBuZXcgbm9kZV91cmxfMS5VUkwodXJsKVxuICAgICAgICB9O1xuICAgIH1cbn1cbl9hID0gc3ltYm9sc18xLmtDYUZpbmdlcnByaW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZUNvbm5lY3Rpb25Qb29sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNvbm5lY3Rpb25Qb29sLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst BaseConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./BaseConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js\"));\nclass CloudConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"cloudConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cloudConnection = null;\n    }\n    /**\n     * Returns the only cloud connection.\n     *\n     * @returns {object} connection\n     */\n    getConnection(opts) {\n        return this.cloudConnection;\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.cloudConnection = null;\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.cloudConnection = this.connections[0];\n        return this;\n    }\n}\nexports[\"default\"] = CloudConnectionPool;\n//# sourceMappingURL=CloudConnectionPool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL0Nsb3VkQ29ubmVjdGlvblBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQixxREFBcUQsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL0Nsb3VkQ29ubmVjdGlvblBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBCYXNlQ29ubmVjdGlvblBvb2xfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VDb25uZWN0aW9uUG9vbFwiKSk7XG5jbGFzcyBDbG91ZENvbm5lY3Rpb25Qb29sIGV4dGVuZHMgQmFzZUNvbm5lY3Rpb25Qb29sXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2xvdWRDb25uZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xvdWRDb25uZWN0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb25seSBjbG91ZCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gY29ubmVjdGlvblxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpb24ob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG91ZENvbm5lY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgdGhlIGNvbm5lY3Rpb24gcG9vbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtDb25uZWN0aW9uUG9vbH1cbiAgICAgKi9cbiAgICBhc3luYyBlbXB0eSgpIHtcbiAgICAgICAgYXdhaXQgc3VwZXIuZW1wdHkoKTtcbiAgICAgICAgdGhpcy5jbG91ZENvbm5lY3Rpb24gPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIENvbm5lY3Rpb25Qb29sIHdpdGggbmV3IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyYXkgb2YgY29ubmVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvblBvb2x9XG4gICAgICovXG4gICAgdXBkYXRlKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShjb25uZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuY2xvdWRDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uc1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2xvdWRDb25uZWN0aW9uUG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsb3VkQ29ubmVjdGlvblBvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst BaseConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./BaseConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js\"));\nconst node_assert_1 = tslib_1.__importDefault(__webpack_require__(/*! node:assert */ \"node:assert\"));\nconst debug_1 = tslib_1.__importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst connection_1 = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/index.js\");\nconst debug = (0, debug_1.default)('elasticsearch');\nclass ClusterConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        var _a, _b;\n        super(opts);\n        Object.defineProperty(this, \"dead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeoutCutoff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pingTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectStrategy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.dead = [];\n        // the resurrect timeout is 60s\n        this.resurrectTimeout = 1000 * 60;\n        // number of consecutive failures after which\n        // the timeout doesn't increase\n        this.resurrectTimeoutCutoff = 5;\n        this.pingTimeout = (_a = opts.pingTimeout) !== null && _a !== void 0 ? _a : 3000;\n        const resurrectStrategy = (_b = opts.resurrectStrategy) !== null && _b !== void 0 ? _b : 'ping';\n        this.resurrectStrategy = ClusterConnectionPool.resurrectStrategies[resurrectStrategy];\n        (0, node_assert_1.default)(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);\n    }\n    /**\n     * Marks a connection as 'alive'.\n     * If needed removes the connection from the dead list\n     * and then resets the `deadCount`.\n     *\n     * @param {object} connection\n     */\n    markAlive(connection) {\n        const { id } = connection;\n        debug(`Marking as 'alive' connection '${id}'`);\n        const index = this.dead.indexOf(id);\n        if (index > -1)\n            this.dead.splice(index, 1);\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        connection.deadCount = 0;\n        connection.resurrectTimeout = 0;\n        return this;\n    }\n    /**\n     * Marks a connection as 'dead'.\n     * If needed adds the connection to the dead list\n     * and then increments the `deadCount`.\n     *\n     * @param {object} connection\n     */\n    markDead(connection) {\n        const { id } = connection;\n        debug(`Marking as 'dead' connection '${id}'`);\n        if (!this.dead.includes(id)) {\n            // It might happen that `markDead` is called jsut after\n            // a pool update, and in such case we will add to the dead\n            // list a node that no longer exist. The following check verify\n            // that the connection is still part of the pool before\n            // marking it as dead.\n            for (let i = 0; i < this.size; i++) {\n                if (this.connections[i].id === id) {\n                    this.dead.push(id);\n                    break;\n                }\n            }\n        }\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        connection.deadCount++;\n        // resurrectTimeout formula:\n        // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n        connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));\n        // sort the dead list in ascending order\n        // based on the resurrectTimeout\n        this.dead.sort((a, b) => {\n            const conn1 = this.connections.find(c => c.id === a);\n            const conn2 = this.connections.find(c => c.id === b);\n            return conn1.resurrectTimeout - conn2.resurrectTimeout;\n        });\n        return this;\n    }\n    /**\n     * If enabled, tries to resurrect a connection with the given\n     * resurrect strategy ('ping', 'optimistic', 'none').\n     *\n     * @param {object} { now, requestId }\n     */\n    resurrect(opts) {\n        if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n            debug('Nothing to resurrect');\n            return;\n        }\n        // the dead list is sorted in ascending order based on the timeout\n        // so the first element will always be the one with the smaller timeout\n        const connection = this.connections.find(c => c.id === this.dead[0]);\n        if (opts.now < connection.resurrectTimeout) {\n            debug('Nothing to resurrect');\n            return;\n        }\n        const { id } = connection;\n        // ping strategy\n        if (this.resurrectStrategy === 1) {\n            connection.request({ method: 'HEAD', path: '/' }, { timeout: this.pingTimeout, requestId: opts.requestId, name: opts.name, context: opts.context })\n                .then(({ statusCode }) => {\n                let isAlive = true;\n                if (statusCode === 502 || statusCode === 503 || statusCode === 504) {\n                    debug(`Resurrect: connection '${id}' is still dead`);\n                    this.markDead(connection);\n                    isAlive = false;\n                }\n                else {\n                    debug(`Resurrect: connection '${id}' is now alive`);\n                    this.markAlive(connection);\n                }\n                this.diagnostic.emit('resurrect', null, {\n                    strategy: 'ping',\n                    name: opts.name,\n                    request: { id: opts.requestId },\n                    isAlive,\n                    connection\n                });\n            })\n                .catch((err) => {\n                this.markDead(connection);\n                this.diagnostic.emit('resurrect', err, {\n                    strategy: 'ping',\n                    name: opts.name,\n                    request: { id: opts.requestId },\n                    isAlive: false,\n                    connection\n                });\n            });\n            // optimistic strategy\n        }\n        else {\n            debug(`Resurrect: optimistic resurrection for connection '${id}'`);\n            this.dead.splice(this.dead.indexOf(id), 1);\n            connection.status = connection_1.BaseConnection.statuses.ALIVE;\n            this.diagnostic.emit('resurrect', null, {\n                strategy: 'optimistic',\n                name: opts.name,\n                request: { id: opts.requestId },\n                isAlive: true,\n                connection\n            });\n        }\n    }\n    /**\n     * Returns an alive connection if present,\n     * otherwise returns a dead connection.\n     * By default it filters the `master` only nodes.\n     * It uses the selector to choose which\n     * connection return.\n     *\n     * @param {object} options (filter and selector)\n     * @returns {object|null} connection\n     */\n    getConnection(opts) {\n        const filter = opts.filter != null ? opts.filter : () => true;\n        const selector = opts.selector != null ? opts.selector : (c) => c[0];\n        this.resurrect({\n            now: opts.now,\n            requestId: opts.requestId,\n            name: opts.name,\n            context: opts.context\n        });\n        const noAliveConnections = this.size === this.dead.length;\n        // TODO: can we cache this?\n        const connections = [];\n        for (let i = 0; i < this.size; i++) {\n            const connection = this.connections[i];\n            if (noAliveConnections || connection.status === connection_1.BaseConnection.statuses.ALIVE) {\n                if (filter(connection)) {\n                    connections.push(connection);\n                }\n            }\n        }\n        if (connections.length === 0)\n            return null;\n        return selector(connections);\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.dead = [];\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.dead = [];\n        return this;\n    }\n}\nObject.defineProperty(ClusterConnectionPool, \"resurrectStrategies\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        none: 0,\n        ping: 1,\n        optimistic: 2\n    }\n});\nexports[\"default\"] = ClusterConnectionPool;\n//# sourceMappingURL=ClusterConnectionPool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL0NsdXN0ZXJDb25uZWN0aW9uUG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHVEQUFPO0FBQy9CLHFEQUFxRCxtQkFBTyxDQUFDLG9HQUFzQjtBQUNuRiw4Q0FBOEMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNuRSx3Q0FBd0MsbUJBQU8sQ0FBQyxzREFBTztBQUN2RCxxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBZTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxrQkFBa0I7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnREFBZ0QsR0FBRztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckIsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBO0FBQ0EsaUNBQWlDLDJCQUEyQixJQUFJLDhGQUE4RjtBQUM5Six5QkFBeUIsWUFBWTtBQUNyQztBQUNBO0FBQ0Esb0RBQW9ELEdBQUc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsR0FBRztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxrQkFBZTtBQUNmIiwic291cmNlcyI6WyIvVXNlcnMvcmFpbnNmYWxsL0Rvd25sb2Fkcy9zZWFyY2gtZW5naW5lL3NlcnZpY2VzL3dlYi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL0NsdXN0ZXJDb25uZWN0aW9uUG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBMaWNlbnNlZCB0byBFbGFzdGljc2VhcmNoIEIuVi4gdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3JcbiAqIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoXG4gKiB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodFxuICogb3duZXJzaGlwLiBFbGFzdGljc2VhcmNoIEIuVi4gbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlclxuICogdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heVxuICogbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IEJhc2VDb25uZWN0aW9uUG9vbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQmFzZUNvbm5lY3Rpb25Qb29sXCIpKTtcbmNvbnN0IG5vZGVfYXNzZXJ0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibm9kZTphc3NlcnRcIikpO1xuY29uc3QgZGVidWdfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBjb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29ubmVjdGlvblwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ2VsYXN0aWNzZWFyY2gnKTtcbmNsYXNzIENsdXN0ZXJDb25uZWN0aW9uUG9vbCBleHRlbmRzIEJhc2VDb25uZWN0aW9uUG9vbF8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlYWRcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzdXJyZWN0VGltZW91dFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJyZXN1cnJlY3RUaW1lb3V0Q3V0b2ZmXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInBpbmdUaW1lb3V0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc3VycmVjdFN0cmF0ZWd5XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGVhZCA9IFtdO1xuICAgICAgICAvLyB0aGUgcmVzdXJyZWN0IHRpbWVvdXQgaXMgNjBzXG4gICAgICAgIHRoaXMucmVzdXJyZWN0VGltZW91dCA9IDEwMDAgKiA2MDtcbiAgICAgICAgLy8gbnVtYmVyIG9mIGNvbnNlY3V0aXZlIGZhaWx1cmVzIGFmdGVyIHdoaWNoXG4gICAgICAgIC8vIHRoZSB0aW1lb3V0IGRvZXNuJ3QgaW5jcmVhc2VcbiAgICAgICAgdGhpcy5yZXN1cnJlY3RUaW1lb3V0Q3V0b2ZmID0gNTtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dCA9IChfYSA9IG9wdHMucGluZ1RpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDMwMDA7XG4gICAgICAgIGNvbnN0IHJlc3VycmVjdFN0cmF0ZWd5ID0gKF9iID0gb3B0cy5yZXN1cnJlY3RTdHJhdGVneSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3BpbmcnO1xuICAgICAgICB0aGlzLnJlc3VycmVjdFN0cmF0ZWd5ID0gQ2x1c3RlckNvbm5lY3Rpb25Qb29sLnJlc3VycmVjdFN0cmF0ZWdpZXNbcmVzdXJyZWN0U3RyYXRlZ3ldO1xuICAgICAgICAoMCwgbm9kZV9hc3NlcnRfMS5kZWZhdWx0KSh0aGlzLnJlc3VycmVjdFN0cmF0ZWd5ICE9IG51bGwsIGBJbnZhbGlkIHJlc3VycmVjdGlvbiBzdHJhdGVneTogJyR7cmVzdXJyZWN0U3RyYXRlZ3l9J2ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIGNvbm5lY3Rpb24gYXMgJ2FsaXZlJy5cbiAgICAgKiBJZiBuZWVkZWQgcmVtb3ZlcyB0aGUgY29ubmVjdGlvbiBmcm9tIHRoZSBkZWFkIGxpc3RcbiAgICAgKiBhbmQgdGhlbiByZXNldHMgdGhlIGBkZWFkQ291bnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBtYXJrQWxpdmUoY29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCB7IGlkIH0gPSBjb25uZWN0aW9uO1xuICAgICAgICBkZWJ1ZyhgTWFya2luZyBhcyAnYWxpdmUnIGNvbm5lY3Rpb24gJyR7aWR9J2ApO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZGVhZC5pbmRleE9mKGlkKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICB0aGlzLmRlYWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMgPSBjb25uZWN0aW9uXzEuQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMuQUxJVkU7XG4gICAgICAgIGNvbm5lY3Rpb24uZGVhZENvdW50ID0gMDtcbiAgICAgICAgY29ubmVjdGlvbi5yZXN1cnJlY3RUaW1lb3V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIGEgY29ubmVjdGlvbiBhcyAnZGVhZCcuXG4gICAgICogSWYgbmVlZGVkIGFkZHMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIGRlYWQgbGlzdFxuICAgICAqIGFuZCB0aGVuIGluY3JlbWVudHMgdGhlIGBkZWFkQ291bnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBtYXJrRGVhZChjb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGNvbm5lY3Rpb247XG4gICAgICAgIGRlYnVnKGBNYXJraW5nIGFzICdkZWFkJyBjb25uZWN0aW9uICcke2lkfSdgKTtcbiAgICAgICAgaWYgKCF0aGlzLmRlYWQuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICAvLyBJdCBtaWdodCBoYXBwZW4gdGhhdCBgbWFya0RlYWRgIGlzIGNhbGxlZCBqc3V0IGFmdGVyXG4gICAgICAgICAgICAvLyBhIHBvb2wgdXBkYXRlLCBhbmQgaW4gc3VjaCBjYXNlIHdlIHdpbGwgYWRkIHRvIHRoZSBkZWFkXG4gICAgICAgICAgICAvLyBsaXN0IGEgbm9kZSB0aGF0IG5vIGxvbmdlciBleGlzdC4gVGhlIGZvbGxvd2luZyBjaGVjayB2ZXJpZnlcbiAgICAgICAgICAgIC8vIHRoYXQgdGhlIGNvbm5lY3Rpb24gaXMgc3RpbGwgcGFydCBvZiB0aGUgcG9vbCBiZWZvcmVcbiAgICAgICAgICAgIC8vIG1hcmtpbmcgaXQgYXMgZGVhZC5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uc1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWFkLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMgPSBjb25uZWN0aW9uXzEuQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMuREVBRDtcbiAgICAgICAgY29ubmVjdGlvbi5kZWFkQ291bnQrKztcbiAgICAgICAgLy8gcmVzdXJyZWN0VGltZW91dCBmb3JtdWxhOlxuICAgICAgICAvLyBgcmVzdXJyZWN0VGltZW91dCAqIDIgKiogbWluKGRlYWRDb3VudCAtIDEsIHJlc3VycmVjdFRpbWVvdXRDdXRvZmYpYFxuICAgICAgICBjb25uZWN0aW9uLnJlc3VycmVjdFRpbWVvdXQgPSBEYXRlLm5vdygpICsgdGhpcy5yZXN1cnJlY3RUaW1lb3V0ICogTWF0aC5wb3coMiwgTWF0aC5taW4oY29ubmVjdGlvbi5kZWFkQ291bnQgLSAxLCB0aGlzLnJlc3VycmVjdFRpbWVvdXRDdXRvZmYpKTtcbiAgICAgICAgLy8gc29ydCB0aGUgZGVhZCBsaXN0IGluIGFzY2VuZGluZyBvcmRlclxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgcmVzdXJyZWN0VGltZW91dFxuICAgICAgICB0aGlzLmRlYWQuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29ubjEgPSB0aGlzLmNvbm5lY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSBhKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm4yID0gdGhpcy5jb25uZWN0aW9ucy5maW5kKGMgPT4gYy5pZCA9PT0gYik7XG4gICAgICAgICAgICByZXR1cm4gY29ubjEucmVzdXJyZWN0VGltZW91dCAtIGNvbm4yLnJlc3VycmVjdFRpbWVvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgZW5hYmxlZCwgdHJpZXMgdG8gcmVzdXJyZWN0IGEgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlblxuICAgICAqIHJlc3VycmVjdCBzdHJhdGVneSAoJ3BpbmcnLCAnb3B0aW1pc3RpYycsICdub25lJykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geyBub3csIHJlcXVlc3RJZCB9XG4gICAgICovXG4gICAgcmVzdXJyZWN0KG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdXJyZWN0U3RyYXRlZ3kgPT09IDAgfHwgdGhpcy5kZWFkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZGVidWcoJ05vdGhpbmcgdG8gcmVzdXJyZWN0Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRlYWQgbGlzdCBpcyBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIGJhc2VkIG9uIHRoZSB0aW1lb3V0XG4gICAgICAgIC8vIHNvIHRoZSBmaXJzdCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIHRoZSBvbmUgd2l0aCB0aGUgc21hbGxlciB0aW1lb3V0XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb25zLmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmRlYWRbMF0pO1xuICAgICAgICBpZiAob3B0cy5ub3cgPCBjb25uZWN0aW9uLnJlc3VycmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGRlYnVnKCdOb3RoaW5nIHRvIHJlc3VycmVjdCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQgfSA9IGNvbm5lY3Rpb247XG4gICAgICAgIC8vIHBpbmcgc3RyYXRlZ3lcbiAgICAgICAgaWYgKHRoaXMucmVzdXJyZWN0U3RyYXRlZ3kgPT09IDEpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucmVxdWVzdCh7IG1ldGhvZDogJ0hFQUQnLCBwYXRoOiAnLycgfSwgeyB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0LCByZXF1ZXN0SWQ6IG9wdHMucmVxdWVzdElkLCBuYW1lOiBvcHRzLm5hbWUsIGNvbnRleHQ6IG9wdHMuY29udGV4dCB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCh7IHN0YXR1c0NvZGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpc0FsaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzQ29kZSA9PT0gNTAyIHx8IHN0YXR1c0NvZGUgPT09IDUwMyB8fCBzdGF0dXNDb2RlID09PSA1MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYFJlc3VycmVjdDogY29ubmVjdGlvbiAnJHtpZH0nIGlzIHN0aWxsIGRlYWRgKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXJrRGVhZChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaXNBbGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoYFJlc3VycmVjdDogY29ubmVjdGlvbiAnJHtpZH0nIGlzIG5vdyBhbGl2ZWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcmtBbGl2ZShjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaWFnbm9zdGljLmVtaXQoJ3Jlc3VycmVjdCcsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyYXRlZ3k6ICdwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB7IGlkOiBvcHRzLnJlcXVlc3RJZCB9LFxuICAgICAgICAgICAgICAgICAgICBpc0FsaXZlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrRGVhZChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpYWdub3N0aWMuZW1pdCgncmVzdXJyZWN0JywgZXJyLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAncGluZycsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9wdHMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBpZDogb3B0cy5yZXF1ZXN0SWQgfSxcbiAgICAgICAgICAgICAgICAgICAgaXNBbGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gb3B0aW1pc3RpYyBzdHJhdGVneVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoYFJlc3VycmVjdDogb3B0aW1pc3RpYyByZXN1cnJlY3Rpb24gZm9yIGNvbm5lY3Rpb24gJyR7aWR9J2ApO1xuICAgICAgICAgICAgdGhpcy5kZWFkLnNwbGljZSh0aGlzLmRlYWQuaW5kZXhPZihpZCksIDEpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5zdGF0dXMgPSBjb25uZWN0aW9uXzEuQmFzZUNvbm5lY3Rpb24uc3RhdHVzZXMuQUxJVkU7XG4gICAgICAgICAgICB0aGlzLmRpYWdub3N0aWMuZW1pdCgncmVzdXJyZWN0JywgbnVsbCwge1xuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnb3B0aW1pc3RpYycsXG4gICAgICAgICAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgaWQ6IG9wdHMucmVxdWVzdElkIH0sXG4gICAgICAgICAgICAgICAgaXNBbGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFsaXZlIGNvbm5lY3Rpb24gaWYgcHJlc2VudCxcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBhIGRlYWQgY29ubmVjdGlvbi5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGZpbHRlcnMgdGhlIGBtYXN0ZXJgIG9ubHkgbm9kZXMuXG4gICAgICogSXQgdXNlcyB0aGUgc2VsZWN0b3IgdG8gY2hvb3NlIHdoaWNoXG4gICAgICogY29ubmVjdGlvbiByZXR1cm4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAoZmlsdGVyIGFuZCBzZWxlY3RvcilcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fG51bGx9IGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBnZXRDb25uZWN0aW9uKG9wdHMpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyID0gb3B0cy5maWx0ZXIgIT0gbnVsbCA/IG9wdHMuZmlsdGVyIDogKCkgPT4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBvcHRzLnNlbGVjdG9yICE9IG51bGwgPyBvcHRzLnNlbGVjdG9yIDogKGMpID0+IGNbMF07XG4gICAgICAgIHRoaXMucmVzdXJyZWN0KHtcbiAgICAgICAgICAgIG5vdzogb3B0cy5ub3csXG4gICAgICAgICAgICByZXF1ZXN0SWQ6IG9wdHMucmVxdWVzdElkLFxuICAgICAgICAgICAgbmFtZTogb3B0cy5uYW1lLFxuICAgICAgICAgICAgY29udGV4dDogb3B0cy5jb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBub0FsaXZlQ29ubmVjdGlvbnMgPSB0aGlzLnNpemUgPT09IHRoaXMuZGVhZC5sZW5ndGg7XG4gICAgICAgIC8vIFRPRE86IGNhbiB3ZSBjYWNoZSB0aGlzP1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmIChub0FsaXZlQ29ubmVjdGlvbnMgfHwgY29ubmVjdGlvbi5zdGF0dXMgPT09IGNvbm5lY3Rpb25fMS5CYXNlQ29ubmVjdGlvbi5zdGF0dXNlcy5BTElWRSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbnMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IoY29ubmVjdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbXB0aWVzIHRoZSBjb25uZWN0aW9uIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvblBvb2x9XG4gICAgICovXG4gICAgYXN5bmMgZW1wdHkoKSB7XG4gICAgICAgIGF3YWl0IHN1cGVyLmVtcHR5KCk7XG4gICAgICAgIHRoaXMuZGVhZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIENvbm5lY3Rpb25Qb29sIHdpdGggbmV3IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyYXkgb2YgY29ubmVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvblBvb2x9XG4gICAgICovXG4gICAgdXBkYXRlKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShjb25uZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuZGVhZCA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2x1c3RlckNvbm5lY3Rpb25Qb29sLCBcInJlc3VycmVjdFN0cmF0ZWdpZXNcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7XG4gICAgICAgIG5vbmU6IDAsXG4gICAgICAgIHBpbmc6IDEsXG4gICAgICAgIG9wdGltaXN0aWM6IDJcbiAgICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IENsdXN0ZXJDb25uZWN0aW9uUG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNsdXN0ZXJDb25uZWN0aW9uUG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst connection_1 = __webpack_require__(/*! ../connection */ \"(rsc)/./node_modules/@elastic/transport/lib/connection/index.js\");\nconst BaseConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./BaseConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js\"));\nconst noFilter = () => true;\nclass WeightedConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxWeight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"greatestCommonDivisor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"currentWeight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // index choosen last time\n        this.index = -1;\n        // max weight of all nodes\n        this.maxWeight = 0;\n        // greatest common divisor of all nodes weights\n        this.greatestCommonDivisor = 0;\n        // current weight in scheduling\n        this.currentWeight = 0;\n    }\n    /**\n     * Returns a connection, even if the connection might be dead.\n     *\n     * @param {object} options (filter)\n     * @returns {object|null} connection\n     */\n    getConnection(opts) {\n        const filter = opts.filter != null ? opts.filter : noFilter;\n        // we should be able to find the next node in 1 array scan,\n        // if we don't, it means that we are in an infinite loop\n        let counter = 0;\n        while (counter++ < this.size) {\n            // 0 <= index < size\n            this.index = (this.index + 1) % this.size;\n            if (this.index === 0) {\n                this.currentWeight = this.currentWeight - this.greatestCommonDivisor;\n                if (this.currentWeight <= 0) {\n                    this.currentWeight = this.maxWeight;\n                    /* istanbul ignore if */\n                    if (this.currentWeight === 0) {\n                        return null;\n                    }\n                }\n            }\n            const connection = this.connections[this.index];\n            if (connection.weight >= this.currentWeight && filter(connection)) {\n                return connection;\n            }\n        }\n        return null;\n    }\n    /**\n     * Set the weight of a connection to the maximum value.\n     * If sniffing is not enabled and there is only\n     * one node, this method is a noop.\n     *\n     * @param {object} connection\n     */\n    markAlive(connection) {\n        if (this.size === 1 || connection.status === connection_1.BaseConnection.statuses.ALIVE)\n            return this;\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        connection.deadCount = 0;\n        connection.weight = Math.round(1000 / this.size);\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        return this;\n    }\n    /**\n     * Decreases the connection weight.\n     * If sniffing is not enabled and there is only\n     * one node, this method is a noop.\n     *\n     * @param {object} connection\n     */\n    markDead(connection) {\n        if (this.size === 1)\n            return this;\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        connection.deadCount++;\n        connection.weight -= Math.round(Math.pow(Math.log2(connection.weight), connection.deadCount));\n        /* istanbul ignore if */\n        if (connection.weight <= 0)\n            connection.weight = 1;\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        return this;\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.maxWeight = 0;\n        this.greatestCommonDivisor = 0;\n        this.index = -1;\n        this.currentWeight = 0;\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.connections.forEach(connection => {\n            connection.weight = Math.round(1000 / this.size);\n        });\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        this.index = -1;\n        this.currentWeight = 0;\n        return this;\n    }\n}\nexports[\"default\"] = WeightedConnectionPool;\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0)\n        return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\n//# sourceMappingURL=WeightedConnectionPool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL1dlaWdodGVkQ29ubmVjdGlvblBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1REFBTztBQUMvQixxQkFBcUIsbUJBQU8sQ0FBQyxzRkFBZTtBQUM1QyxxREFBcUQsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3JhaW5zZmFsbC9Eb3dubG9hZHMvc2VhcmNoLWVuZ2luZS9zZXJ2aWNlcy93ZWIvbm9kZV9tb2R1bGVzL0BlbGFzdGljL3RyYW5zcG9ydC9saWIvcG9vbC9XZWlnaHRlZENvbm5lY3Rpb25Qb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIExpY2Vuc2VkIHRvIEVsYXN0aWNzZWFyY2ggQi5WLiB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvclxuICogbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWUgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGhcbiAqIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0XG4gKiBvd25lcnNoaXAuIEVsYXN0aWNzZWFyY2ggQi5WLiBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyXG4gKiB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgY29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4uL2Nvbm5lY3Rpb25cIik7XG5jb25zdCBCYXNlQ29ubmVjdGlvblBvb2xfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VDb25uZWN0aW9uUG9vbFwiKSk7XG5jb25zdCBub0ZpbHRlciA9ICgpID0+IHRydWU7XG5jbGFzcyBXZWlnaHRlZENvbm5lY3Rpb25Qb29sIGV4dGVuZHMgQmFzZUNvbm5lY3Rpb25Qb29sXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaW5kZXhcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4V2VpZ2h0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdyZWF0ZXN0Q29tbW9uRGl2aXNvclwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjdXJyZW50V2VpZ2h0XCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluZGV4IGNob29zZW4gbGFzdCB0aW1lXG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgLy8gbWF4IHdlaWdodCBvZiBhbGwgbm9kZXNcbiAgICAgICAgdGhpcy5tYXhXZWlnaHQgPSAwO1xuICAgICAgICAvLyBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiBhbGwgbm9kZXMgd2VpZ2h0c1xuICAgICAgICB0aGlzLmdyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IDA7XG4gICAgICAgIC8vIGN1cnJlbnQgd2VpZ2h0IGluIHNjaGVkdWxpbmdcbiAgICAgICAgdGhpcy5jdXJyZW50V2VpZ2h0ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvbm5lY3Rpb24sIGV2ZW4gaWYgdGhlIGNvbm5lY3Rpb24gbWlnaHQgYmUgZGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIChmaWx0ZXIpXG4gICAgICogQHJldHVybnMge29iamVjdHxudWxsfSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGlvbihvcHRzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IG9wdHMuZmlsdGVyICE9IG51bGwgPyBvcHRzLmZpbHRlciA6IG5vRmlsdGVyO1xuICAgICAgICAvLyB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaW5kIHRoZSBuZXh0IG5vZGUgaW4gMSBhcnJheSBzY2FuLFxuICAgICAgICAvLyBpZiB3ZSBkb24ndCwgaXQgbWVhbnMgdGhhdCB3ZSBhcmUgaW4gYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIHdoaWxlIChjb3VudGVyKysgPCB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIC8vIDAgPD0gaW5kZXggPCBzaXplXG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gKHRoaXMuaW5kZXggKyAxKSAlIHRoaXMuc2l6ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50V2VpZ2h0ID0gdGhpcy5jdXJyZW50V2VpZ2h0IC0gdGhpcy5ncmVhdGVzdENvbW1vbkRpdmlzb3I7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFdlaWdodCA9IHRoaXMubWF4V2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFdlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uc1t0aGlzLmluZGV4XTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLndlaWdodCA+PSB0aGlzLmN1cnJlbnRXZWlnaHQgJiYgZmlsdGVyKGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgd2VpZ2h0IG9mIGEgY29ubmVjdGlvbiB0byB0aGUgbWF4aW11bSB2YWx1ZS5cbiAgICAgKiBJZiBzbmlmZmluZyBpcyBub3QgZW5hYmxlZCBhbmQgdGhlcmUgaXMgb25seVxuICAgICAqIG9uZSBub2RlLCB0aGlzIG1ldGhvZCBpcyBhIG5vb3AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29ubmVjdGlvblxuICAgICAqL1xuICAgIG1hcmtBbGl2ZShjb25uZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPT09IDEgfHwgY29ubmVjdGlvbi5zdGF0dXMgPT09IGNvbm5lY3Rpb25fMS5CYXNlQ29ubmVjdGlvbi5zdGF0dXNlcy5BTElWRSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25uZWN0aW9uLnN0YXR1cyA9IGNvbm5lY3Rpb25fMS5CYXNlQ29ubmVjdGlvbi5zdGF0dXNlcy5BTElWRTtcbiAgICAgICAgY29ubmVjdGlvbi5kZWFkQ291bnQgPSAwO1xuICAgICAgICBjb25uZWN0aW9uLndlaWdodCA9IE1hdGgucm91bmQoMTAwMCAvIHRoaXMuc2l6ZSk7XG4gICAgICAgIHRoaXMubWF4V2VpZ2h0ID0gTWF0aC5tYXgoLi4uKHRoaXMuY29ubmVjdGlvbnMubWFwKGMgPT4gYy53ZWlnaHQpKSk7XG4gICAgICAgIHRoaXMuZ3JlYXRlc3RDb21tb25EaXZpc29yID0gdGhpcy5jb25uZWN0aW9ucy5tYXAoYyA9PiBjLndlaWdodCkucmVkdWNlKGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNyZWFzZXMgdGhlIGNvbm5lY3Rpb24gd2VpZ2h0LlxuICAgICAqIElmIHNuaWZmaW5nIGlzIG5vdCBlbmFibGVkIGFuZCB0aGVyZSBpcyBvbmx5XG4gICAgICogb25lIG5vZGUsIHRoaXMgbWV0aG9kIGlzIGEgbm9vcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgbWFya0RlYWQoY29ubmVjdGlvbikge1xuICAgICAgICBpZiAodGhpcy5zaXplID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbm5lY3Rpb24uc3RhdHVzID0gY29ubmVjdGlvbl8xLkJhc2VDb25uZWN0aW9uLnN0YXR1c2VzLkRFQUQ7XG4gICAgICAgIGNvbm5lY3Rpb24uZGVhZENvdW50Kys7XG4gICAgICAgIGNvbm5lY3Rpb24ud2VpZ2h0IC09IE1hdGgucm91bmQoTWF0aC5wb3coTWF0aC5sb2cyKGNvbm5lY3Rpb24ud2VpZ2h0KSwgY29ubmVjdGlvbi5kZWFkQ291bnQpKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChjb25uZWN0aW9uLndlaWdodCA8PSAwKVxuICAgICAgICAgICAgY29ubmVjdGlvbi53ZWlnaHQgPSAxO1xuICAgICAgICB0aGlzLm1heFdlaWdodCA9IE1hdGgubWF4KC4uLih0aGlzLmNvbm5lY3Rpb25zLm1hcChjID0+IGMud2VpZ2h0KSkpO1xuICAgICAgICB0aGlzLmdyZWF0ZXN0Q29tbW9uRGl2aXNvciA9IHRoaXMuY29ubmVjdGlvbnMubWFwKGMgPT4gYy53ZWlnaHQpLnJlZHVjZShnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IsIDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1wdGllcyB0aGUgY29ubmVjdGlvbiBwb29sLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0Nvbm5lY3Rpb25Qb29sfVxuICAgICAqL1xuICAgIGFzeW5jIGVtcHR5KCkge1xuICAgICAgICBhd2FpdCBzdXBlci5lbXB0eSgpO1xuICAgICAgICB0aGlzLm1heFdlaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZ3JlYXRlc3RDb21tb25EaXZpc29yID0gMDtcbiAgICAgICAgdGhpcy5pbmRleCA9IC0xO1xuICAgICAgICB0aGlzLmN1cnJlbnRXZWlnaHQgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIENvbm5lY3Rpb25Qb29sIHdpdGggbmV3IGNvbm5lY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthcnJheX0gYXJyYXkgb2YgY29ubmVjdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvblBvb2x9XG4gICAgICovXG4gICAgdXBkYXRlKGNvbm5lY3Rpb25zKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZShjb25uZWN0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbnMuZm9yRWFjaChjb25uZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ud2VpZ2h0ID0gTWF0aC5yb3VuZCgxMDAwIC8gdGhpcy5zaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWF4V2VpZ2h0ID0gTWF0aC5tYXgoLi4uKHRoaXMuY29ubmVjdGlvbnMubWFwKGMgPT4gYy53ZWlnaHQpKSk7XG4gICAgICAgIHRoaXMuZ3JlYXRlc3RDb21tb25EaXZpc29yID0gdGhpcy5jb25uZWN0aW9ucy5tYXAoYyA9PiBjLndlaWdodCkucmVkdWNlKGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvciwgMCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5jdXJyZW50V2VpZ2h0ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gV2VpZ2h0ZWRDb25uZWN0aW9uUG9vbDtcbmZ1bmN0aW9uIGdldEdyZWF0ZXN0Q29tbW9uRGl2aXNvcihhLCBiKSB7XG4gICAgaWYgKGIgPT09IDApXG4gICAgICAgIHJldHVybiBhO1xuICAgIHJldHVybiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IoYiwgYSAlIGIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2VpZ2h0ZWRDb25uZWN0aW9uUG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/pool/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/pool/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the 'License'); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CloudConnectionPool = exports.ClusterConnectionPool = exports.WeightedConnectionPool = exports.BaseConnectionPool = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(rsc)/./node_modules/tslib/tslib.es6.mjs\");\nconst BaseConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./BaseConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js\"));\nexports.BaseConnectionPool = BaseConnectionPool_1.default;\nconst WeightedConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./WeightedConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js\"));\nexports.WeightedConnectionPool = WeightedConnectionPool_1.default;\nconst ClusterConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./ClusterConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js\"));\nexports.ClusterConnectionPool = ClusterConnectionPool_1.default;\nconst CloudConnectionPool_1 = tslib_1.__importDefault(__webpack_require__(/*! ./CloudConnectionPool */ \"(rsc)/./node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js\"));\nexports.CloudConnectionPool = CloudConnectionPool_1.default;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9wb29sL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCO0FBQ3pILGdCQUFnQixtQkFBTyxDQUFDLHVEQUFPO0FBQy9CLHFEQUFxRCxtQkFBTyxDQUFDLG9HQUFzQjtBQUNuRiwwQkFBMEI7QUFDMUIseURBQXlELG1CQUFPLENBQUMsNEdBQTBCO0FBQzNGLDhCQUE4QjtBQUM5Qix3REFBd0QsbUJBQU8sQ0FBQywwR0FBeUI7QUFDekYsNkJBQTZCO0FBQzdCLHNEQUFzRCxtQkFBTyxDQUFDLHNHQUF1QjtBQUNyRiwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL3Bvb2wvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSAnTGljZW5zZScpOyB5b3UgbWF5XG4gKiBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqICdBUyBJUycgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbG91ZENvbm5lY3Rpb25Qb29sID0gZXhwb3J0cy5DbHVzdGVyQ29ubmVjdGlvblBvb2wgPSBleHBvcnRzLldlaWdodGVkQ29ubmVjdGlvblBvb2wgPSBleHBvcnRzLkJhc2VDb25uZWN0aW9uUG9vbCA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG5jb25zdCBCYXNlQ29ubmVjdGlvblBvb2xfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL0Jhc2VDb25uZWN0aW9uUG9vbFwiKSk7XG5leHBvcnRzLkJhc2VDb25uZWN0aW9uUG9vbCA9IEJhc2VDb25uZWN0aW9uUG9vbF8xLmRlZmF1bHQ7XG5jb25zdCBXZWlnaHRlZENvbm5lY3Rpb25Qb29sXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9XZWlnaHRlZENvbm5lY3Rpb25Qb29sXCIpKTtcbmV4cG9ydHMuV2VpZ2h0ZWRDb25uZWN0aW9uUG9vbCA9IFdlaWdodGVkQ29ubmVjdGlvblBvb2xfMS5kZWZhdWx0O1xuY29uc3QgQ2x1c3RlckNvbm5lY3Rpb25Qb29sXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9DbHVzdGVyQ29ubmVjdGlvblBvb2xcIikpO1xuZXhwb3J0cy5DbHVzdGVyQ29ubmVjdGlvblBvb2wgPSBDbHVzdGVyQ29ubmVjdGlvblBvb2xfMS5kZWZhdWx0O1xuY29uc3QgQ2xvdWRDb25uZWN0aW9uUG9vbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vQ2xvdWRDb25uZWN0aW9uUG9vbFwiKSk7XG5leHBvcnRzLkNsb3VkQ29ubmVjdGlvblBvb2wgPSBDbG91ZENvbm5lY3Rpb25Qb29sXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/pool/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/security.js":
/*!*********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/security.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.redactObject = redactObject;\nexports.redactDiagnostic = redactDiagnostic;\nconst secretKeys = [\n    'authorization',\n    'password',\n    'apikey',\n    'x-elastic-app-auth'\n];\n/**\n * Clones an object and recursively loops through all keys, redacting their values if the key matches any of a list of strings.\n * @param obj: Object to clone and redact\n * @param additionalKeys: Extra keys that can be matched for redaction. Does not overwrite the default set.\n */\nfunction redactObject(obj, additionalKeys = []) {\n    const toRedact = [...secretKeys, ...additionalKeys].map(key => key.toLowerCase());\n    // `seen` stores each Object it sees, so we can prevent infinite recursion due to circular references\n    const seen = new Map();\n    return doRedact(obj);\n    function doRedact(obj) {\n        if (typeof obj !== 'object' || obj == null)\n            return obj;\n        const newObj = {};\n        Object.entries(obj).forEach(([key, value]) => {\n            // pull auth info out of URL objects\n            if (value instanceof URL) {\n                value = `${value.origin}${value.pathname}${value.search}`;\n            }\n            else if (typeof value === 'object' && value !== null) {\n                if (Array.isArray(value)) {\n                    // if it's an array, redact each item\n                    value = value.map(v => doRedact(v));\n                }\n                else {\n                    if (seen.get(value) !== true) {\n                        // if this Object hasn't been seen, recursively redact it\n                        seen.set(value, true);\n                        value = doRedact(value);\n                    }\n                    else {\n                        // if it has been seen, set the value that goes in newObj to null\n                        // this is what prevents the circular references\n                        value = null;\n                    }\n                }\n            }\n            // check if redaction is needed for this key\n            if (toRedact.includes(key.toLowerCase())) {\n                newObj[key] = '[redacted]';\n            }\n            else {\n                newObj[key] = value;\n            }\n        });\n        return newObj;\n    }\n}\n/**\n * Redacts a DiagnosticResult object using the provided options.\n * - 'off' does nothing\n * - 'remove' removes most optional properties, replaces non-optional properties with the simplest possible alternative\n * - 'replace' runs `redactObject`, which replaces secret keys with `[redacted]`\n */\nfunction redactDiagnostic(diag, options) {\n    var _a;\n    switch (options.type) {\n        case 'off':\n            break;\n        case 'remove':\n            delete diag.headers;\n            delete diag.meta.sniff;\n            delete diag.meta.request.params.headers;\n            diag.meta.request.options = {};\n            diag.meta.connection = null;\n            break;\n        case 'replace':\n            diag = redactObject(diag, (_a = options.additionalKeys) !== null && _a !== void 0 ? _a : []);\n            break;\n    }\n    return diag;\n}\n//# sourceMappingURL=security.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9zZWN1cml0eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYSxFQUFFLGVBQWUsRUFBRSxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL3NlY3VyaXR5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWRhY3RPYmplY3QgPSByZWRhY3RPYmplY3Q7XG5leHBvcnRzLnJlZGFjdERpYWdub3N0aWMgPSByZWRhY3REaWFnbm9zdGljO1xuY29uc3Qgc2VjcmV0S2V5cyA9IFtcbiAgICAnYXV0aG9yaXphdGlvbicsXG4gICAgJ3Bhc3N3b3JkJyxcbiAgICAnYXBpa2V5JyxcbiAgICAneC1lbGFzdGljLWFwcC1hdXRoJ1xuXTtcbi8qKlxuICogQ2xvbmVzIGFuIG9iamVjdCBhbmQgcmVjdXJzaXZlbHkgbG9vcHMgdGhyb3VnaCBhbGwga2V5cywgcmVkYWN0aW5nIHRoZWlyIHZhbHVlcyBpZiB0aGUga2V5IG1hdGNoZXMgYW55IG9mIGEgbGlzdCBvZiBzdHJpbmdzLlxuICogQHBhcmFtIG9iajogT2JqZWN0IHRvIGNsb25lIGFuZCByZWRhY3RcbiAqIEBwYXJhbSBhZGRpdGlvbmFsS2V5czogRXh0cmEga2V5cyB0aGF0IGNhbiBiZSBtYXRjaGVkIGZvciByZWRhY3Rpb24uIERvZXMgbm90IG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBzZXQuXG4gKi9cbmZ1bmN0aW9uIHJlZGFjdE9iamVjdChvYmosIGFkZGl0aW9uYWxLZXlzID0gW10pIHtcbiAgICBjb25zdCB0b1JlZGFjdCA9IFsuLi5zZWNyZXRLZXlzLCAuLi5hZGRpdGlvbmFsS2V5c10ubWFwKGtleSA9PiBrZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgLy8gYHNlZW5gIHN0b3JlcyBlYWNoIE9iamVjdCBpdCBzZWVzLCBzbyB3ZSBjYW4gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb24gZHVlIHRvIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBjb25zdCBzZWVuID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBkb1JlZGFjdChvYmopO1xuICAgIGZ1bmN0aW9uIGRvUmVkYWN0KG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7fTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMob2JqKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIC8vIHB1bGwgYXV0aCBpbmZvIG91dCBvZiBVUkwgb2JqZWN0c1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBgJHt2YWx1ZS5vcmlnaW59JHt2YWx1ZS5wYXRobmFtZX0ke3ZhbHVlLnNlYXJjaH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIGFuIGFycmF5LCByZWRhY3QgZWFjaCBpdGVtXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUubWFwKHYgPT4gZG9SZWRhY3QodikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZW4uZ2V0KHZhbHVlKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBPYmplY3QgaGFzbid0IGJlZW4gc2VlbiwgcmVjdXJzaXZlbHkgcmVkYWN0IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWVuLnNldCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGRvUmVkYWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBiZWVuIHNlZW4sIHNldCB0aGUgdmFsdWUgdGhhdCBnb2VzIGluIG5ld09iaiB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHdoYXQgcHJldmVudHMgdGhlIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHJlZGFjdGlvbiBpcyBuZWVkZWQgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICBpZiAodG9SZWRhY3QuaW5jbHVkZXMoa2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2tleV0gPSAnW3JlZGFjdGVkXSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld09iajtcbiAgICB9XG59XG4vKipcbiAqIFJlZGFjdHMgYSBEaWFnbm9zdGljUmVzdWx0IG9iamVjdCB1c2luZyB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAqIC0gJ29mZicgZG9lcyBub3RoaW5nXG4gKiAtICdyZW1vdmUnIHJlbW92ZXMgbW9zdCBvcHRpb25hbCBwcm9wZXJ0aWVzLCByZXBsYWNlcyBub24tb3B0aW9uYWwgcHJvcGVydGllcyB3aXRoIHRoZSBzaW1wbGVzdCBwb3NzaWJsZSBhbHRlcm5hdGl2ZVxuICogLSAncmVwbGFjZScgcnVucyBgcmVkYWN0T2JqZWN0YCwgd2hpY2ggcmVwbGFjZXMgc2VjcmV0IGtleXMgd2l0aCBgW3JlZGFjdGVkXWBcbiAqL1xuZnVuY3Rpb24gcmVkYWN0RGlhZ25vc3RpYyhkaWFnLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ29mZic6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgICAgIGRlbGV0ZSBkaWFnLmhlYWRlcnM7XG4gICAgICAgICAgICBkZWxldGUgZGlhZy5tZXRhLnNuaWZmO1xuICAgICAgICAgICAgZGVsZXRlIGRpYWcubWV0YS5yZXF1ZXN0LnBhcmFtcy5oZWFkZXJzO1xuICAgICAgICAgICAgZGlhZy5tZXRhLnJlcXVlc3Qub3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgZGlhZy5tZXRhLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgZGlhZyA9IHJlZGFjdE9iamVjdChkaWFnLCAoX2EgPSBvcHRpb25zLmFkZGl0aW9uYWxLZXlzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGRpYWc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWN1cml0eS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/security.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/lib/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/@elastic/transport/lib/symbols.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.kOtelTracer = exports.kRetryBackoff = exports.kRedaction = exports.kAcceptHeader = exports.kNdjsonContentType = exports.kJsonContentType = exports.kMaxCompressedResponseSize = exports.kMaxResponseSize = exports.kCaFingerprint = exports.kProductCheck = exports.kStatus = exports.kJsonOptions = exports.kNodeSelector = exports.kNodeFilter = exports.kHeaders = exports.kDiagnostic = exports.kSerializer = exports.kConnectionPool = exports.kContext = exports.kGenerateRequestId = exports.kOpaqueIdPrefix = exports.kName = exports.kMaxRetries = exports.kCompression = exports.kRetryOnTimeout = exports.kRequestTimeout = exports.kSniffEndpoint = exports.kSniffOnConnectionFault = exports.kSniffInterval = exports.kIsSniffing = exports.kNextSniff = exports.kSniffEnabled = void 0;\nexports.kSniffEnabled = Symbol('sniff enabled');\nexports.kNextSniff = Symbol('next sniff');\nexports.kIsSniffing = Symbol('is sniffing');\nexports.kSniffInterval = Symbol('sniff interval');\nexports.kSniffOnConnectionFault = Symbol('sniff on connection fault');\nexports.kSniffEndpoint = Symbol('sniff endpoint');\nexports.kRequestTimeout = Symbol('request timeout');\nexports.kRetryOnTimeout = Symbol('retry on timeout');\nexports.kCompression = Symbol('compression');\nexports.kMaxRetries = Symbol('max retries');\nexports.kName = Symbol('name');\nexports.kOpaqueIdPrefix = Symbol('opaque id prefix');\nexports.kGenerateRequestId = Symbol('generate request id');\nexports.kContext = Symbol('context');\nexports.kConnectionPool = Symbol('connection pool');\nexports.kSerializer = Symbol('serializer');\nexports.kDiagnostic = Symbol('diagnostics');\nexports.kHeaders = Symbol('headers');\nexports.kNodeFilter = Symbol('node filter');\nexports.kNodeSelector = Symbol('node selector');\nexports.kJsonOptions = Symbol('secure json parse options');\nexports.kStatus = Symbol('status');\nexports.kProductCheck = Symbol('product check');\nexports.kCaFingerprint = Symbol('ca fingerprint');\nexports.kMaxResponseSize = Symbol('max response size');\nexports.kMaxCompressedResponseSize = Symbol('max compressed response size');\nexports.kJsonContentType = Symbol('json content type');\nexports.kNdjsonContentType = Symbol('ndjson content type');\nexports.kAcceptHeader = Symbol('accept header');\nexports.kRedaction = Symbol('redaction');\nexports.kRetryBackoff = Symbol('retry backoff');\nexports.kOtelTracer = Symbol('opentelemetry tracer');\n//# sourceMappingURL=symbols.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGVsYXN0aWMvdHJhbnNwb3J0L2xpYi9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsa0NBQWtDLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLGdCQUFnQixHQUFHLDBCQUEwQixHQUFHLHVCQUF1QixHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyx1QkFBdUIsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRywrQkFBK0IsR0FBRyxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUI7QUFDbndCLHFCQUFxQjtBQUNyQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QiwrQkFBK0I7QUFDL0Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixnQkFBZ0I7QUFDaEIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLGVBQWU7QUFDZixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixrQ0FBa0M7QUFDbEMsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9yYWluc2ZhbGwvRG93bmxvYWRzL3NlYXJjaC1lbmdpbmUvc2VydmljZXMvd2ViL25vZGVfbW9kdWxlcy9AZWxhc3RpYy90cmFuc3BvcnQvbGliL3N5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogTGljZW5zZWQgdG8gRWxhc3RpY3NlYXJjaCBCLlYuIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yXG4gKiBsaWNlbnNlIGFncmVlbWVudHMuIFNlZSB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aFxuICogdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHRcbiAqIG93bmVyc2hpcC4gRWxhc3RpY3NlYXJjaCBCLlYuIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXJcbiAqIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXlcbiAqIG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4gKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuICogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiAqIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuICogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuICogdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua090ZWxUcmFjZXIgPSBleHBvcnRzLmtSZXRyeUJhY2tvZmYgPSBleHBvcnRzLmtSZWRhY3Rpb24gPSBleHBvcnRzLmtBY2NlcHRIZWFkZXIgPSBleHBvcnRzLmtOZGpzb25Db250ZW50VHlwZSA9IGV4cG9ydHMua0pzb25Db250ZW50VHlwZSA9IGV4cG9ydHMua01heENvbXByZXNzZWRSZXNwb25zZVNpemUgPSBleHBvcnRzLmtNYXhSZXNwb25zZVNpemUgPSBleHBvcnRzLmtDYUZpbmdlcnByaW50ID0gZXhwb3J0cy5rUHJvZHVjdENoZWNrID0gZXhwb3J0cy5rU3RhdHVzID0gZXhwb3J0cy5rSnNvbk9wdGlvbnMgPSBleHBvcnRzLmtOb2RlU2VsZWN0b3IgPSBleHBvcnRzLmtOb2RlRmlsdGVyID0gZXhwb3J0cy5rSGVhZGVycyA9IGV4cG9ydHMua0RpYWdub3N0aWMgPSBleHBvcnRzLmtTZXJpYWxpemVyID0gZXhwb3J0cy5rQ29ubmVjdGlvblBvb2wgPSBleHBvcnRzLmtDb250ZXh0ID0gZXhwb3J0cy5rR2VuZXJhdGVSZXF1ZXN0SWQgPSBleHBvcnRzLmtPcGFxdWVJZFByZWZpeCA9IGV4cG9ydHMua05hbWUgPSBleHBvcnRzLmtNYXhSZXRyaWVzID0gZXhwb3J0cy5rQ29tcHJlc3Npb24gPSBleHBvcnRzLmtSZXRyeU9uVGltZW91dCA9IGV4cG9ydHMua1JlcXVlc3RUaW1lb3V0ID0gZXhwb3J0cy5rU25pZmZFbmRwb2ludCA9IGV4cG9ydHMua1NuaWZmT25Db25uZWN0aW9uRmF1bHQgPSBleHBvcnRzLmtTbmlmZkludGVydmFsID0gZXhwb3J0cy5rSXNTbmlmZmluZyA9IGV4cG9ydHMua05leHRTbmlmZiA9IGV4cG9ydHMua1NuaWZmRW5hYmxlZCA9IHZvaWQgMDtcbmV4cG9ydHMua1NuaWZmRW5hYmxlZCA9IFN5bWJvbCgnc25pZmYgZW5hYmxlZCcpO1xuZXhwb3J0cy5rTmV4dFNuaWZmID0gU3ltYm9sKCduZXh0IHNuaWZmJyk7XG5leHBvcnRzLmtJc1NuaWZmaW5nID0gU3ltYm9sKCdpcyBzbmlmZmluZycpO1xuZXhwb3J0cy5rU25pZmZJbnRlcnZhbCA9IFN5bWJvbCgnc25pZmYgaW50ZXJ2YWwnKTtcbmV4cG9ydHMua1NuaWZmT25Db25uZWN0aW9uRmF1bHQgPSBTeW1ib2woJ3NuaWZmIG9uIGNvbm5lY3Rpb24gZmF1bHQnKTtcbmV4cG9ydHMua1NuaWZmRW5kcG9pbnQgPSBTeW1ib2woJ3NuaWZmIGVuZHBvaW50Jyk7XG5leHBvcnRzLmtSZXF1ZXN0VGltZW91dCA9IFN5bWJvbCgncmVxdWVzdCB0aW1lb3V0Jyk7XG5leHBvcnRzLmtSZXRyeU9uVGltZW91dCA9IFN5bWJvbCgncmV0cnkgb24gdGltZW91dCcpO1xuZXhwb3J0cy5rQ29tcHJlc3Npb24gPSBTeW1ib2woJ2NvbXByZXNzaW9uJyk7XG5leHBvcnRzLmtNYXhSZXRyaWVzID0gU3ltYm9sKCdtYXggcmV0cmllcycpO1xuZXhwb3J0cy5rTmFtZSA9IFN5bWJvbCgnbmFtZScpO1xuZXhwb3J0cy5rT3BhcXVlSWRQcmVmaXggPSBTeW1ib2woJ29wYXF1ZSBpZCBwcmVmaXgnKTtcbmV4cG9ydHMua0dlbmVyYXRlUmVxdWVzdElkID0gU3ltYm9sKCdnZW5lcmF0ZSByZXF1ZXN0IGlkJyk7XG5leHBvcnRzLmtDb250ZXh0ID0gU3ltYm9sKCdjb250ZXh0Jyk7XG5leHBvcnRzLmtDb25uZWN0aW9uUG9vbCA9IFN5bWJvbCgnY29ubmVjdGlvbiBwb29sJyk7XG5leHBvcnRzLmtTZXJpYWxpemVyID0gU3ltYm9sKCdzZXJpYWxpemVyJyk7XG5leHBvcnRzLmtEaWFnbm9zdGljID0gU3ltYm9sKCdkaWFnbm9zdGljcycpO1xuZXhwb3J0cy5rSGVhZGVycyA9IFN5bWJvbCgnaGVhZGVycycpO1xuZXhwb3J0cy5rTm9kZUZpbHRlciA9IFN5bWJvbCgnbm9kZSBmaWx0ZXInKTtcbmV4cG9ydHMua05vZGVTZWxlY3RvciA9IFN5bWJvbCgnbm9kZSBzZWxlY3RvcicpO1xuZXhwb3J0cy5rSnNvbk9wdGlvbnMgPSBTeW1ib2woJ3NlY3VyZSBqc29uIHBhcnNlIG9wdGlvbnMnKTtcbmV4cG9ydHMua1N0YXR1cyA9IFN5bWJvbCgnc3RhdHVzJyk7XG5leHBvcnRzLmtQcm9kdWN0Q2hlY2sgPSBTeW1ib2woJ3Byb2R1Y3QgY2hlY2snKTtcbmV4cG9ydHMua0NhRmluZ2VycHJpbnQgPSBTeW1ib2woJ2NhIGZpbmdlcnByaW50Jyk7XG5leHBvcnRzLmtNYXhSZXNwb25zZVNpemUgPSBTeW1ib2woJ21heCByZXNwb25zZSBzaXplJyk7XG5leHBvcnRzLmtNYXhDb21wcmVzc2VkUmVzcG9uc2VTaXplID0gU3ltYm9sKCdtYXggY29tcHJlc3NlZCByZXNwb25zZSBzaXplJyk7XG5leHBvcnRzLmtKc29uQ29udGVudFR5cGUgPSBTeW1ib2woJ2pzb24gY29udGVudCB0eXBlJyk7XG5leHBvcnRzLmtOZGpzb25Db250ZW50VHlwZSA9IFN5bWJvbCgnbmRqc29uIGNvbnRlbnQgdHlwZScpO1xuZXhwb3J0cy5rQWNjZXB0SGVhZGVyID0gU3ltYm9sKCdhY2NlcHQgaGVhZGVyJyk7XG5leHBvcnRzLmtSZWRhY3Rpb24gPSBTeW1ib2woJ3JlZGFjdGlvbicpO1xuZXhwb3J0cy5rUmV0cnlCYWNrb2ZmID0gU3ltYm9sKCdyZXRyeSBiYWNrb2ZmJyk7XG5leHBvcnRzLmtPdGVsVHJhY2VyID0gU3ltYm9sKCdvcGVudGVsZW1ldHJ5IHRyYWNlcicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ltYm9scy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@elastic/transport/lib/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/elasticsearch/package.json":
/*!**********************************************************!*\
  !*** ./node_modules/@elastic/elasticsearch/package.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@elastic/elasticsearch","version":"8.16.2","versionCanary":"8.16.2-canary.0","description":"The official Elasticsearch client for Node.js","main":"./index.js","types":"index.d.ts","exports":{"require":"./index.js","import":"./index.js","types":"./index.d.ts"},"scripts":{"test":"npm run build && npm run lint && tap","test:unit":"npm run build && tap","test:unit-bun":"bun run build && bunx tap","test:esm":"npm run build && cd test/esm/ && npm install && node test-import.mjs","test:coverage-100":"npm run build && tap --coverage --100","test:coverage-report":"npm run build && tap --coverage && nyc report --reporter=text-lcov > coverage.lcov","test:coverage-ui":"npm run build && tap --coverage --coverage-report=html","test:integration":"tsc && node test/integration/index.js","lint":"ts-standard src","lint:fix":"ts-standard --fix src","license-checker":"license-checker --production --onlyAllow=\'MIT;Apache-2.0;Apache1.1;ISC;BSD-3-Clause;BSD-2-Clause;0BSD\'","prebuild":"npm run clean-build && npm run lint","build":"tsc && rm lib/package.json && mv lib/src/* lib/ && rm -rf lib/src","clean-build":"rimraf ./lib && mkdir lib","prepublishOnly":"npm run build"},"keywords":["elasticsearch","elastic","kibana","mapping","REST","search","client","index"],"contributors":[{"name":"Elastic Client Library Maintainers","company":"Elastic BV"}],"license":"Apache-2.0","repository":{"type":"git","url":"https://github.com/elastic/elasticsearch-js.git"},"bugs":{"url":"https://github.com/elastic/elasticsearch-js/issues"},"homepage":"http://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html","engines":{"node":">=18"},"devDependencies":{"@elastic/request-converter":"^8.16.1","@sinonjs/fake-timers":"github:sinonjs/fake-timers#0bfffc1","@types/debug":"^4.1.7","@types/ms":"^0.7.31","@types/node":"^18.19.55","@types/sinonjs__fake-timers":"^8.1.2","@types/split2":"^3.2.1","@types/stoppable":"^1.1.1","@types/tap":"^15.0.7","chai":"^4.3.7","cross-zip":"^4.0.0","desm":"^1.2.0","into-stream":"^7.0.0","js-yaml":"^4.1.0","license-checker":"^25.0.1","minimist":"^1.2.6","ms":"^2.1.3","node-abort-controller":"^3.0.1","node-fetch":"^2.6.7","ora":"^5.4.1","proxy":"^1.0.2","rimraf":"^3.0.2","semver":"^7.3.7","split2":"^4.1.0","stoppable":"^1.1.0","tap":"^21.0.1","ts-node":"^10.7.0","ts-standard":"^12.0.2","typescript":"^4.6.4","workq":"^3.0.0","xmlbuilder2":"^3.0.2","zx":"^7.2.2"},"dependencies":{"@elastic/transport":"^8.9.1","apache-arrow":"^18.0.0","tslib":"^2.4.0"},"tap":{"disable-coverage":true,"files":["test/unit/{*,**/*}.test.ts"]}}');

/***/ }),

/***/ "(rsc)/./node_modules/@elastic/transport/package.json":
/*!******************************************************!*\
  !*** ./node_modules/@elastic/transport/package.json ***!
  \******************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@elastic/transport","version":"8.9.1","description":"Transport classes and utilities shared among Node.js Elastic client libraries","main":"./index.js","types":"index.d.ts","exports":{".":"./index.js","./package.json":"./package.json","./connection/BaseConnection":"./lib/connection/BaseConnection.js","./lib/connection/BaseConnection":"./lib/connection/BaseConnection.js","./pool/BaseConnectionPool":"./lib/pool/BaseConnectionPool.js","./lib/pool/BaseConnectionPool":"./lib/pool/BaseConnectionPool.js","./pool/CloudConnectionPool":"./lib/pool/CloudConnectionPool.js","./lib/pool/CloudConnectionPool":"./lib/pool/CloudConnectionPool.js","./pool/ClusterConnectionPool":"./lib/pool/ClusterConnectionPool.js","./lib/pool/ClusterConnectionPool":"./lib/pool/ClusterConnectionPool.js","./Diagnostic":"./lib/Diagnostic.js","./lib/Diagnostic":"./lib/Diagnostic.js","./errors":"./lib/errors.js","./lib/errors":"./lib/errors.js","./connection/HttpConnection":"./lib/connection/HttpConnection.js","./lib/connection/HttpConnection":"./lib/connection/HttpConnection.js","./connection":"./lib/connection/index.js","./lib/connection":"./lib/connection/index.js","./pool":"./lib/pool/index.js","./lib/pool":"./lib/pool/index.js","./security":"./lib/security.js","./lib/security":"./lib/security.js","./Serializer":"./lib/Serializer.js","./lib/Serializer":"./lib/Serializer.js","./symbols":"./lib/symbols.js","./lib/symbols":"./lib/symbols.js","./Transport":"./lib/Transport.js","./lib/Transport":"./lib/Transport.js","./types":"./lib/types.js","./lib/types":"./lib/types.js","./connection/UndiciConnection":"./lib/connection/UndiciConnection.js","./lib/connection/UndiciConnection":"./lib/connection/UndiciConnection.js","./pool/WeightedConnectionPool":"./lib/pool/WeightedConnectionPool.js","./lib/pool/WeightedConnectionPool":"./lib/pool/WeightedConnectionPool.js"},"scripts":{"test":"npm run build && npm run lint && tap test/{unit,acceptance}/{*,**/*}.test.ts","test:unit":"npm run build && tap test/unit/{*,**/*}.test.ts --disable-coverage","test:acceptance":"npm run build && tap test/acceptance/*.test.ts --disable-coverage","test:coverage-100":"npm run build && tap test/{unit,acceptance}/{*,**/*}.test.ts --show-full-coverage","test:coverage-report":"npm test && tap report --coverage-report=lcov","test:coverage-ui":"npm run build && tap test/{unit,acceptance}/{*,**/*}.test.ts --coverage-report=html","lint":"ts-standard src","lint:fix":"ts-standard --fix src","license-checker":"license-checker --production --onlyAllow=\'MIT;Apache-2.0;Apache1.1;ISC;BSD-3-Clause;BSD-2-Clause;0BSD\'","prebuild":"npm run clean-build && npm run lint","build":"tsc","clean-build":"rimraf ./lib && mkdir lib","prepublishOnly":"npm run build"},"repository":{"type":"git","url":"git+https://github.com/elastic/elastic-transport-js.git"},"keywords":[],"author":{"name":"Elastic Client Library Maintainers","company":"Elastic BV"},"license":"Apache-2.0","bugs":{"url":"https://github.com/elastic/elastic-transport-js/issues"},"homepage":"https://github.com/elastic/elastic-transport-js#readme","engines":{"node":">=18"},"devDependencies":{"@opentelemetry/sdk-trace-base":"1.27.0","@sinonjs/fake-timers":"13.0.4","@tapjs/clock":"3.0.0","@types/debug":"4.1.12","@types/ms":"0.7.34","@types/node":"20.17.0","@types/sinonjs__fake-timers":"8.1.5","@types/stoppable":"1.1.3","@types/tap":"15.0.12","into-stream":"6.0.0","license-checker":"25.0.1","node-abort-controller":"3.1.1","proxy":"1.0.2","rimraf":"6.0.1","stoppable":"1.1.0","tap":"21.0.1","ts-node":"10.9.2","ts-standard":"12.0.2","typescript":"5.6.3","workq":"3.0.0"},"dependencies":{"@opentelemetry/api":"1.x","debug":"^4.3.4","hpagent":"^1.0.0","ms":"^2.1.3","secure-json-parse":"^2.4.0","tslib":"^2.4.0","undici":"^6.12.0"},"tap":{"allow-incomplete-coverage":true,"plugin":["@tapjs/clock","@tapjs/before"]}}');

/***/ })

};
;