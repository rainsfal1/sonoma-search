Serialization

Serialization is the process of converting an in-memory data structure (like an object or a data structure in programming) into a format that can be easily
stored or transmitted. In the context of JSON, this means converting a Rust struct (or any other programming language's object) into a JSON string.

Deserialization

Deserialization is the reverse process of serialization. It involves converting data from a specific
format (like JSON) back into an in-memory data structure (like a Rust struct).

Transport: Manages the connection settings and underlying HTTP communication with the Elasticsearch cluster. The Transport struct allows you to specify various parameters such as the Elasticsearch server's address, authentication credentials, and connection timeouts.
Elasticsearch: The main client for interacting with the cluster, providing a high-level API for various operations. it provides methods for performing various operations such as indexing documents, searching, deleting documents, and managing indices.
SearchParts: A builder for constructing search queries in a type-safe and flexible manner.

bm25_scores.get(&outcome.id): Retrieves the BM25 score for the current document ID from the bm25_scores map.


What is Pagination?
Definition: Pagination is the process of dividing a large set of results into smaller subsets, or "pages." Instead of retrieving all records at once, you only fetch a specific subset based on the current page the user is viewing.

from:
Definition: The from parameter specifies the starting point (or offset) from which to begin retrieving records. It indicates how many records to skip before starting to collect results.

size:
Definition: The size parameter specifies the maximum number of records to return in a single request. It controls how many results are fetched from the database or search engine.


    loop {
        let response = client
            .search(SearchParts::Index(&["processed_docs"]))
            .body(serde_json::json!({
                "query": {
                    "multi_match": {
                        "query": query,
                        "fields": ["title^2", "content_summary", "body"]
                    }
                },
                "fields": ["_id", "_score"],
                "from": from,
                "size": size
            }))
            .send()
            .await?;

Executes a loop that sends a search request to Elasticsearch.
The search is a multi_match query, which searches across the title, content_summary, and body fields. The ^2 boosts the title field to give it more weight in the search.
Pagination is handled by the form and size parameters.


hits and hits Array Logic
In Elasticsearch, the response to a search query contains a hits object that contains information about the search results. Within this hits object, there is another hits array that contains the actual search results.
Here's an example of what the JSON response might look like:

{
  "hits": {
    "total": 100,
    "max_score": 1.0,
    "hits": [
      {
        "_id": "doc1",
        "_score": 0.8,
        "fields": { ... }
      },
      {
        "_id": "doc2",
        "_score": 0.6,
        "fields": { ... }
      },
      ...
    ]
  }
}

In this example, the outer hits object contains metadata about the search results, such as the total number of hits and the maximum score. The inner hits array contains the actual search results, where each element is a JSON object representing a document.
The code is accessing this inner hits array using body["hits"]["hits"]. The as_array() method is used to convert this JSON value into a Rust array (Vec<serde_json::Value>).
